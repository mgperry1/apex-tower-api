--------------------------------------------------------
--  File created - Friday-May-10-2019   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Type EBA_RESTDEMO_GITHUB_REPO_CT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "CHARTER2_INV"."EBA_RESTDEMO_GITHUB_REPO_CT" as table of eba_restdemo_github_repo_t

/
--------------------------------------------------------
--  DDL for Type EBA_RESTDEMO_GITHUB_REPO_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "CHARTER2_INV"."EBA_RESTDEMO_GITHUB_REPO_T" as object(
    name          varchar2(255),
    language      varchar2(50),
    description   varchar2(4000),
    updated_on    timestamp with time zone,
    created_on    timestamp with time zone,
    issues_cnt    number )

/
--------------------------------------------------------
--  DDL for Type FILE_LISTING_NTT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "CHARTER2_INV"."FILE_LISTING_NTT" AS TABLE OF file_listing_ot;

/
--------------------------------------------------------
--  DDL for Type FILE_LISTING_OT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "CHARTER2_INV"."FILE_LISTING_OT" AS OBJECT
    ( file_path VARCHAR(1000)
    , file_name VARCHAR2(100)
    , file_time DATE
    , file_size NUMBER
    );

/
--------------------------------------------------------
--  DDL for Sequence APEX$_WS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."APEX$_WS_SEQ"  MINVALUE 100 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DB_ID
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."DB_ID"  MINVALUE 100 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 ORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEPT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."DEPT_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 50 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence EMP_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."EMP_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8000 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence LOGGER_APX_ITEMS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."LOGGER_APX_ITEMS_SEQ"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence LOGGER_LOGS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."LOGGER_LOGS_SEQ"  MINVALUE 1 MAXVALUE 999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence MSSQL_TEAM_USERS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."MSSQL_TEAM_USERS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 81 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence ORACLE_TEAM_USERS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."ORACLE_TEAM_USERS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 41 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence V_HISTORY_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "CHARTER2_INV"."V_HISTORY_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 15761 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Table APEX$TEAM_DEV_FILES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" 
   (	"ID" NUMBER, 
	"ROW_VERSION_NUMBER" NUMBER, 
	"COMPONENT_ID" NUMBER, 
	"COMPONENT_TYPE" VARCHAR2(30 BYTE), 
	"FILENAME" VARCHAR2(4000 BYTE), 
	"FILE_MIMETYPE" VARCHAR2(512 BYTE), 
	"FILE_CHARSET" VARCHAR2(512 BYTE), 
	"FILE_BLOB" BLOB, 
	"FILE_COMMENTS" VARCHAR2(4000 BYTE), 
	"TAGS" VARCHAR2(4000 BYTE), 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_ACL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_ACL" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"USERNAME" VARCHAR2(255 BYTE), 
	"PRIV" VARCHAR2(1 BYTE), 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_FILES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_FILES" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"ROW_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"COMPONENT_LEVEL" VARCHAR2(30 BYTE), 
	"NAME" VARCHAR2(255 BYTE), 
	"IMAGE_ALIAS" VARCHAR2(255 BYTE), 
	"IMAGE_ATTRIBUTES" VARCHAR2(255 BYTE), 
	"CONTENT" BLOB, 
	"CONTENT_LAST_UPDATE" DATE, 
	"MIME_TYPE" VARCHAR2(255 BYTE), 
	"CONTENT_CHARSET" VARCHAR2(255 BYTE), 
	"CONTENT_FILENAME" VARCHAR2(500 BYTE), 
	"DESCRIPTION" VARCHAR2(4000 BYTE), 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_HISTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_HISTORY" 
   (	"ROW_ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"COLUMN_NAME" VARCHAR2(255 BYTE), 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"NEW_VALUE" VARCHAR2(4000 BYTE), 
	"APPLICATION_USER_ID" VARCHAR2(255 BYTE), 
	"CHANGE_DATE" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_LINKS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_LINKS" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"ROW_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"COMPONENT_LEVEL" VARCHAR2(30 BYTE), 
	"TAGS" VARCHAR2(4000 BYTE), 
	"SHOW_ON_HOMEPAGE" VARCHAR2(1 BYTE), 
	"LINK_NAME" VARCHAR2(255 BYTE), 
	"URL" VARCHAR2(4000 BYTE), 
	"LINK_DESCRIPTION" VARCHAR2(4000 BYTE), 
	"DISPLAY_SEQUENCE" NUMBER, 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_NOTES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_NOTES" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"ROW_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"COMPONENT_LEVEL" VARCHAR2(30 BYTE), 
	"CONTENT" CLOB, 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_ROWS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_ROWS" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"UNIQUE_VALUE" VARCHAR2(255 BYTE), 
	"TAGS" VARCHAR2(4000 BYTE), 
	"PARENT_ROW_ID" NUMBER, 
	"OWNER" VARCHAR2(255 BYTE), 
	"GEOCODE" VARCHAR2(512 BYTE), 
	"LOAD_ORDER" NUMBER, 
	"CHANGE_COUNT" NUMBER, 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"C001" VARCHAR2(4000 BYTE), 
	"C002" VARCHAR2(4000 BYTE), 
	"C003" VARCHAR2(4000 BYTE), 
	"C004" VARCHAR2(4000 BYTE), 
	"C005" VARCHAR2(4000 BYTE), 
	"C006" VARCHAR2(4000 BYTE), 
	"C007" VARCHAR2(4000 BYTE), 
	"C008" VARCHAR2(4000 BYTE), 
	"C009" VARCHAR2(4000 BYTE), 
	"C010" VARCHAR2(4000 BYTE), 
	"C011" VARCHAR2(4000 BYTE), 
	"C012" VARCHAR2(4000 BYTE), 
	"C013" VARCHAR2(4000 BYTE), 
	"C014" VARCHAR2(4000 BYTE), 
	"C015" VARCHAR2(4000 BYTE), 
	"C016" VARCHAR2(4000 BYTE), 
	"C017" VARCHAR2(4000 BYTE), 
	"C018" VARCHAR2(4000 BYTE), 
	"C019" VARCHAR2(4000 BYTE), 
	"C020" VARCHAR2(4000 BYTE), 
	"C021" VARCHAR2(4000 BYTE), 
	"C022" VARCHAR2(4000 BYTE), 
	"C023" VARCHAR2(4000 BYTE), 
	"C024" VARCHAR2(4000 BYTE), 
	"C025" VARCHAR2(4000 BYTE), 
	"C026" VARCHAR2(4000 BYTE), 
	"C027" VARCHAR2(4000 BYTE), 
	"C028" VARCHAR2(4000 BYTE), 
	"C029" VARCHAR2(4000 BYTE), 
	"C030" VARCHAR2(4000 BYTE), 
	"C031" VARCHAR2(4000 BYTE), 
	"C032" VARCHAR2(4000 BYTE), 
	"C033" VARCHAR2(4000 BYTE), 
	"C034" VARCHAR2(4000 BYTE), 
	"C035" VARCHAR2(4000 BYTE), 
	"C036" VARCHAR2(4000 BYTE), 
	"C037" VARCHAR2(4000 BYTE), 
	"C038" VARCHAR2(4000 BYTE), 
	"C039" VARCHAR2(4000 BYTE), 
	"C040" VARCHAR2(4000 BYTE), 
	"C041" VARCHAR2(4000 BYTE), 
	"C042" VARCHAR2(4000 BYTE), 
	"C043" VARCHAR2(4000 BYTE), 
	"C044" VARCHAR2(4000 BYTE), 
	"C045" VARCHAR2(4000 BYTE), 
	"C046" VARCHAR2(4000 BYTE), 
	"C047" VARCHAR2(4000 BYTE), 
	"C048" VARCHAR2(4000 BYTE), 
	"C049" VARCHAR2(4000 BYTE), 
	"C050" VARCHAR2(4000 BYTE), 
	"N001" NUMBER, 
	"N002" NUMBER, 
	"N003" NUMBER, 
	"N004" NUMBER, 
	"N005" NUMBER, 
	"N006" NUMBER, 
	"N007" NUMBER, 
	"N008" NUMBER, 
	"N009" NUMBER, 
	"N010" NUMBER, 
	"N011" NUMBER, 
	"N012" NUMBER, 
	"N013" NUMBER, 
	"N014" NUMBER, 
	"N015" NUMBER, 
	"N016" NUMBER, 
	"N017" NUMBER, 
	"N018" NUMBER, 
	"N019" NUMBER, 
	"N020" NUMBER, 
	"N021" NUMBER, 
	"N022" NUMBER, 
	"N023" NUMBER, 
	"N024" NUMBER, 
	"N025" NUMBER, 
	"N026" NUMBER, 
	"N027" NUMBER, 
	"N028" NUMBER, 
	"N029" NUMBER, 
	"N030" NUMBER, 
	"N031" NUMBER, 
	"N032" NUMBER, 
	"N033" NUMBER, 
	"N034" NUMBER, 
	"N035" NUMBER, 
	"N036" NUMBER, 
	"N037" NUMBER, 
	"N038" NUMBER, 
	"N039" NUMBER, 
	"N040" NUMBER, 
	"N041" NUMBER, 
	"N042" NUMBER, 
	"N043" NUMBER, 
	"N044" NUMBER, 
	"N045" NUMBER, 
	"N046" NUMBER, 
	"N047" NUMBER, 
	"N048" NUMBER, 
	"N049" NUMBER, 
	"N050" NUMBER, 
	"D001" DATE, 
	"D002" DATE, 
	"D003" DATE, 
	"D004" DATE, 
	"D005" DATE, 
	"D006" DATE, 
	"D007" DATE, 
	"D008" DATE, 
	"D009" DATE, 
	"D010" DATE, 
	"D011" DATE, 
	"D012" DATE, 
	"D013" DATE, 
	"D014" DATE, 
	"D015" DATE, 
	"D016" DATE, 
	"D017" DATE, 
	"D018" DATE, 
	"D019" DATE, 
	"D020" DATE, 
	"D021" DATE, 
	"D022" DATE, 
	"D023" DATE, 
	"D024" DATE, 
	"D025" DATE, 
	"D026" DATE, 
	"D027" DATE, 
	"D028" DATE, 
	"D029" DATE, 
	"D030" DATE, 
	"D031" DATE, 
	"D032" DATE, 
	"D033" DATE, 
	"D034" DATE, 
	"D035" DATE, 
	"D036" DATE, 
	"D037" DATE, 
	"D038" DATE, 
	"D039" DATE, 
	"D040" DATE, 
	"D041" DATE, 
	"D042" DATE, 
	"D043" DATE, 
	"D044" DATE, 
	"D045" DATE, 
	"D046" DATE, 
	"D047" DATE, 
	"D048" DATE, 
	"D049" DATE, 
	"D050" DATE, 
	"CLOB001" CLOB, 
	"SEARCH_CLOB" CLOB
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_TAGS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_TAGS" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"DATA_GRID_ID" NUMBER, 
	"ROW_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"COMPONENT_LEVEL" VARCHAR2(30 BYTE), 
	"TAG" VARCHAR2(4000 BYTE), 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_WEBPG_SECTIONS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" 
   (	"ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"DISPLAY_SEQUENCE" NUMBER, 
	"SECTION_TYPE" VARCHAR2(30 BYTE), 
	"TITLE" VARCHAR2(4000 BYTE), 
	"CONTENT" CLOB, 
	"CONTENT_UPPER" CLOB, 
	"NAV_START_WEBPAGE_ID" NUMBER, 
	"NAV_MAX_LEVEL" NUMBER, 
	"NAV_ORDER_BY" VARCHAR2(255 BYTE), 
	"NAV_INCLUDE_LINK" VARCHAR2(1 BYTE), 
	"DATA_GRID_ID" NUMBER, 
	"REPORT_ID" NUMBER, 
	"DATA_SECTION_STYLE" NUMBER, 
	"SHOW_ADD_ROW" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"SHOW_EDIT_ROW" VARCHAR2(1 BYTE) DEFAULT 'N', 
	"SHOW_SEARCH" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"MAX_ROW_COUNT" NUMBER, 
	"CHART_TYPE" VARCHAR2(255 BYTE), 
	"CHART_LABEL" VARCHAR2(255 BYTE), 
	"LABEL_AXIS_TITLE" VARCHAR2(255 BYTE), 
	"CHART_VALUE" VARCHAR2(255 BYTE), 
	"VALUE_AXIS_TITLE" VARCHAR2(255 BYTE), 
	"CHART_AGGREGATE" VARCHAR2(255 BYTE), 
	"CHART_SORTING" VARCHAR2(255 BYTE), 
	"CHART_ORIENTATION" VARCHAR2(10 BYTE), 
	"CHANGE_COUNT" NUMBER, 
	"CREATED_ON" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED_ON" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table APEX$_WS_WEBPG_SECTION_HISTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" 
   (	"SECTION_ID" NUMBER, 
	"WS_APP_ID" NUMBER, 
	"WEBPAGE_ID" NUMBER, 
	"OLD_DISPLAY_SEQUENCE" NUMBER, 
	"NEW_DISPLAY_SEQUENCE" NUMBER, 
	"OLD_TITLE" VARCHAR2(4000 BYTE), 
	"NEW_TITLE" VARCHAR2(4000 BYTE), 
	"OLD_CONTENT" CLOB, 
	"NEW_CONTENT" CLOB, 
	"APPLICATION_USER_ID" VARCHAR2(255 BYTE), 
	"CHANGE_DATE" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table APPLICATION_DETAILS_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."APPLICATION_DETAILS_TBL" 
   (	"APPLICATION_NAME" VARCHAR2(60 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(60 BYTE), 
	"TECHNICAL_CONTACT" VARCHAR2(100 BYTE), 
	"TECH_CONTACT_EMAIL" VARCHAR2(2000 BYTE), 
	"APP_DESC" VARCHAR2(2000 BYTE), 
	"APP_OWNER" VARCHAR2(100 BYTE), 
	"APP_OWNER_EMAIL" VARCHAR2(2000 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table CLUSTER_MEMBER_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."CLUSTER_MEMBER_TBL" 
   (	"CLUSTER_NAME" VARCHAR2(60 BYTE), 
	"CLUSTER_TYPE" VARCHAR2(20 BYTE), 
	"GI_VERSION" VARCHAR2(20 BYTE), 
	"GI_CURRENT_PATCHSET" VARCHAR2(20 BYTE), 
	"HOST_CODE" VARCHAR2(10 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table DB_CHECK_LIST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."DB_CHECK_LIST" 
   (	"DB_ID" NUMBER, 
	"CHECKLIST_TYPE" VARCHAR2(20 BYTE), 
	"POST_BUILD_STATUS" VARCHAR2(20 BYTE), 
	"CLUSTER_VERIFY" VARCHAR2(20 BYTE), 
	"GI_INSTALL_STATUS" VARCHAR2(20 BYTE), 
	"DB_INSTALL_STATUS" VARCHAR2(20 BYTE), 
	"DB_UPGRADE_STATUS" VARCHAR2(20 BYTE), 
	"GI_UPGRADE_STATUS" VARCHAR2(20 BYTE), 
	"MIGRATION_STATUS" VARCHAR2(20 BYTE), 
	"POST_MIGRATION_STATUS" VARCHAR2(20 BYTE), 
	"EXECUTION_ID" VARCHAR2(20 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table DB_INVENTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."DB_INVENTORY" 
   (	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"APPLICATION_NAME" VARCHAR2(60 BYTE), 
	"ENVIRONMENT" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(100 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"RAC_ENABLED" VARCHAR2(3 BYTE) DEFAULT NULL, 
	"RAC_TYPE" VARCHAR2(20 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(60 BYTE), 
	"CLUSTER_NAME" VARCHAR2(100 BYTE), 
	"CLUSTERED" NUMBER(1,0), 
	"APPLIANCE" VARCHAR2(20 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"PCI_REQUIRED" VARCHAR2(10 BYTE), 
	"SOX_REQUIRED" VARCHAR2(10 BYTE), 
	"ENCRYPTION_REQUIRED" VARCHAR2(10 BYTE) DEFAULT NULL, 
	"DATAGUARD" VARCHAR2(20 BYTE), 
	"GOLDEN_GATE" VARCHAR2(3 BYTE) DEFAULT NULL, 
	"BACKUP_ENABLED" VARCHAR2(3 BYTE) DEFAULT NULL, 
	"END_OF_LIFE" VARCHAR2(20 BYTE), 
	"DB_MONITORING_TOOL" VARCHAR2(20 BYTE), 
	"MONITORING" VARCHAR2(20 BYTE), 
	"COMMENTS" VARCHAR2(2000 BYTE), 
	"INSTANCE_COUNT" NUMBER, 
	"DB_SOURCE" VARCHAR2(10 BYTE), 
	"DB_ID" NUMBER, 
	"DR_SOLUTION" VARCHAR2(40 BYTE), 
	"DR_LOCATION" VARCHAR2(20 BYTE), 
	"ENV_CATEGORY" VARCHAR2(10 BYTE), 
	"HOST_CODE" VARCHAR2(20 BYTE), 
	"STORAGE_TYPE" VARCHAR2(10 BYTE), 
	"DECOMMISIONED" VARCHAR2(30 BYTE)
   )   NO INMEMORY ;

   COMMENT ON COLUMN "CHARTER2_INV"."DB_INVENTORY"."CLUSTERED" IS 'Values are 0 for Standalone and 1 for CLustered';
--------------------------------------------------------
--  DDL for Table DB_SCHEDULE_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."DB_SCHEDULE_TBL" 
   (	"DB_ID" NUMBER, 
	"UPGRADE_START_DATE" DATE, 
	"UPGRADE_END_DATE" DATE, 
	"MIGRATION_START_DATE" DATE, 
	"MIGRATION_END_DATE" DATE, 
	"UPGRADE_COMPLETION_TIME" TIMESTAMP (6), 
	"MIGRATION_COMPLETION_TIME" TIMESTAMP (6), 
	"MIGRATION_METHOD" VARCHAR2(20 BYTE), 
	"OUTAGE_WINDOW" NUMBER, 
	"COMMENTS" VARCHAR2(2000 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table DEPT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."DEPT" 
   (	"DEPTNO" NUMBER(2,0), 
	"DNAME" VARCHAR2(14 BYTE), 
	"LOC" VARCHAR2(13 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_BBALL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_BBALL" 
   (	"ID" NUMBER, 
	"CITY" VARCHAR2(20 BYTE), 
	"TEAM" VARCHAR2(30 BYTE), 
	"CONFERENCE" VARCHAR2(5 BYTE), 
	"WINS" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_DEPT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_DEPT" 
   (	"DEPTNO" NUMBER(2,0), 
	"DNAME" VARCHAR2(14 BYTE), 
	"LOC" VARCHAR2(13 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_EMP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_EMP" 
   (	"EMPNO" NUMBER(4,0), 
	"ENAME" VARCHAR2(10 BYTE), 
	"JOB" VARCHAR2(9 BYTE), 
	"MGR" NUMBER(4,0), 
	"HIREDATE" DATE, 
	"SAL" NUMBER(7,2), 
	"COMM" NUMBER(7,2), 
	"DEPTNO" NUMBER(2,0)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_GRADES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_GRADES" 
   (	"ID" NUMBER, 
	"COURSE" VARCHAR2(10 BYTE), 
	"SCHOOLA" NUMBER, 
	"SCHOOLB" NUMBER, 
	"SCHOOLC" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_ORDERS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" 
   (	"ORDER_ID" NUMBER, 
	"PRODUCT_ID" NUMBER, 
	"QUANTITY" NUMBER(8,0), 
	"CUSTOMER" VARCHAR2(30 BYTE), 
	"SALES_DATE" DATE, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_POPULATION
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_POPULATION" 
   (	"ID" NUMBER, 
	"ROW_VERSION_NUMBER" NUMBER, 
	"STATE_NAME" VARCHAR2(100 BYTE), 
	"STATE_CODE" VARCHAR2(2 BYTE), 
	"POPULATION" NUMBER, 
	"REGION" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_PRODUCTS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" 
   (	"PRODUCT_ID" NUMBER, 
	"PRODUCT_NAME" VARCHAR2(50 BYTE), 
	"PRODUCT_DESCRIPTION" VARCHAR2(2000 BYTE), 
	"LIST_PRICE" NUMBER(8,2), 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_PROJECTS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" 
   (	"ID" NUMBER, 
	"PROJECT" VARCHAR2(30 BYTE), 
	"ROW_VERSION_NUMBER" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_SAMPLES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLES" 
   (	"SAMPLE1" NUMBER, 
	"SAMPLE2" NUMBER, 
	"SAMPLE3" NUMBER, 
	"SAMPLE4" NUMBER, 
	"SAMPLE5" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_SAMPLE_DATA
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_DATA" 
   (	"ID" NUMBER, 
	"SAMPLE_ID" NUMBER, 
	"RESPONSE" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_SAMPLE_NAMES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" 
   (	"ID" NUMBER, 
	"SAMPLE_NAME" VARCHAR2(30 BYTE), 
	"SAMPLE_DATE" DATE, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_STATS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STATS" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(2 BYTE), 
	"COUNTRY" VARCHAR2(30 BYTE), 
	"EMPLOYEE" NUMBER, 
	"EMPLOYER" NUMBER, 
	"TOTAL" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_STOCKS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STOCKS" 
   (	"ID" NUMBER, 
	"ROW_VERSION_NUMBER" NUMBER, 
	"STOCK_CODE" VARCHAR2(4 BYTE), 
	"STOCK_NAME" VARCHAR2(130 BYTE), 
	"PRICING_DATE" DATE, 
	"PRICING_TIMESTAMP" TIMESTAMP (6), 
	"PRICING_TIMESTAMP_TZ" TIMESTAMP (6) WITH TIME ZONE, 
	"PRICING_TIMESTAMP_LTZ" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"OPENING_VAL" NUMBER, 
	"HIGH" NUMBER, 
	"LOW" NUMBER, 
	"CLOSING_VAL" NUMBER, 
	"VOLUME" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_DEMO_CHART_TASKS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" 
   (	"ID" NUMBER, 
	"PROJECT" NUMBER, 
	"PARENT_TASK" NUMBER, 
	"TASK_NAME" VARCHAR2(255 BYTE), 
	"ROW_VERSION_NUMBER" NUMBER, 
	"START_DATE" DATE, 
	"END_DATE" DATE, 
	"STATUS" VARCHAR2(30 BYTE), 
	"ASSIGNED_TO" VARCHAR2(30 BYTE), 
	"COST" NUMBER, 
	"BUDGET" NUMBER, 
	"CREATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_RESTDEMO_SAMPLE_EMP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_EMP" 
   (	"EMPNO" NUMBER, 
	"ENAME" VARCHAR2(4000 BYTE), 
	"JOB" VARCHAR2(4000 BYTE), 
	"MGR" NUMBER, 
	"HIREDATE" DATE, 
	"SAL" NUMBER, 
	"DEPTNO" NUMBER, 
	"RN" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_RESTDEMO_SAMPLE_GITHUB
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_GITHUB" 
   (	"NAME" VARCHAR2(255 BYTE), 
	"LANGUAGE" VARCHAR2(50 BYTE), 
	"DESCRIPTION" VARCHAR2(4000 BYTE), 
	"UPDATED_ON" TIMESTAMP (6), 
	"CREATED_ON" TIMESTAMP (6), 
	"ISSUES_CNT" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_RESTDEMO_SAMPLE_LANG
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_LANG" 
   (	"NAME" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EBA_RESTDEMO_SAMPLE_URLS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_URLS" 
   (	"NAME" VARCHAR2(255 BYTE), 
	"URL" VARCHAR2(500 BYTE), 
	"HTTPS_HOST" VARCHAR2(500 BYTE), 
	"LAST_STATUS" VARCHAR2(500 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table EMP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."EMP" 
   (	"EMPNO" NUMBER(4,0), 
	"ENAME" VARCHAR2(10 BYTE), 
	"JOB" VARCHAR2(9 BYTE), 
	"MGR" NUMBER(4,0), 
	"HIREDATE" DATE, 
	"SAL" NUMBER(7,2), 
	"COMM" NUMBER(7,2), 
	"DEPTNO" NUMBER(2,0)
   ) ;
--------------------------------------------------------
--  DDL for Table ENV_HOST_CODE_BACKUP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."ENV_HOST_CODE_BACKUP" 
   (	"HOST_CODE" VARCHAR2(20 BYTE), 
	"ENV_SOURCE" VARCHAR2(4 BYTE), 
	"ENV_NUM" NUMBER
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table ENV_HOST_INFO
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."ENV_HOST_INFO" 
   (	"HOST_CODE" VARCHAR2(20 BYTE), 
	"ENV_SOURCE" VARCHAR2(4 BYTE), 
	"ENV_NUM" NUMBER
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table FILES_XT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."FILES_XT" 
   (	"LAST_MODIFIED" DATE, 
	"SIZE_BYTES" NUMBER, 
	"FILE_NAME" VARCHAR2(255 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "JSON_DATA"
      ACCESS PARAMETERS
      ( RECORDS DELIMITED BY NEWLINE
        nologfile
        LOAD WHEN SIZE_BYTES != '<DIR>'
        PREPROCESSOR json_bin: 'list_files.sh'
            skip 1
            fields terminated by ','           
            ( 
                last_modified date 'YYYY-MM-DD HH24:MI',
                size_bytes,
                file_name
            )
         )
      LOCATION
       ( 'testdir2.txt'
       )
    )
   REJECT LIMIT UNLIMITED ;
--------------------------------------------------------
--  DDL for Table LOGGER_LOGS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."LOGGER_LOGS" 
   (	"ID" NUMBER, 
	"LOGGER_LEVEL" NUMBER, 
	"TEXT" VARCHAR2(4000 BYTE), 
	"TIME_STAMP" TIMESTAMP (6), 
	"SCOPE" VARCHAR2(1000 BYTE), 
	"MODULE" VARCHAR2(100 BYTE), 
	"ACTION" VARCHAR2(100 BYTE), 
	"USER_NAME" VARCHAR2(255 BYTE), 
	"CLIENT_IDENTIFIER" VARCHAR2(255 BYTE), 
	"CALL_STACK" VARCHAR2(4000 BYTE), 
	"UNIT_NAME" VARCHAR2(255 BYTE), 
	"LINE_NO" VARCHAR2(100 BYTE), 
	"SCN" NUMBER, 
	"EXTRA" CLOB, 
	"SID" NUMBER, 
	"CLIENT_INFO" VARCHAR2(64 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table LOGGER_LOGS_APEX_ITEMS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" 
   (	"ID" NUMBER, 
	"LOG_ID" NUMBER, 
	"APP_SESSION" NUMBER, 
	"ITEM_NAME" VARCHAR2(1000 BYTE), 
	"ITEM_VALUE" CLOB
   ) ;
--------------------------------------------------------
--  DDL for Table LOGGER_PREFS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."LOGGER_PREFS" 
   (	"PREF_NAME" VARCHAR2(255 BYTE), 
	"PREF_VALUE" VARCHAR2(255 BYTE), 
	"PREF_TYPE" VARCHAR2(30 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table LOGGER_PREFS_BY_CLIENT_ID
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" 
   (	"CLIENT_ID" VARCHAR2(64 BYTE), 
	"LOGGER_LEVEL" VARCHAR2(20 BYTE), 
	"INCLUDE_CALL_STACK" VARCHAR2(5 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"EXPIRY_DATE" DATE
   ) ;

   COMMENT ON COLUMN "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"."CLIENT_ID" IS 'Client identifier';
   COMMENT ON COLUMN "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"."LOGGER_LEVEL" IS 'Logger level. Must be OFF, PERMANENT, ERROR, WARNING, INFORMATION, DEBUG, TIMING';
   COMMENT ON COLUMN "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"."INCLUDE_CALL_STACK" IS 'Include call stack in logging';
   COMMENT ON COLUMN "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"."CREATED_DATE" IS 'Date that entry was created on';
   COMMENT ON COLUMN "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"."EXPIRY_DATE" IS 'After the given expiry date the logger_level will be disabled for the specific client_id. Unless sepcifically removed from this table a job will clean up old entries';
   COMMENT ON TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID"  IS 'Client specific logger levels. Only active client_ids/logger_levels will be maintained in this table';
--------------------------------------------------------
--  DDL for Table MSSQL_TEAM_USERS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."MSSQL_TEAM_USERS" 
   (	"ID" NUMBER, 
	"USERNAME" VARCHAR2(30 BYTE), 
	"USER_ID" VARCHAR2(30 BYTE), 
	"EMAIL" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table ORACLE_TEAM_USERS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."ORACLE_TEAM_USERS" 
   (	"ID" NUMBER, 
	"CONTACT" VARCHAR2(30 BYTE), 
	"L_CHTR_PID" VARCHAR2(30 BYTE), 
	"L_TWC_VID" VARCHAR2(30 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table REQUEST_QUEUE_DEP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."REQUEST_QUEUE_DEP" 
   (	"ID" NUMBER, 
	"TEMPLATE_NAME" VARCHAR2(50 BYTE), 
	"JOB_ID" VARCHAR2(20 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"JOB_URL" VARCHAR2(75 BYTE), 
	"STATUS" VARCHAR2(1 BYTE), 
	"CLUSTER_NAME" VARCHAR2(50 BYTE), 
	"CLUSTER_TYPE" VARCHAR2(50 BYTE), 
	"GI_VERSION" VARCHAR2(20 BYTE), 
	"ENV_SOURCE" VARCHAR2(20 BYTE), 
	"TICKET_REF" VARCHAR2(50 BYTE), 
	"APPLICATION_NAME" VARCHAR2(100 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(50 BYTE), 
	"DB_OPTION" VARCHAR2(20 BYTE), 
	"HOST_NAME" CLOB, 
	"NETWORK_TYPE" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"OS_TYPE" VARCHAR2(20 BYTE), 
	"OS_TYPE_VERSION" VARCHAR2(20 BYTE), 
	"PHY_VERT" VARCHAR2(20 BYTE), 
	"CLUSTERED" VARCHAR2(20 BYTE), 
	"DC_LOCATION" VARCHAR2(20 BYTE), 
	"SERVER_MONITOTING_TOOL" VARCHAR2(50 BYTE), 
	"DATABASE_NAME" VARCHAR2(50 BYTE), 
	"ENVIRONMENT" VARCHAR2(20 BYTE), 
	"RAC_TYPE" VARCHAR2(20 BYTE), 
	"DATABASE_ROLE" VARCHAR2(30 BYTE), 
	"STORAGE_TYPE" VARCHAR2(20 BYTE), 
	"DB_MONITORING_TOOL" VARCHAR2(50 BYTE), 
	"APPLIANCE" VARCHAR2(20 BYTE), 
	"PCI_REQUIRED" VARCHAR2(20 BYTE), 
	"SOX_REQUIRED" VARCHAR2(20 BYTE), 
	"ENCRYPTION_REQUIRED" VARCHAR2(20 BYTE), 
	"BACKUP_REQUIRED" VARCHAR2(20 BYTE), 
	"MONITORING" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table SOURCE_APP_UPDATE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."SOURCE_APP_UPDATE" 
   (	"SOURCE_APP_UPDATE_ID" NUMBER, 
	"APP_VERSION" VARCHAR2(255 BYTE), 
	"RELEASED_DT" DATE, 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"APPLIED_DT" DATE, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"SUMMARY" VARCHAR2(4000 BYTE), 
	"DESCRIPTION" CLOB, 
	"FILE_LIST" CLOB
   ) ;
--------------------------------------------------------
--  DDL for Table SOURCE_OBJECT_DETAILS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."SOURCE_OBJECT_DETAILS" 
   (	"OWNER" VARCHAR2(128 BYTE), 
	"OBJECT_NAME" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(23 BYTE), 
	"STATUS" VARCHAR2(7 BYTE), 
	"VERSION" CHAR(3 BYTE), 
	"DEPLOYED_ON" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table TEMP_COUNT_MSTR
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."TEMP_COUNT_MSTR" 
   (	"CAT" VARCHAR2(5 BYTE), 
	"CNT" NUMBER, 
	"SRC" CHAR(3 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table TEMP_LIST_MAP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."TEMP_LIST_MAP" 
   (	"INVID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"USAGEID" NUMBER, 
	"DB_NAME" VARCHAR2(255 BYTE), 
	"HOST" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table TEMP_LIST_MAP_COMP1
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."TEMP_LIST_MAP_COMP1" 
   (	"INVID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"USAGEID" NUMBER, 
	"DB_NAME" VARCHAR2(255 BYTE), 
	"HOST" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table TEMP_LIST_MAP_COMP2
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."TEMP_LIST_MAP_COMP2" 
   (	"INVID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"USAGEID" NUMBER, 
	"DB_NAME" VARCHAR2(255 BYTE), 
	"HOST" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table TEMP_LIST_MAP_EXADATA
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."TEMP_LIST_MAP_EXADATA" 
   (	"INVID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"USAGEID" NUMBER, 
	"DB_NAME" VARCHAR2(255 BYTE), 
	"HOST" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_API_RESULT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_API_RESULT" 
   (	"REQUEST_ID" NUMBER, 
	"REQUEST_TYPE" VARCHAR2(30 BYTE), 
	"CALL_URL" VARCHAR2(1000 BYTE), 
	"RESPONSE" CLOB, 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"BODY" CLOB
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_GROUPS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_GROUPS" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"URL" VARCHAR2(1000 BYTE), 
	"INVENTORY" NUMBER, 
	"TOTAL_HOSTS" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_HOSTS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_HOSTS" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"URL" VARCHAR2(1000 BYTE), 
	"INVENTORY" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_INVENTORIES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_INVENTORIES" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"ORGANIZATION" NUMBER, 
	"VARIABLES" VARCHAR2(4000 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_JOB_TEMPLATES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_JOB_TEMPLATES" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"PLAYBOOK" VARCHAR2(1000 BYTE), 
	"URL" VARCHAR2(1000 BYTE), 
	"INVENTORY" NUMBER, 
	"TEMPLATE_TYPE" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_ORGANIZATIONS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_ORGANIZATIONS" 
   (	"ID" NUMBER, 
	"NAME" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_REST_LOGS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" 
   (	"ID" NUMBER, 
	"FILE_PATH" VARCHAR2(1000 BYTE), 
	"FILE_NAME" VARCHAR2(255 BYTE), 
	"FILE_SIZE" NUMBER, 
	"FILE_TIME" DATE, 
	"STATUS" VARCHAR2(1 BYTE), 
	"REF_TBL_NAME" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;

   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_REST_LOGS"."STATUS" IS 'I= Inserted, P=Processed';
--------------------------------------------------------
--  DDL for Table V_ANSIBLE_TEMPLATE_STORE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" 
   (	"ID" NUMBER, 
	"TEMPLATE_NAME" VARCHAR2(200 BYTE), 
	"TEMPLATE_TYPE" VARCHAR2(10 BYTE), 
	"TEMPLATE_DESC" VARCHAR2(2000 BYTE), 
	"APEX_FEATURE" VARCHAR2(100 BYTE), 
	"APEX_MENU_ITEM" VARCHAR2(100 BYTE), 
	"CREATED" DATE DEFAULT SYSDATE, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"TEMPLATE_STATUS" VARCHAR2(20 BYTE), 
	"TEMPLATE_ID" NUMBER, 
	"APEX_APP_ID" NUMBER, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE)
   ) ;

   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."TEMPLATE_NAME" IS 'ansible template name';
   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."TEMPLATE_TYPE" IS 'w=workflow , p = playbook';
   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."APEX_MENU_ITEM" IS 'apex page reference';
   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."TEMPLATE_STATUS" IS 'A= Active , I =InActive';
   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."TEMPLATE_ID" IS 'ansible template id';
   COMMENT ON COLUMN "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE"."APEX_APP_ID" IS 'apex app reference';
  GRANT SELECT ON "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_APPLICATION_DETAILS_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" 
   (	"ID" NUMBER, 
	"APPLICATION_NAME" VARCHAR2(60 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(60 BYTE), 
	"TECHNICAL_CONTACT" VARCHAR2(255 BYTE), 
	"TECH_CONTACT_EMAIL" VARCHAR2(2000 BYTE), 
	"APP_DESC" VARCHAR2(2000 BYTE), 
	"APP_OWNER" VARCHAR2(255 BYTE), 
	"APP_OWNER_EMAIL" VARCHAR2(2000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"REF_APP_ID" VARCHAR2(50 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_APP_FILES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_FILES" 
   (	"PERMISSIONS" VARCHAR2(15 BYTE), 
	"HARD_LINKS" NUMBER, 
	"FILE_OWNER" VARCHAR2(32 BYTE), 
	"GROUP_NAME" VARCHAR2(32 BYTE), 
	"SIZE_BYTES" NUMBER, 
	"LAST_MODIFIED" DATE, 
	"FILE_NAME" VARCHAR2(255 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "JSON_DATA"
      ACCESS PARAMETERS
      ( records delimited by newline
            nologfile
            preprocessor json_bin : 'list_files2.sh'           
            skip 1
            fields terminated by ','           
            ( 
                permissions,
                hard_links,
                file_owner,
                group_name,
                size_bytes,
                last_modified date 'YYYY-MM-DD HH24:MI',
                file_name
            )
                )
      LOCATION
       ( 'testdir.txt'
       )
    );
--------------------------------------------------------
--  DDL for Table V_APP_FILES2
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_FILES2" 
   (	"PERMISSIONS" VARCHAR2(15 BYTE), 
	"HARD_LINKS" NUMBER, 
	"FILE_OWNER" VARCHAR2(32 BYTE), 
	"GROUP_NAME" VARCHAR2(32 BYTE), 
	"SIZE_BYTES" NUMBER, 
	"LAST_MODIFIED" DATE, 
	"FILE_NAME" VARCHAR2(255 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "JSON_DATA"
      ACCESS PARAMETERS
      ( records delimited by newline
            nologfile
            preprocessor json_bin : 'list_files2.sh'           
            skip 1
            fields terminated by ','           
            ( 
                permissions,
                hard_links,
                file_owner,
                group_name,
                size_bytes,
                last_modified date 'YYYY-MM-DD HH24:MI',
                file_name
            )
            )
      LOCATION
       ( 'testdir.txt'
       )
    );
--------------------------------------------------------
--  DDL for Table V_APP_NEWS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_NEWS" 
   (	"ID" NUMBER, 
	"HEADLINE" VARCHAR2(1000 BYTE), 
	"DETAIL" CLOB, 
	"START_DISPLAY" DATE, 
	"EXPIRE_DISPLAY" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table V_APP_PERSON
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_PERSON" 
   (	"PERSON_ID" NUMBER, 
	"APP_ID" VARCHAR2(255 BYTE), 
	"USERNAME" VARCHAR2(255 BYTE), 
	"APP_ROLE" VARCHAR2(255 BYTE), 
	"APP_ADMIN" VARCHAR2(255 BYTE), 
	"CREATED_ON" DATE, 
	"DISPLAY_NAME" VARCHAR2(255 BYTE), 
	"EMAIL_ADDR" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_APP_PERSON_ROLES
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_PERSON_ROLES" 
   (	"PERSON_ID" NUMBER, 
	"ROLE_ID" NUMBER, 
	"CREATED_ON" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table V_APP_ROLE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_ROLE" 
   (	"ROLE_ID" NUMBER, 
	"APP_ID" VARCHAR2(255 BYTE), 
	"APP_ROLE" VARCHAR2(255 BYTE), 
	"APP_ADMIN" VARCHAR2(255 BYTE), 
	"CREATED_ON" DATE, 
	"DESCRIPTION" VARCHAR2(4000 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_APP_SETTINGS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_APP_SETTINGS" 
   (	"ID" NUMBER, 
	"SETTING_NAME" VARCHAR2(255 BYTE), 
	"SETTING_VALUE" VARCHAR2(2000 BYTE), 
	"SETTING_DESC" VARCHAR2(2000 BYTE), 
	"SETTING_CATEGORY" VARCHAR2(100 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"APEX_APP_ID" NUMBER
   ) ;
  GRANT SELECT ON "CHARTER2_INV"."V_APP_SETTINGS" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_APP_SETTINGS" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_APP_SETTINGS" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_APP_SETTINGS" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_CHECKLIST_STATUS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_CHECKLIST_STATUS" 
   (	"STATUS_ID" NUMBER, 
	"TASK_ID" VARCHAR2(255 BYTE), 
	"TASK_KEY" VARCHAR2(1000 BYTE), 
	"TASK_AREA" VARCHAR2(1000 BYTE), 
	"TASK_STATUS" VARCHAR2(255 BYTE), 
	"TASK_MESSAGE" VARCHAR2(4000 BYTE), 
	"FILE_NAME" VARCHAR2(1000 BYTE), 
	"FILE_MIMETYPE" VARCHAR2(255 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"TASK_BODY" CLOB, 
	"FILE_UPLOAD" BLOB, 
	"RECORD_TYPE" VARCHAR2(255 BYTE), 
	"STANDARD_TASK_ID" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_CHECK_LIST_LOGS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_CHECK_LIST_LOGS" 
   (	"LOG_ID" NUMBER, 
	"CHECK_LIST_ID" NUMBER, 
	"LOG_FILE" BLOB, 
	"FILE_TYPE" VARCHAR2(100 BYTE), 
	"MIME_TYPE" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"LOG_FILE_DESC" VARCHAR2(100 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_CLUSTER_MEMBER_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" 
   (	"ID" NUMBER, 
	"CLUSTER_NAME" VARCHAR2(60 BYTE), 
	"CLUSTER_TYPE" VARCHAR2(20 BYTE), 
	"GI_VERSION" VARCHAR2(20 BYTE), 
	"GI_CURRENT_PATCHSET" VARCHAR2(20 BYTE), 
	"V_HOST_CODE" VARCHAR2(10 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"ENV_SOURCE" VARCHAR2(4 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_CSI_LIST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_CSI_LIST" 
   (	"CSI" VARCHAR2(20 BYTE), 
	"CSI_TYPE" VARCHAR2(20 BYTE), 
	"CSI_PRODUCT_TYPE" VARCHAR2(20 BYTE), 
	"CSI_TERM" VARCHAR2(20 BYTE), 
	"MASTER_ASSET_CODE" VARCHAR2(20 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_CSI_PRODUCT_LIST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_CSI_PRODUCT_LIST" 
   (	"CSI" VARCHAR2(20 BYTE), 
	"PRODUCT_NAME" VARCHAR2(1000 BYTE), 
	"PRODUCT_CATEGORY" VARCHAR2(40 BYTE), 
	"SUPPORT_LEVEL" VARCHAR2(100 BYTE), 
	"CONTRACT_EXPIRATION" DATE, 
	"ENTITLEMENT" VARCHAR2(1000 BYTE), 
	"LICENSE_TYPE" VARCHAR2(20 BYTE), 
	"LICENSE_COUNT" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_DB_CHECK_LIST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" 
   (	"CHECK_LIST_ID" NUMBER, 
	"CHECKLIST_TYPE" VARCHAR2(200 BYTE), 
	"POST_BUILD_STATUS" VARCHAR2(200 BYTE), 
	"CLUSTER_VERIFY" VARCHAR2(200 BYTE), 
	"GI_INSTALL_STATUS" VARCHAR2(200 BYTE), 
	"DB_INSTALL_STATUS" VARCHAR2(200 BYTE), 
	"DB_UPGRADE_STATUS" VARCHAR2(200 BYTE), 
	"GI_UPGRADE_STATUS" VARCHAR2(200 BYTE), 
	"MIGRATION_STATUS" VARCHAR2(200 BYTE), 
	"POST_MIGRATION_STATUS" VARCHAR2(200 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"LOG_FILE" BLOB, 
	"FILE_TYPE" VARCHAR2(20 BYTE), 
	"CHECKLIST_CATEGORY" VARCHAR2(100 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"DB_NAME" VARCHAR2(50 BYTE), 
	"CLUSTER_NAME" VARCHAR2(100 BYTE), 
	"TASK_DESC" VARCHAR2(200 BYTE), 
	"TICKET_REF" VARCHAR2(255 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_DB_INVENTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_DB_INVENTORY" 
   (	"ID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"APPLICATION_NAME" VARCHAR2(60 BYTE), 
	"ENVIRONMENT" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"RAC_TYPE" VARCHAR2(20 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(60 BYTE), 
	"APPLIANCE" VARCHAR2(20 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"PCI_REQUIRED" VARCHAR2(10 BYTE), 
	"SOX_REQUIRED" VARCHAR2(10 BYTE), 
	"ENCRYPTION_REQUIRED" VARCHAR2(10 BYTE), 
	"DATAGUARD" VARCHAR2(20 BYTE), 
	"GOLDEN_GATE" VARCHAR2(10 BYTE), 
	"BACKUP_ENABLED" VARCHAR2(10 BYTE), 
	"END_OF_LIFE" VARCHAR2(20 BYTE), 
	"DB_MONITORING_TOOL" VARCHAR2(20 BYTE), 
	"MONITORING" VARCHAR2(20 BYTE), 
	"COMMENTS" VARCHAR2(2000 BYTE), 
	"INSTANCE_COUNT" NUMBER, 
	"DB_SOURCE" VARCHAR2(10 BYTE), 
	"DR_SOLUTION" VARCHAR2(40 BYTE), 
	"DR_LOCATION" VARCHAR2(20 BYTE), 
	"ENV_CATEGORY" VARCHAR2(10 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"APP_ID" NUMBER, 
	"STORAGE_TYPE" VARCHAR2(20 BYTE), 
	"DB_HOME" VARCHAR2(20 BYTE), 
	"SW_CSI" VARCHAR2(20 BYTE), 
	"REF_APP_ID" VARCHAR2(100 BYTE), 
	"DECOMMISIONED" VARCHAR2(30 BYTE), 
	"DB_CREATION_DATE" DATE
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_DB_PATCH_HISTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_DB_PATCH_HISTORY" 
   (	"ID" NUMBER, 
	"DB_ID" NUMBER, 
	"PSU_QUARTER" VARCHAR2(10 BYTE), 
	"PSU_NUMBER" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"LS_INVENT" BLOB, 
	"CREATED_BY" VARCHAR2(60 BYTE), 
	"PSU_YEAR" VARCHAR2(4 BYTE), 
	"PATCH_LOG" BLOB, 
	"HOST_CODE" VARCHAR2(20 BYTE), 
	"PATCH_TYPE" VARCHAR2(20 BYTE), 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"DB_HOME" VARCHAR2(20 BYTE), 
	"PATCH_STATUS" VARCHAR2(200 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_DB_SCHEDULE_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" 
   (	"ID" NUMBER, 
	"UPGRADE_START_DATE" DATE, 
	"UPGRADE_END_DATE" DATE, 
	"MIGRATION_START_DATE" DATE, 
	"MIGRATION_END_DATE" DATE, 
	"UPGRADE_COMPLETION_TIME" VARCHAR2(4000 BYTE), 
	"MIGRATION_COMPLETION_TIME" VARCHAR2(4000 BYTE), 
	"MIGRATION_METHOD" VARCHAR2(20 BYTE), 
	"OUTAGE_WINDOW" NUMBER, 
	"COMMENTS" VARCHAR2(2000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"DB_ID" NUMBER, 
	"MIGRATION_DEST" VARCHAR2(100 BYTE), 
	"MIGRATION_DEST_HOST_CODE" VARCHAR2(10 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_HISTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_HISTORY" 
   (	"ID" NUMBER, 
	"TABLE_NAME" VARCHAR2(128 BYTE), 
	"COLUMN_NAME" VARCHAR2(128 BYTE), 
	"ACTION" VARCHAR2(1 BYTE), 
	"ACTION_DATE" DATE, 
	"ACTION_BY" VARCHAR2(255 BYTE), 
	"DATA_TYPE" VARCHAR2(255 BYTE), 
	"PK1" NUMBER, 
	"TAB_ROW_VERSION" NUMBER(*,0), 
	"OLD_VC" VARCHAR2(4000 BYTE), 
	"NEW_VC" VARCHAR2(4000 BYTE), 
	"OLD_NUMBER" NUMBER, 
	"NEW_NUMBER" NUMBER, 
	"OLD_DATE" DATE, 
	"NEW_DATE" DATE, 
	"OLD_TS" TIMESTAMP (6), 
	"NEW_TS" TIMESTAMP (6), 
	"OLD_TSWTZ" TIMESTAMP (6) WITH TIME ZONE, 
	"NEW_TSWTZ" TIMESTAMP (6) WITH TIME ZONE, 
	"OLD_TSWLTZ" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"NEW_TSWLTZ" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"OLD_CLOB" CLOB, 
	"NEW_CLOB" CLOB, 
	"OLD_BLOB" BLOB, 
	"NEW_BLOB" BLOB
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_HOST_INV_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_HOST_INV_TBL" 
   (	"ID" NUMBER, 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"NETWORK_TYPE" VARCHAR2(40 BYTE), 
	"CORE_COUNT" NUMBER, 
	"PROCESSOR_CONFIG_SPEED" VARCHAR2(30 BYTE), 
	"SERVER_MODEL" VARCHAR2(100 BYTE), 
	"HARDWARE_VENDOR" VARCHAR2(20 BYTE), 
	"OS_TYPE_VERSION" VARCHAR2(20 BYTE), 
	"PROCESSOR_BIT" VARCHAR2(20 BYTE), 
	"SERVER_CREATION_DATE" VARCHAR2(20 BYTE), 
	"PHY_VIRT" VARCHAR2(20 BYTE), 
	"DC_LOCATION" VARCHAR2(20 BYTE), 
	"GLOBAL_ZONE_SOLARIS" VARCHAR2(20 BYTE), 
	"PHY_MEMORY" VARCHAR2(10 BYTE), 
	"SERVER_MONITORING_TOOL" VARCHAR2(100 BYTE), 
	"HOST_CODE" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"DB_ID" NUMBER, 
	"CLUSTER_ID" NUMBER, 
	"CLUSTERED" VARCHAR2(1 BYTE), 
	"OS_TYPE" VARCHAR2(20 BYTE), 
	"ENV_SOURCE" VARCHAR2(4 BYTE), 
	"HW_CSI" VARCHAR2(20 BYTE), 
	"DECOMMISIONED" VARCHAR2(30 BYTE), 
	"IP_ADDRESS" VARCHAR2(255 BYTE), 
	"SCAN_IP_ADDRESS" VARCHAR2(255 BYTE), 
	"VIP_IP_ADDRESS" VARCHAR2(255 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_ITSM_API_RESULT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_API_RESULT" 
   (	"REQUEST_ID" NUMBER, 
	"REQUEST_TYPE" VARCHAR2(30 BYTE), 
	"CALL_URL" VARCHAR2(1000 BYTE), 
	"RESPONSE" CLOB, 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"BODY" CLOB, 
	"RUN_ID" NUMBER
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_ITSM_CHANGE_REQUEST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_CHANGE_REQUEST" 
   (	"NAME" VARCHAR2(1000 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"CHANGE_ID" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(255 BYTE), 
	"TEST_PLAN" VARCHAR2(1000 BYTE), 
	"IMPLEMENTATION_PLAN" VARCHAR2(1000 BYTE), 
	"CHANGE_PLAN" VARCHAR2(1000 BYTE), 
	"BACKOUT_PLAN" VARCHAR2(1000 BYTE), 
	"ASSIGNMENT_GROUP" VARCHAR2(255 BYTE), 
	"STATE" VARCHAR2(255 BYTE), 
	"PHASE" VARCHAR2(255 BYTE), 
	"IMPACT" VARCHAR2(255 BYTE), 
	"CMDB_CI_SYS_ID" VARCHAR2(255 BYTE), 
	"CLOSED_AT" VARCHAR2(255 BYTE), 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"PRIORITY" VARCHAR2(255 BYTE), 
	"PRODUCTION_SYSTEM" VARCHAR2(255 BYTE), 
	"REQUESTED_BY" VARCHAR2(255 BYTE), 
	"ASSIGNED_TO" VARCHAR2(255 BYTE), 
	"BUSINESS_SERVICE" VARCHAR2(255 BYTE), 
	"REVIEW_DATE" VARCHAR2(255 BYTE), 
	"START_DATE" VARCHAR2(255 BYTE), 
	"END_DATE" VARCHAR2(255 BYTE), 
	"CONFLICT_STATUS" VARCHAR2(255 BYTE), 
	"OPENED_AT" VARCHAR2(255 BYTE), 
	"PARENT" VARCHAR2(255 BYTE), 
	"SPECIAL_INSTRUCTIONS" VARCHAR2(255 BYTE), 
	"WORK_NOTES" VARCHAR2(255 BYTE), 
	"SHORT_DESCRIPTION" VARCHAR2(255 BYTE), 
	"WORK_START" VARCHAR2(255 BYTE), 
	"WORK_NOTES_LIST" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"REQUESTED_DATE" VARCHAR2(255 BYTE), 
	"URGENCY" VARCHAR2(255 BYTE), 
	"CONTACT_TYPE" VARCHAR2(255 BYTE), 
	"CLOSED_BY" VARCHAR2(255 BYTE), 
	"CLOSE_NOTES" VARCHAR2(255 BYTE), 
	"COMMENTS_AND_WORK_NOTES" VARCHAR2(255 BYTE), 
	"APPROVAL" VARCHAR2(255 BYTE), 
	"SLA_DUE" VARCHAR2(255 BYTE), 
	"DUE_DATE" VARCHAR2(255 BYTE), 
	"REQUEST_STATE" VARCHAR2(255 BYTE), 
	"STAGE" VARCHAR2(255 BYTE), 
	"ESCALATION" VARCHAR2(255 BYTE), 
	"UPON_APPROVAL" VARCHAR2(255 BYTE), 
	"OPENED_BY" VARCHAR2(255 BYTE), 
	"SKILLS" VARCHAR2(255 BYTE), 
	"REQUESTED_FOR" VARCHAR2(255 BYTE), 
	"MADE_SLA" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE), 
	"OWNED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"MANAGED_BY_SYS_ID" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_CI_APPL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_CI_APPL" 
   (	"NAME" VARCHAR2(1000 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"OWNED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"MANAGED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"U_APPLICATION_ID" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"USED_FOR" VARCHAR2(255 BYTE), 
	"UNVERIFIED" VARCHAR2(255 BYTE), 
	"INSTALL_DIRECTORY" VARCHAR2(255 BYTE), 
	"INSTALL_DATE" VARCHAR2(255 BYTE), 
	"ASSET_TAG" VARCHAR2(255 BYTE), 
	"OPERATIONAL_STATUS" VARCHAR2(255 BYTE), 
	"CHANGE_CONTROL_GROUP" VARCHAR2(255 BYTE), 
	"DELIVERY_DATE" VARCHAR2(255 BYTE), 
	"INSTALL_STATUS" VARCHAR2(255 BYTE), 
	"SUBCATEGORY" VARCHAR2(255 BYTE), 
	"ASSIGNMENT_GROUP" VARCHAR2(255 BYTE), 
	"EDITION" VARCHAR2(255 BYTE), 
	"PO_NUMBER" VARCHAR2(255 BYTE), 
	"DEPARTMENT" VARCHAR2(255 BYTE), 
	"COMMENTS" VARCHAR2(255 BYTE), 
	"GL_ACCOUNT" VARCHAR2(255 BYTE), 
	"INVOICE_NUMBER" VARCHAR2(255 BYTE), 
	"WARRANTY_EXPIRATION" VARCHAR2(255 BYTE), 
	"COST_CC" VARCHAR2(255 BYTE), 
	"ORDER_DATE" VARCHAR2(255 BYTE), 
	"SCHEDULE" VARCHAR2(255 BYTE), 
	"DUE" VARCHAR2(255 BYTE), 
	"LOCATION" VARCHAR2(255 BYTE), 
	"CATEGORY" VARCHAR2(255 BYTE), 
	"LEASE_ID" VARCHAR2(255 BYTE), 
	"U_VRR_RATING" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_CORRELATION" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_ID" VARCHAR2(255 BYTE), 
	"U_DATA_CATEGORY" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_STATUS" VARCHAR2(255 BYTE), 
	"U_DATA_CLASSIFICATION" VARCHAR2(255 BYTE), 
	"U_IP_NETMASK" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_CMDB_CI
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_CMDB_CI" 
   (	"NAME" VARCHAR2(1000 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"OWNED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"MANAGED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"U_APPLICATION_ID" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"USED_FOR" VARCHAR2(255 BYTE), 
	"UNVERIFIED" VARCHAR2(255 BYTE), 
	"INSTALL_DIRECTORY" VARCHAR2(255 BYTE), 
	"INSTALL_DATE" VARCHAR2(255 BYTE), 
	"ASSET_TAG" VARCHAR2(255 BYTE), 
	"OPERATIONAL_STATUS" VARCHAR2(255 BYTE), 
	"CHANGE_CONTROL_GROUP" VARCHAR2(255 BYTE), 
	"DELIVERY_DATE" VARCHAR2(255 BYTE), 
	"INSTALL_STATUS" VARCHAR2(255 BYTE), 
	"SUBCATEGORY" VARCHAR2(255 BYTE), 
	"ASSIGNMENT_GROUP" VARCHAR2(255 BYTE), 
	"EDITION" VARCHAR2(255 BYTE), 
	"PO_NUMBER" VARCHAR2(255 BYTE), 
	"DEPARTMENT" VARCHAR2(255 BYTE), 
	"COMMENTS" VARCHAR2(255 BYTE), 
	"GL_ACCOUNT" VARCHAR2(255 BYTE), 
	"INVOICE_NUMBER" VARCHAR2(255 BYTE), 
	"WARRANTY_EXPIRATION" VARCHAR2(255 BYTE), 
	"COST_CC" VARCHAR2(255 BYTE), 
	"ORDER_DATE" VARCHAR2(255 BYTE), 
	"SCHEDULE" VARCHAR2(255 BYTE), 
	"DUE" VARCHAR2(255 BYTE), 
	"LOCATION" VARCHAR2(255 BYTE), 
	"CATEGORY" VARCHAR2(255 BYTE), 
	"LEASE_ID" VARCHAR2(255 BYTE), 
	"IP_ADDRESS" VARCHAR2(255 BYTE), 
	"U_VRR_RATING" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_CORRELATION" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_ID" VARCHAR2(255 BYTE), 
	"U_DATA_CATEGORY" VARCHAR2(255 BYTE), 
	"U_SCIENCELOGIC_STATUS" VARCHAR2(255 BYTE), 
	"U_DATA_CLASSIFICATION" VARCHAR2(255 BYTE), 
	"U_IP_NETMASK" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_SC_REQUEST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_SC_REQUEST" 
   (	"NAME" VARCHAR2(1000 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"TICKET_ID" VARCHAR2(255 BYTE), 
	"DESCRIPTION" CLOB, 
	"ASSIGNMENT_GROUP" VARCHAR2(255 BYTE), 
	"STATE" VARCHAR2(255 BYTE), 
	"CLOSED_AT" VARCHAR2(255 BYTE), 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"PRIORITY" VARCHAR2(255 BYTE), 
	"BUSINESS_SERVICE" VARCHAR2(255 BYTE), 
	"OPENED_AT" VARCHAR2(255 BYTE), 
	"PARENT" VARCHAR2(255 BYTE), 
	"SPECIAL_INSTRUCTIONS" VARCHAR2(4000 BYTE), 
	"WORK_NOTES" CLOB, 
	"SHORT_DESCRIPTION" VARCHAR2(4000 BYTE), 
	"WORK_START" VARCHAR2(255 BYTE), 
	"WORK_NOTES_LIST" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"REQUESTED_DATE" VARCHAR2(255 BYTE), 
	"URGENCY" VARCHAR2(255 BYTE), 
	"CONTACT_TYPE" VARCHAR2(255 BYTE), 
	"CLOSED_BY" VARCHAR2(255 BYTE), 
	"CLOSE_NOTES" VARCHAR2(255 BYTE), 
	"ASSIGNED_TO" VARCHAR2(255 BYTE), 
	"COMMENTS" CLOB, 
	"APPROVAL" VARCHAR2(255 BYTE), 
	"SLA_DUE" VARCHAR2(255 BYTE), 
	"COMMENTS_AND_WORK_NOTES" CLOB, 
	"DUE_DATE" VARCHAR2(255 BYTE), 
	"REQUEST_STATE" VARCHAR2(255 BYTE), 
	"STAGE" VARCHAR2(255 BYTE), 
	"ESCALATION" VARCHAR2(255 BYTE), 
	"UPON_APPROVAL" VARCHAR2(255 BYTE), 
	"OPENED_BY" VARCHAR2(255 BYTE), 
	"SKILLS" VARCHAR2(255 BYTE), 
	"REQUESTED_FOR" VARCHAR2(255 BYTE), 
	"MADE_SLA" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE), 
	"OWNED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"MANAGED_BY_SYS_ID" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_SC_REQ_ITEM
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_SC_REQ_ITEM" 
   (	"NAME" VARCHAR2(1000 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"TICKET_ID" VARCHAR2(255 BYTE), 
	"REQUEST_SYS_ID" VARCHAR2(255 BYTE), 
	"SHORT_DESCRIPTION" VARCHAR2(4000 BYTE), 
	"DESCRIPTION" CLOB, 
	"ASSIGNMENT_GROUP" VARCHAR2(255 BYTE), 
	"STATE" VARCHAR2(255 BYTE), 
	"CLOSED_AT" VARCHAR2(255 BYTE), 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"PRIORITY" VARCHAR2(255 BYTE), 
	"BUSINESS_SERVICE" VARCHAR2(255 BYTE), 
	"OPENED_AT" VARCHAR2(255 BYTE), 
	"PARENT" VARCHAR2(255 BYTE), 
	"SPECIAL_INSTRUCTIONS" VARCHAR2(4000 BYTE), 
	"WORK_NOTES" CLOB, 
	"WORK_START" VARCHAR2(255 BYTE), 
	"WORK_NOTES_LIST" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"REQUESTED_DATE" VARCHAR2(255 BYTE), 
	"URGENCY" VARCHAR2(255 BYTE), 
	"CONTACT_TYPE" VARCHAR2(255 BYTE), 
	"CLOSED_BY" VARCHAR2(255 BYTE), 
	"CLOSE_NOTES" VARCHAR2(255 BYTE), 
	"ASSIGNED_TO" VARCHAR2(255 BYTE), 
	"COMMENTS" CLOB, 
	"APPROVAL" VARCHAR2(255 BYTE), 
	"SLA_DUE" VARCHAR2(255 BYTE), 
	"COMMENTS_AND_WORK_NOTES" CLOB, 
	"DUE_DATE" VARCHAR2(255 BYTE), 
	"REQUEST_STATE" VARCHAR2(255 BYTE), 
	"STAGE" VARCHAR2(255 BYTE), 
	"ESCALATION" VARCHAR2(255 BYTE), 
	"UPON_APPROVAL" VARCHAR2(255 BYTE), 
	"OPENED_BY" VARCHAR2(255 BYTE), 
	"SKILLS" VARCHAR2(255 BYTE), 
	"REQUESTED_FOR" VARCHAR2(255 BYTE), 
	"MADE_SLA" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE), 
	"OWNED_BY_SYS_ID" VARCHAR2(255 BYTE), 
	"MANAGED_BY_SYS_ID" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_SYS_USER
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_SYS_USER" 
   (	"NAME" VARCHAR2(255 BYTE), 
	"FIRST_NAME" VARCHAR2(255 BYTE), 
	"LAST_NAME" VARCHAR2(255 BYTE), 
	"SYS_ID" VARCHAR2(255 BYTE), 
	"VIP" VARCHAR2(255 BYTE), 
	"STREET" VARCHAR2(1000 BYTE), 
	"CITY" VARCHAR2(255 BYTE), 
	"STATE" VARCHAR2(255 BYTE), 
	"ZIP" VARCHAR2(255 BYTE), 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"MOBILE_PHONE" VARCHAR2(255 BYTE), 
	"PHONE" VARCHAR2(255 BYTE), 
	"HOME_PHONE" VARCHAR2(255 BYTE), 
	"TITLE" VARCHAR2(255 BYTE), 
	"COST_CENTER" VARCHAR2(255 BYTE), 
	"EMPLOYEE_NUMBER" VARCHAR2(255 BYTE), 
	"EMAIL" VARCHAR2(255 BYTE), 
	"GENDER" VARCHAR2(255 BYTE), 
	"USER_NAME" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"DEPARTMENT" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_SYS_USER_GRMEMBER
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_SYS_USER_GRMEMBER" 
   (	"USER_SYS_ID" VARCHAR2(255 BYTE), 
	"GROUP_SYS_ID" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_ITSM_SYS_USER_GROUP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_ITSM_SYS_USER_GROUP" 
   (	"SYS_ID" VARCHAR2(255 BYTE), 
	"NAME" VARCHAR2(1000 BYTE), 
	"ACTIVE" VARCHAR2(255 BYTE), 
	"MANAGER" VARCHAR2(255 BYTE), 
	"COMPANY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_BY" VARCHAR2(255 BYTE), 
	"SYS_CREATED_ON" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_BY" VARCHAR2(255 BYTE), 
	"SYS_UPDATED_ON" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LICENSE_FEATURE_USAGE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LICENSE_FEATURE_USAGE" 
   (	"HOST_NAME" VARCHAR2(255 BYTE), 
	"INSTANCE_NAME" VARCHAR2(255 BYTE), 
	"DATABASE_NAME" VARCHAR2(255 BYTE), 
	"OPEN_MODE" VARCHAR2(255 BYTE), 
	"DATABASE_ROLE" VARCHAR2(255 BYTE), 
	"CREATED" DATE, 
	"DBID" NUMBER, 
	"VERSION" VARCHAR2(255 BYTE), 
	"BANNER" VARCHAR2(255 BYTE), 
	"PRODUCT" VARCHAR2(255 BYTE), 
	"FEATURE_BEING_USED" VARCHAR2(255 BYTE), 
	"USAGE" VARCHAR2(255 BYTE), 
	"LAST_SAMPLE_DATE" DATE, 
	"DETECTED_USAGES" NUMBER, 
	"TOTAL_SAMPLES" NUMBER, 
	"CURRENTLY_USED" VARCHAR2(255 BYTE), 
	"FIRST_USAGE_DATE" DATE, 
	"LAST_USAGE_DATE" DATE, 
	"EXTRA_FEATURE_INFO" VARCHAR2(4000 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LICENSE_PRODUCT_USAGE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LICENSE_PRODUCT_USAGE" 
   (	"HOST_NAME" VARCHAR2(255 BYTE), 
	"INSTANCE_NAME" VARCHAR2(255 BYTE), 
	"DATABASE_NAME" VARCHAR2(255 BYTE), 
	"OPEN_MODE" VARCHAR2(255 BYTE), 
	"DATABASE_ROLE" VARCHAR2(255 BYTE), 
	"CREATED" DATE, 
	"DBID" NUMBER, 
	"VERSION" VARCHAR2(255 BYTE), 
	"BANNER" VARCHAR2(255 BYTE), 
	"GID" NUMBER, 
	"CON_ID" NUMBER, 
	"CON_NAME" VARCHAR2(255 BYTE), 
	"PRODUCT" VARCHAR2(255 BYTE), 
	"USAGE" VARCHAR2(255 BYTE), 
	"LAST_SAMPLE_DATE" DATE, 
	"FIRST_USAGE_DATE" DATE, 
	"LAST_USAGE_DATE" DATE
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_BASELINE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_BASELINE" 
   (	"BASELINE_ID" NUMBER, 
	"BASELINE_NAME" VARCHAR2(1000 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"STATUS" VARCHAR2(255 BYTE), 
	"START_DT" DATE, 
	"END_DT" DATE, 
	"DATA_PULL_FREQUENCY" VARCHAR2(1000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"EMAIL_ADDR" VARCHAR2(1000 BYTE), 
	"COMPARE_KEY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_BASELINE_JSONLOAD
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_BASELINE_JSONLOAD" 
   (	"JSON_LOAD_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"STATUS_ID" NUMBER, 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"DATABASE_NAME" VARCHAR2(255 BYTE), 
	"HOST_NAME" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_DB_INVENTORY
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" 
   (	"DATABASE_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"DATABASE_NAME" VARCHAR2(40 BYTE), 
	"APPLICATION_NAME" VARCHAR2(60 BYTE), 
	"ENVIRONMENT" VARCHAR2(20 BYTE), 
	"ORACLE_VERSION" VARCHAR2(20 BYTE), 
	"RAC_TYPE" VARCHAR2(20 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(60 BYTE), 
	"APPLIANCE" VARCHAR2(20 BYTE), 
	"DATABASE_ROLE" VARCHAR2(20 BYTE), 
	"PCI_REQUIRED" VARCHAR2(10 BYTE), 
	"SOX_REQUIRED" VARCHAR2(10 BYTE), 
	"ENCRYPTION_REQUIRED" VARCHAR2(10 BYTE), 
	"DATAGUARD" VARCHAR2(20 BYTE), 
	"GOLDEN_GATE" VARCHAR2(10 BYTE), 
	"BACKUP_ENABLED" VARCHAR2(10 BYTE), 
	"END_OF_LIFE" VARCHAR2(20 BYTE), 
	"DB_MONITORING_TOOL" VARCHAR2(20 BYTE), 
	"MONITORING" VARCHAR2(20 BYTE), 
	"COMMENTS" VARCHAR2(2000 BYTE), 
	"INSTANCE_COUNT" NUMBER, 
	"DB_SOURCE" VARCHAR2(10 BYTE), 
	"DR_SOLUTION" VARCHAR2(40 BYTE), 
	"DR_LOCATION" VARCHAR2(20 BYTE), 
	"ENV_CATEGORY" VARCHAR2(10 BYTE), 
	"V_HOST_CODE" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE), 
	"APP_ID" NUMBER, 
	"STORAGE_TYPE" VARCHAR2(20 BYTE), 
	"DB_HOME" VARCHAR2(20 BYTE), 
	"SW_CSI" VARCHAR2(20 BYTE), 
	"REF_APP_ID" VARCHAR2(100 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_DISCOVERY_SCHEDULE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_DISCOVERY_SCHEDULE" 
   (	"LIC_SCHEDULE_ID" NUMBER, 
	"SCHEDULE_NAME" VARCHAR2(255 BYTE), 
	"SCHEDULE_TYPE" VARCHAR2(30 BYTE), 
	"TICKET_REF" VARCHAR2(255 BYTE), 
	"HOST_NAME" CLOB, 
	"FILTER_PARMS" CLOB, 
	"EXECUTE_INTERVAL" VARCHAR2(255 BYTE), 
	"SCHEDULE_START_HR" VARCHAR2(255 BYTE), 
	"LAST_START_TIME" DATE, 
	"NUMBER_OF_RUNS" NUMBER, 
	"LAST_SCHEDULE_ID" NUMBER, 
	"STATUS" VARCHAR2(255 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"SCHEDULE_START_DATE" DATE, 
	"CURRENT_SCHEDULE_ID" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_FEATURE_USAGE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_FEATURE_USAGE" 
   (	"FEATURE_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"HOST_NAME" VARCHAR2(255 BYTE), 
	"INSTANCE_NAME" VARCHAR2(255 BYTE), 
	"DATABASE_NAME" VARCHAR2(255 BYTE), 
	"OPEN_MODE" VARCHAR2(255 BYTE), 
	"DATABASE_ROLE" VARCHAR2(255 BYTE), 
	"DBCREATED" DATE, 
	"DBID" NUMBER, 
	"VERSION" VARCHAR2(255 BYTE), 
	"BANNER" VARCHAR2(255 BYTE), 
	"PRODUCT" VARCHAR2(255 BYTE), 
	"FEATURE_BEING_USED" VARCHAR2(255 BYTE), 
	"USAGE" VARCHAR2(255 BYTE), 
	"LAST_SAMPLE_DATE" DATE, 
	"DETECTED_USAGES" NUMBER, 
	"TOTAL_SAMPLES" NUMBER, 
	"CURRENTLY_USED" VARCHAR2(255 BYTE), 
	"FIRST_USAGE_DATE" DATE, 
	"LAST_USAGE_DATE" DATE, 
	"EXTRA_FEATURE_INFO" VARCHAR2(4000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_HOST_INV
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_HOST_INV" 
   (	"HOST_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"HOST_NAME" VARCHAR2(200 BYTE), 
	"NETWORK_TYPE" VARCHAR2(40 BYTE), 
	"LIC_CORE" NUMBER, 
	"CORE_COUNT" NUMBER, 
	"PROCESSOR_CONFIG_SPEED" VARCHAR2(30 BYTE), 
	"SERVER_MODEL" VARCHAR2(255 BYTE), 
	"HARDWARE_VENDOR" VARCHAR2(255 BYTE), 
	"OS_TYPE_VERSION" VARCHAR2(255 BYTE), 
	"PROCESSOR_BIT" VARCHAR2(255 BYTE), 
	"SERVER_CREATION_DATE" VARCHAR2(255 BYTE), 
	"PHY_VIRT" VARCHAR2(255 BYTE), 
	"DC_LOCATION" VARCHAR2(256 BYTE), 
	"GLOBAL_ZONE_SOLARIS" VARCHAR2(255 BYTE), 
	"PHY_MEMORY" VARCHAR2(10 BYTE), 
	"SERVER_MONITORING_TOOL" VARCHAR2(100 BYTE), 
	"HOST_CODE" VARCHAR2(255 BYTE), 
	"DB_ID" NUMBER, 
	"CLUSTER_ID" NUMBER, 
	"CLUSTERED" VARCHAR2(255 BYTE), 
	"OS_TYPE" VARCHAR2(20 BYTE), 
	"ENV_SOURCE" VARCHAR2(4 BYTE), 
	"HW_CSI" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_PRODUCT_PRICE_LIST
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_PRODUCT_PRICE_LIST" 
   (	"PRODUCT_PRICE_ID" NUMBER, 
	"PRODUCT_NAME" VARCHAR2(1000 BYTE), 
	"PRODUCT_KEY" VARCHAR2(1000 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"LISTPRICE_PER_PROCESSOR" NUMBER, 
	"LISTPRICE_PER_NAMED_USER" NUMBER, 
	"PRICE_PER_PROCESSOR" NUMBER, 
	"PRICE_PER_NAMED_USER" NUMBER, 
	"CURRENCY" VARCHAR2(1000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_PRODUCT_USAGE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" 
   (	"PRODUCT_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"HOST_NAME" VARCHAR2(255 BYTE), 
	"INSTANCE_NAME" VARCHAR2(255 BYTE), 
	"DATABASE_NAME" VARCHAR2(255 BYTE), 
	"OPEN_MODE" VARCHAR2(255 BYTE), 
	"DATABASE_ROLE" VARCHAR2(255 BYTE), 
	"DBCREATED" DATE, 
	"DBID" NUMBER, 
	"VERSION" VARCHAR2(255 BYTE), 
	"BANNER" VARCHAR2(255 BYTE), 
	"GID" NUMBER, 
	"CON_ID" NUMBER, 
	"CON_NAME" VARCHAR2(255 BYTE), 
	"PRODUCT" VARCHAR2(255 BYTE), 
	"USAGE" VARCHAR2(255 BYTE), 
	"LAST_SAMPLE_DATE" DATE, 
	"FIRST_USAGE_DATE" DATE, 
	"LAST_USAGE_DATE" DATE, 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LIC_PURCHASED_PRODUCTS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LIC_PURCHASED_PRODUCTS" 
   (	"PRODUCT_ID" NUMBER, 
	"BASELINE_ID" NUMBER, 
	"PRODUCT_NAME" VARCHAR2(1000 BYTE), 
	"PRODUCT_KEY" VARCHAR2(1000 BYTE), 
	"FEATURE_NAME" VARCHAR2(1000 BYTE), 
	"FEATURE_KEY" VARCHAR2(1000 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"PURCHASED" DATE, 
	"CSI" VARCHAR2(1000 BYTE), 
	"PROCESSOR_LICENSES" NUMBER, 
	"NAMED_USER_LICENSES" NUMBER, 
	"PRICE_PER_PROCESSOR" NUMBER, 
	"PRICE_PER_NAMED_USER" NUMBER, 
	"CURRENCY" VARCHAR2(1000 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_LOV_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_LOV_TBL" 
   (	"LOV_ID" NUMBER, 
	"LOV_VALUE" VARCHAR2(100 BYTE), 
	"LOV_CATEGORY" VARCHAR2(20 BYTE), 
	"LOV_ACTIVE" VARCHAR2(255 BYTE), 
	"LOV_PAGE" VARCHAR2(255 BYTE), 
	"LOV_DISPLAY_VALUE" VARCHAR2(255 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_PATCH_LOOKUP_TBL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" 
   (	"ID" NUMBER, 
	"PATCH_FILE_NAME" VARCHAR2(255 BYTE), 
	"PATCH_TYPE" VARCHAR2(15 BYTE), 
	"PATCH_QUARTER" VARCHAR2(10 BYTE), 
	"PATCH_YEAR" NUMBER(4,0), 
	"SOFTWARE_VERSION" VARCHAR2(10 BYTE), 
	"OPATCH_VERSION" VARCHAR2(20 BYTE), 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"PATCH_STATUS" VARCHAR2(10 BYTE), 
	"OPATCH_FILE" VARCHAR2(255 BYTE), 
	"OJVM_PATCH" VARCHAR2(255 BYTE), 
	"PSU_VERSION" VARCHAR2(40 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_PATCH_REQUEST_QUEUE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" 
   (	"ID" NUMBER, 
	"TEMPLATE_TYPE" VARCHAR2(1 BYTE), 
	"TEMPLATE_NAME" VARCHAR2(50 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"REQUEST_TYPE" VARCHAR2(25 BYTE) DEFAULT 'PROVISIONING', 
	"HOST_NAME" CLOB, 
	"CLUSTER_NAME" VARCHAR2(50 BYTE), 
	"TICKET_REF" VARCHAR2(50 BYTE), 
	"DC_LOCATION" VARCHAR2(50 BYTE), 
	"RDBMS_HOME" VARCHAR2(20 BYTE), 
	"PATCH_FILE_NAME" VARCHAR2(255 BYTE), 
	"STATUS" VARCHAR2(30 BYTE), 
	"CREATED" DATE DEFAULT SYSDATE, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION','app_user'),regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*'),sys_context('userenv','session_user')), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(50 BYTE), 
	"EXTRA_VARS" CLOB, 
	"JOB_ID" NUMBER, 
	"REQUEST_ID" NUMBER, 
	"PATCH_TYPE" VARCHAR2(255 BYTE), 
	"TARGET_TYPE" VARCHAR2(255 BYTE), 
	"GROUP_ID" NUMBER, 
	"CHANGE_REQ" VARCHAR2(255 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_PATCH_SCHEDULE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_PATCH_SCHEDULE" 
   (	"PATCH_SCHED_ID" NUMBER, 
	"HOST_CODE" VARCHAR2(20 BYTE), 
	"PATCH_DATE" DATE, 
	"APP_ID" NUMBER, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"PATCH_TYPE" VARCHAR2(20 BYTE), 
	"PATCH_CATEGORY" VARCHAR2(20 BYTE), 
	"RDBMS_HOME" VARCHAR2(20 BYTE), 
	"PATCH_LOOKUP_ID" NUMBER, 
	"TICKET_REF" VARCHAR2(50 BYTE), 
	"DC_LOCATION" VARCHAR2(50 BYTE), 
	"HOST_NAME" VARCHAR2(50 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_PROCESS_STATUS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_PROCESS_STATUS" 
   (	"STATUS_ID" NUMBER, 
	"TASK_ID" VARCHAR2(255 BYTE), 
	"TASK_KEY" VARCHAR2(1000 BYTE), 
	"TASK_AREA" VARCHAR2(1000 BYTE), 
	"TASK_STATUS" VARCHAR2(255 BYTE), 
	"TASK_MESSAGE" VARCHAR2(4000 BYTE), 
	"FILE_NAME" VARCHAR2(1000 BYTE), 
	"FILE_MIMETYPE" VARCHAR2(255 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"TASK_BODY" CLOB, 
	"FILE_UPLOAD" BLOB, 
	"RECORD_TYPE" VARCHAR2(255 BYTE), 
	"STANDARD_TASK_ID" NUMBER
   ) ;
--------------------------------------------------------
--  DDL for Table V_REGISTRY_SQLPATCH
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_REGISTRY_SQLPATCH" 
   (	"ID" NUMBER, 
	"HOST_NAME" VARCHAR2(64 BYTE), 
	"INSTANCE_NAME" VARCHAR2(30 BYTE), 
	"DATABASE_NAME" VARCHAR2(30 BYTE), 
	"OPEN_MODE" VARCHAR2(20 BYTE), 
	"DATABASE_ROLE" VARCHAR2(16 BYTE), 
	"DB_CREATED" DATE, 
	"DB_ID" NUMBER, 
	"VERSION" VARCHAR2(17 BYTE), 
	"BANNER" VARCHAR2(80 BYTE), 
	"ACTION_TIME" TIMESTAMP (6), 
	"DESCRIPTION" VARCHAR2(100 BYTE), 
	"PATCH_ID" NUMBER, 
	"STATUS" VARCHAR2(15 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED" DATE, 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE)
   ) ;
--------------------------------------------------------
--  DDL for Table V_REQUEST_QUEUE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_REQUEST_QUEUE" 
   (	"ID" NUMBER, 
	"TEMPLATE_TYPE" VARCHAR2(1 BYTE), 
	"TEMPLATE_NAME" VARCHAR2(50 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"REQUEST_TYPE" VARCHAR2(25 BYTE) DEFAULT 'PROVISIONING', 
	"DB_OPTION" VARCHAR2(10 BYTE), 
	"HOST_NAME" CLOB, 
	"CLUSTER_NAME" VARCHAR2(100 BYTE), 
	"CLUSTER_TYPE" VARCHAR2(50 BYTE), 
	"GI_VERSION" VARCHAR2(50 BYTE), 
	"ENV_SOURCE" VARCHAR2(50 BYTE), 
	"TICKET_REF" VARCHAR2(50 BYTE), 
	"APPLICATION_NAME" VARCHAR2(100 BYTE), 
	"BUSINESS_UNIT" VARCHAR2(50 BYTE), 
	"NETWORK_TYPE" VARCHAR2(50 BYTE), 
	"ORACLE_VERSION" VARCHAR2(50 BYTE), 
	"OS_TYPE" VARCHAR2(50 BYTE), 
	"OS_TYPE_VERSION" VARCHAR2(50 BYTE), 
	"PHY_VERT" VARCHAR2(50 BYTE), 
	"CLUSTERED" VARCHAR2(50 BYTE), 
	"DC_LOCATION" VARCHAR2(50 BYTE), 
	"SERVER_MONITORING_TOOL" VARCHAR2(50 BYTE), 
	"ORACLE_DB_NAME" VARCHAR2(50 BYTE), 
	"DB_ENVIRONMENT" VARCHAR2(50 BYTE), 
	"RAC_TYPE" VARCHAR2(50 BYTE), 
	"DATABASE_ROLE" VARCHAR2(50 BYTE), 
	"ENV_CATEGORY" VARCHAR2(50 BYTE), 
	"STORAGE_TYPE" VARCHAR2(50 BYTE), 
	"DB_MONITORING_TOOL" VARCHAR2(50 BYTE), 
	"APPLIANCE" VARCHAR2(1 BYTE), 
	"PCI_REQUIRED" VARCHAR2(1 BYTE), 
	"SOX_REQUIRED" VARCHAR2(1 BYTE), 
	"ENCRYPTION_REQUIRED" VARCHAR2(1 BYTE), 
	"BACKUP_ENABLED" VARCHAR2(1 BYTE), 
	"MONITORING" VARCHAR2(1 BYTE), 
	"STATUS" VARCHAR2(1 BYTE), 
	"CREATED" DATE DEFAULT SYSDATE, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION','app_user'),regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*'),sys_context('userenv','session_user')), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(50 BYTE), 
	"EXTRA_VARS" CLOB, 
	"GROUP_ID" NUMBER
   ) ;

   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."TEMPLATE_TYPE" IS 'W= Workflow, Playbook = P';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."TEMPLATE_NAME" IS 'Name of the template';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."JOB_NAME" IS 'name of the job, which need to submit';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."REQUEST_TYPE" IS 'default is provisioning';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."DB_OPTION" IS 'DB/NONDB which define job to be execute for workflow';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."HOST_NAME" IS 'In general single host name but for cluster workflow can be comma separated list of host names';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."PHY_VERT" IS 'physical or virtual';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."DC_LOCATION" IS 'data center location';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."RAC_TYPE" IS 'This is equal to the Cluster Type';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."STATUS" IS 'P= Pending, E = executed, O = obsulated';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."EXTRA_VARS" IS 'store json structure for the extra vals';
   COMMENT ON COLUMN "CHARTER2_INV"."V_REQUEST_QUEUE"."GROUP_ID" IS 'stores group id created during execution of the process. Which being use to delete group after completion of process.';
  GRANT ALTER ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_REQUEST_QUEUE" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Table V_REST_DEFINITIONS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_REST_DEFINITIONS" 
   (	"ID" NUMBER, 
	"SCHEMA_ENABLE" VARCHAR2(4000 BYTE), 
	"SCHEMA_ENABLE_FLAG" VARCHAR2(1 BYTE), 
	"MODULE_NAME" VARCHAR2(4000 BYTE), 
	"URI_PREFIX" VARCHAR2(4000 BYTE), 
	"URI_TEMPLATE" VARCHAR2(4000 BYTE), 
	"METHOD" VARCHAR2(4000 BYTE), 
	"REST_ACTION" VARCHAR2(4000 BYTE), 
	"REST_CODE" CLOB, 
	"CREATED" DATE, 
	"CREATED_BY" VARCHAR2(255 BYTE), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(255 BYTE)
   )   NO INMEMORY ;
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_QUEUE
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_QUEUE" 
   (	"SCHEDULE_ID" NUMBER, 
	"SCHEDULE_TYPE" VARCHAR2(30 BYTE), 
	"SCHEDULE_PROCESS" VARCHAR2(255 BYTE), 
	"TASK_ID" NUMBER, 
	"APPROVAL_PROCESS_ID" NUMBER, 
	"APPROVAL_REQUIRED" VARCHAR2(255 BYTE), 
	"TICKET_REF" VARCHAR2(255 BYTE), 
	"UNIQUE_GRP" VARCHAR2(255 BYTE), 
	"REQ_QUEUE_ID" NUMBER, 
	"SELF_SERVICE_REQUEST_ID" NUMBER, 
	"HOST_NAME" CLOB, 
	"TASK_PARMS" CLOB, 
	"REQUEST_START_TIME_C" VARCHAR2(255 BYTE), 
	"REQUEST_START_TIME" DATE, 
	"PROCESS_START_TIME" DATE, 
	"STATUS" VARCHAR2(255 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE)
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_QUEUE_DETAIL
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" 
   (	"SCHEDULE_DETAIL_ID" NUMBER, 
	"SCHEDULE_ID" NUMBER, 
	"TASK_ID" NUMBER, 
	"STEP_ID" NUMBER, 
	"TEMPLATE_TYPE" VARCHAR2(10 BYTE), 
	"TEMPLATE_NAME" VARCHAR2(255 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"JOB_NO" VARCHAR2(20 BYTE), 
	"TICKET_REF" VARCHAR2(255 BYTE), 
	"UNIQUE_GRP" VARCHAR2(255 BYTE), 
	"EXTRA_VARS" CLOB, 
	"HOST_NAME" CLOB, 
	"TASK_PARMS" CLOB, 
	"PROCESS_START_TIME" DATE, 
	"STATUS" VARCHAR2(255 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"TEMPLATE_ID" VARCHAR2(255 BYTE), 
	"REQ_QUEUE_ID" NUMBER, 
	"SELF_SERVICE_REQUEST_ID" NUMBER, 
	"GROUP_ID" NUMBER
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_TASK
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_TASK" 
   (	"TASK_ID" NUMBER, 
	"TASK_NAME" VARCHAR2(255 BYTE), 
	"TASK_ICON" VARCHAR2(255 BYTE), 
	"TASK_TYPE" VARCHAR2(255 BYTE), 
	"EXECUTION_MODE" VARCHAR2(255 BYTE), 
	"DESCRIPTION" VARCHAR2(4000 BYTE), 
	"PRIVILEGE_ROLE" VARCHAR2(255 BYTE), 
	"APPROVAL_PROCESS_ID" NUMBER, 
	"APPROVAL_REQUIRED" VARCHAR2(255 BYTE), 
	"STATUS" VARCHAR2(255 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"INCLUDE_IMPACT_REPORT" VARCHAR2(255 BYTE), 
	"TASK_KEY" VARCHAR2(255 BYTE), 
	"SHOW_DATABASE" VARCHAR2(255 BYTE), 
	"SHOW_DB_HOME" VARCHAR2(255 BYTE), 
	"SHOW_DC_LOCATION" VARCHAR2(255 BYTE), 
	"SHOW_APP_ID" VARCHAR2(255 BYTE), 
	"SHOW_PROJECT" VARCHAR2(255 BYTE), 
	"SHOW_DB_CONFIG" VARCHAR2(255 BYTE), 
	"SHOW_CLUSTER" VARCHAR2(255 BYTE), 
	"SHOW_DB_VERSION" VARCHAR2(255 BYTE), 
	"SHOW_DOMAIN" VARCHAR2(255 BYTE), 
	"SHOW_ENVIRONMENT" VARCHAR2(255 BYTE), 
	"EXEC_TARGET_PAGE" VARCHAR2(255 BYTE), 
	"CANCEL_TARGET_PAGE" VARCHAR2(255 BYTE), 
	"SHOW_SCHEDULE" VARCHAR2(255 BYTE), 
	"SHOW_GRID_VERSION" VARCHAR2(255 BYTE)
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_TASK_PARMS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" 
   (	"PARM_ID" NUMBER, 
	"TASK_ID" NUMBER, 
	"PARM_NAME" VARCHAR2(255 BYTE), 
	"PARM_TYPE" VARCHAR2(255 BYTE), 
	"PARM_VAR" VARCHAR2(255 BYTE), 
	"PARM_DEFAULT" VARCHAR2(1000 BYTE), 
	"LOV_NAME" VARCHAR2(255 BYTE), 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"PARM_SEQ" NUMBER
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_TASK_REPORT
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" 
   (	"REPORT_ID" NUMBER, 
	"TASK_ID" NUMBER, 
	"REPORT_SEQ" NUMBER, 
	"REPORT_NAME" VARCHAR2(255 BYTE), 
	"DISPLAY_NAME" VARCHAR2(255 BYTE), 
	"REPORT_TYPE" VARCHAR2(255 BYTE), 
	"REPORT_LOCATION" VARCHAR2(255 BYTE), 
	"REPORT_SQL" CLOB, 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE)
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SCHEDULE_TASK_STEP
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" 
   (	"STEP_ID" NUMBER, 
	"TASK_ID" NUMBER, 
	"STEP_NAME" VARCHAR2(255 BYTE), 
	"STEP_TYPE" VARCHAR2(255 BYTE), 
	"TEMPLATE_TYPE" VARCHAR2(10 BYTE), 
	"TEMPLATE_NAME" VARCHAR2(255 BYTE), 
	"EXTRA_VARS" CLOB, 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"STEP_SEQ" NUMBER, 
	"TEMPLATE_ID" VARCHAR2(255 BYTE)
   ) ;
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT ALTER ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Table V_SELF_SERVICE_STATUS
--------------------------------------------------------

  CREATE TABLE "CHARTER2_INV"."V_SELF_SERVICE_STATUS" 
   (	"REQUEST_ID" NUMBER, 
	"REQUEST_TYPE" VARCHAR2(30 BYTE), 
	"JOB_NAME" VARCHAR2(50 BYTE), 
	"JOB_NO" VARCHAR2(20 BYTE), 
	"JOB_RESULT" VARCHAR2(10 BYTE), 
	"TICKET_REF" VARCHAR2(100 BYTE), 
	"TARGET_NAME" VARCHAR2(4000 BYTE), 
	"JOB_URL" VARCHAR2(75 BYTE), 
	"RESULT_STDOUT" CLOB, 
	"CREATED" DATE DEFAULT sysdate, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')                                       , sys_context('userenv','session_user') ), 
	"UPDATED" DATE, 
	"UPDATED_BY" VARCHAR2(100 BYTE), 
	"REQ_QUEUE_ID" NUMBER
   )   NO INMEMORY ;

   COMMENT ON COLUMN "CHARTER2_INV"."V_SELF_SERVICE_STATUS"."REQ_QUEUE_ID" IS 'fk to v_request_queue table';
  GRANT DELETE ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "CHARTER2_SQL";
  GRANT ALTER ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT INDEX ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SELF_SERVICE_STATUS" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for View APP_DB_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."APP_DB_DETAIL" ("APPLICATION_NAME", "Database_Name", "BUSINESS_UNIT", "APP_OWNER", "EMAIL", "ENV_CATEGORY", "ORACLE_VERSION", "DATABASE_ROLE") AS 
  SELECT a.APPLICATION_NAME, b.database_name "Database_Name", a.BUSINESS_UNIT, a.APP_OWNER, a.APP_OWNER_EMAIL "EMAIL",
        b.ENV_CATEGORY, b.ORACLE_VERSION,b.DATABASE_ROLE
FROM 
    V_APPLICATION_DETAILS_TBL a, v_db_inventory b
    where a.APPLICATION_NAME = b.APPLICATION_NAME
;
--------------------------------------------------------
--  DDL for View CLUSTER_DC_MAPPING
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."CLUSTER_DC_MAPPING" ("CLUSTER_NAME", "V_HOST_CODE", "DC_LOCATION") AS 
  Select distinct a.cluster_name, a.v_host_code, b.DC_LOCATION from v_cluster_member_tbl a, v_host_inv_tbl b
where a.v_host_code = b.host_code
;
--------------------------------------------------------
--  DDL for View DB_APP_DETAIL_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."DB_APP_DETAIL_VW" ("DATABASE_NAME", "ENV_CATEGORY", "ORACLE_VERSION", "DATABASE_ROLE", "APPLICATION_NAME", "BUSINESS_UNIT", "APP_OWNER", "EMAIL", "REF_APP_ID", "DB_ID") AS 
  SELECT
        b.database_name,
        b.env_category,
        b.oracle_version,
        b.database_role,
        a.application_name,
        a.business_unit,      
        a.app_owner,
        a.app_owner_email   EMAIL,
        a.ref_app_id,
        b.id db_id
    FROM
        v_application_details_tbl a,
        v_db_inventory b
    WHERE
         b.application_name = a.application_name(+)
;
--------------------------------------------------------
--  DDL for View DB_MIGRATION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."DB_MIGRATION_VW" ("DB_ID", "DATABASE_NAME", "MIGRATION_START_DATE", "MIGRATION_END_DATE", "MIGRATION_COMPLETION_TIME", "MIGRATION_METHOD", "APPLICATION_NAME", "APP_OWNER", "APP_OWNER_EMAIL") AS 
  SELECT b.DB_ID, a.DATABASE_NAME,b.MIGRATION_START_DATE,b.MIGRATION_END_DATE,b.MIGRATION_COMPLETION_TIME, b.MIGRATION_METHOD,c.application_name,c.APP_OWNER, c.APP_OWNER_EMAIL
from v_db_inventory a , V_DB_SCHEDULE_TBL b , V_APPLICATION_DETAILS_TBL c 
where a.id = b.DB_ID and a.app_id = c.ID
;
--------------------------------------------------------
--  DDL for View DB_UPGRADE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."DB_UPGRADE_VW" ("DB_ID", "DATABASE_NAME", "UPGRADE_START_DATE", "UPGRADE_END_DATE", "UPGRADE_COMPLETION_TIME", "APPLICATION_NAME", "APP_OWNER", "APP_OWNER_EMAIL") AS 
  SELECT b.DB_ID, a.DATABASE_NAME,b.UPGRADE_START_DATE,b.UPGRADE_END_DATE,b.UPGRADE_COMPLETION_TIME, c.application_name,c.APP_OWNER, c.APP_OWNER_EMAIL
from v_db_inventory a , V_DB_SCHEDULE_TBL b , V_APPLICATION_DETAILS_TBL c 
where a.id = b.DB_ID and a.app_id = c.ID
;
--------------------------------------------------------
--  DDL for View DB_VERSION_LOOKUP_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."DB_VERSION_LOOKUP_VW" ("ORACLE_VERSION", "MAIN_EOL", "EXTENDED_EOL") AS 
  select 
v.oracle_version
,max(
case 
when oracle_version like '8%' then
to_date('01/01/2005','MM/DD/RRRR')
when oracle_version like '9%' then
to_date('05/01/2008','MM/DD/RRRR')
when oracle_version like '10.1%' then
to_date('01/31/2009','MM/DD/RRRR')
when oracle_version like '10.2%' then
to_date('07/31/2010','MM/DD/RRRR')
when oracle_version like '11.1%' then
to_date('08/31/2012','MM/DD/RRRR')
when oracle_version like '11.2%' then
to_date('08/31/2015','MM/DD/RRRR')
when oracle_version like '12.1%' then
to_date('08/01/2018','MM/DD/RRRR')
when oracle_version like '12.2%' then
to_date('08/01/2020','MM/DD/RRRR')
else
null
end
) MAIN_EOL
,max(
case 
when oracle_version like '8%' then
to_date('01/01/2008','MM/DD/RRRR')
when oracle_version like '9%' then
to_date('05/01/2009','MM/DD/RRRR')
when oracle_version like '10.1%' then
to_date('07/31/2010','MM/DD/RRRR')
when oracle_version like '10.2%' then
to_date('08/31/2012','MM/DD/RRRR')
when oracle_version like '11.1%' then
to_date('08/31/2015','MM/DD/RRRR')
when oracle_version like '11.2%' then
to_date('12/31/2020','MM/DD/RRRR')
when oracle_version like '12.1%' then
to_date('12/31/2022','MM/DD/RRRR')
when oracle_version like '12.2%' then
to_date('12/31/2023','MM/DD/RRRR')
else
null
end
) EXTENDED_EOL
 from 
(
select

v.lov_value oracle_version
from v_lov_tbl v
where
v.lov_category = 'DB_SOFTWARE'
) v
 group by oracle_version
;
--------------------------------------------------------
--  DDL for View HOST_BU_VENDOR_VERSION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_BU_VENDOR_VERSION_VW" ("BUSINESS_UNIT", "HARDWARE_VENDOR", "ORACLE_VERSION", "DB_CNT", "HOST_CNT") AS 
  select  
Nvl(v.Business_unit,'Not Specified') Business_unit
,v.Hardware_vendor
--,v.os_type
,v.oracle_version
,count(distinct database_name) db_cnt
,count(distinct v.host_name) host_cnt
from HOST_DB_APP_DETAIL_VW  v
group by
Nvl(v.Business_unit,'Not Specified')

,v.Hardware_vendor
--,v.os_type
,v.oracle_version
;
--------------------------------------------------------
--  DDL for View HOST_BU_VENDOR_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_BU_VENDOR_VW" ("BUSINESS_UNIT", "HARDWARE_VENDOR", "DB_CNT", "HOST_CNT") AS 
  select  
Nvl(v.Business_unit,'Not Specified') Business_unit
,v.Hardware_vendor
--,v.os_type
--,v.oracle_version
,count(distinct database_name) db_cnt
,count(distinct v.host_name) host_cnt
from HOST_DB_APP_DETAIL_VW  v
group by
Nvl(v.Business_unit,'Not Specified')
,v.Hardware_vendor
--,v.os_type
--,v.oracle_version
;
--------------------------------------------------------
--  DDL for View HOST_DB_ALL_DETAIL_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_DB_ALL_DETAIL_VW" ("ID", "HOST_NAME", "DATABASE_NAME", "VERSION", "ACTION_TIME", "DESCRIPTION", "PATCH_ID", "STATUS", "OPEN_MODE", "DB_CREATED", "DATABASE_ROLE", "DB_ID", "HARDWARE_VENDOR", "OS_TYPE_VERSION", "PHY_VIRT", "DC_LOCATION", "CLUSTERED", "OS_TYPE", "ENV_SOURCE", "ENV_CATEGORY", "APPLICATION_NAME", "BUSINESS_UNIT", "MAIN_EOL", "EXTENDED_EOL", "DB_SUPPORT", "SYSTEM_TYPE") AS 
  SELECT
    p.id,
    h.host_name,
    h.database_name,
    h.oracle_version version,
    p.action_time,
    p.description,
    p.patch_id,
    nvl(p.status,'NoPatch') status ,
    p.open_mode,
    p.db_created,
    h.database_role,
    h.db_id,
    h.hardware_vendor,
    h.os_type_version,
    h.phy_virt,
    h.dc_location,
    h.clustered,
    h.os_type,
    h.env_source,
    h.env_category,
    h.application_name,
    h.business_unit,
    h.main_eol,
    h.extended_eol,
    h.db_support,
    h.system_type
FROM
 v_registry_sqlpatch p
,host_db_app_detail_vw h
where
p.db_id(+) = h.db_id
and p.host_name(+) = h.host_name
;
--------------------------------------------------------
--  DDL for View HOST_DB_APP_DETAIL_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_DB_APP_DETAIL_VW" ("HOST_ID", "HOST_NAME", "NETWORK_TYPE", "CORE_COUNT", "SERVER_MODEL", "HARDWARE_VENDOR", "OS_TYPE_VERSION", "PHY_VIRT", "DC_LOCATION", "HOST_CODE", "DB_ID", "CLUSTER_ID", "CLUSTERED", "OS_TYPE", "ENV_SOURCE", "DATABASE_NAME", "ENV_CATEGORY", "ORACLE_VERSION", "DATABASE_ROLE", "APPLICATION_NAME", "BUSINESS_UNIT", "MAIN_EOL", "EXTENDED_EOL", "DB_SUPPORT", "SYSTEM_TYPE") AS 
  SELECT
    h.id host_id,
    h.host_name,
    h.network_type,
    h.core_count,
    h.server_model,
    h.hardware_vendor,
    h.os_type_version,
    h.phy_virt,
    h.dc_location,
    h.host_code,
    h.db_id,
    h.cluster_id,
    h.clustered,
    h.os_type,
    h.env_source,
         b.database_name,
        b.env_category,
        b.oracle_version,
        b.database_role,
        b.application_name,
        b.business_unit    ,
        s.MAIN_EOL,
        s.extended_eol,
        case 
        when s.MAIN_EOL <= sysdate and s.extended_eol <= sysdate then
         'Out of Support'
        when s.MAIN_EOL <= sysdate and s.extended_eol >= sysdate then
         'Extended Support'
        when s.MAIN_EOL >= sysdate  then
         'Standard Support'
        else
         'No Support Info'
        end DB_support ,
        case
        when        Hardware_vendor in ('ORACLE EXADATA','ORACLE ODA') then
         'Engineered'
         else
          'In-House-Build'
          end system_type        
FROM
    v_host_inv_tbl h
,    DB_APP_DETAIL_VW b
,DB_VERSION_LOOKUP_VW s
where
1 = 1
and h.dc_location not in ('techlab')
and h.db_id = b.db_id
and b.oracle_version = s.oracle_version(+)
;
--------------------------------------------------------
--  DDL for View HOST_DB_PATCH_DETAIL_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_DB_PATCH_DETAIL_VW" ("ID", "HOST_NAME", "DATABASE_NAME", "OPEN_MODE", "DATABASE_ROLE", "DB_CREATED", "DB_ID", "VERSION", "ACTION_TIME", "DESCRIPTION", "PATCH_ID", "STATUS", "HARDWARE_VENDOR", "OS_TYPE_VERSION", "PHY_VIRT", "DC_LOCATION", "CLUSTERED", "OS_TYPE", "ENV_SOURCE", "ENV_CATEGORY", "APPLICATION_NAME", "BUSINESS_UNIT", "MAIN_EOL", "EXTENDED_EOL", "DB_SUPPORT", "SYSTEM_TYPE") AS 
  SELECT
    id,
    p.host_name,
    p.database_name,
    p.open_mode,
    p.database_role,
    p.db_created,
    p.db_id,
    p.version,
    p.action_time,
    p.description,
    p.patch_id,
    p.status,
    h.hardware_vendor,
    h.os_type_version,
    h.phy_virt,
    h.dc_location,
    h.clustered,
    h.os_type,
    h.env_source,
    h.env_category,
    h.application_name,
    h.business_unit,
    h.main_eol,
    h.extended_eol,
    h.db_support,
    h.system_type
FROM
 v_registry_sqlpatch p
,host_db_app_detail_vw h
where
p.db_id = h.db_id
and p.host_name = h.host_name
;
--------------------------------------------------------
--  DDL for View HOST_VENDOR_VERSION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_VENDOR_VERSION_VW" ("HARDWARE_VENDOR", "ORACLE_VERSION", "DB_CNT", "HOST_CNT") AS 
  select  
v.Hardware_vendor
--,v.os_type
,v.oracle_version
,count(distinct database_name) db_cnt
,count(distinct v.host_name) host_cnt
from HOST_DB_APP_DETAIL_VW  v
group by
v.Hardware_vendor
--,v.os_type
,v.oracle_version
;
--------------------------------------------------------
--  DDL for View HOST_VENDOR_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."HOST_VENDOR_VW" ("HARDWARE_VENDOR", "DB_CNT", "HOST_CNT", "HOST_PCT", "DB_PCT", "SUMMARY_TEXT") AS 
  select
v."HARDWARE_VENDOR",v."DB_CNT",v."HOST_CNT"
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) host_pct
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) db_pct
,initcap(v.Hardware_vendor)||' '||round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) ||'% of Server Fleet, including '||db_cnt||' databases on '||v.host_cnt||' Servers.' summary_text
from
(select  
v.Hardware_vendor
--,v.os_type
,count(distinct database_name) db_cnt
,count(distinct v.host_name) host_cnt
from HOST_DB_APP_DETAIL_VW  v
group by
v.Hardware_vendor
--,v.os_type
) v
;
--------------------------------------------------------
--  DDL for View ITSM_SC_REQUEST_ITEM_VA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."ITSM_SC_REQUEST_ITEM_VA" ("TICKET_ID", "SHORT_DESCRIPTION", "DESCRIPTION", "SYS_CREATED_BY", "ITEM_TICKET_ID", "ITEM_DESC", "SYS_ID", "ITEM_SYS_ID") AS 
  select
r.ticket_id
,r.short_description
,r.description
,r.sys_created_by
,i.ticket_id item_ticket_id
,i.short_description item_desc
,r.sys_id
,i.sys_id item_sys_id
from
v_itsm_sc_request r
,v_itsm_sc_req_item i
where
r.sys_id = i.request_sys_id
;
--------------------------------------------------------
--  DDL for View ITSM_SC_REQUEST_ITEM_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."ITSM_SC_REQUEST_ITEM_VW" ("TICKET_ID", "SHORT_DESCRIPTION", "DESCRIPTION", "SYS_CREATED_BY", "ITEM_TICKET_ID", "ITEM_DESC", "SYS_ID", "ITEM_SYS_ID") AS 
  select
r.ticket_id
,r.short_description
,r.description
,r.sys_created_by
,i.ticket_id item_ticket_id
,i.short_description item_desc
,r.sys_id
,i.sys_id item_sys_id
from
v_itsm_sc_request r
,v_itsm_sc_req_item i
where
r.sys_id = i.request_sys_id
;
--------------------------------------------------------
--  DDL for View ITSM_SC_REQUEST_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."ITSM_SC_REQUEST_VW" ("NAME", "SNOW_URL_LINK", "SYS_ID", "TICKET_ID", "DESCRIPTION", "ASSIGNMENT_GROUP", "ASSIGNMENT_GROUP_NAME", "STATE", "CLOSED_AT", "ACTIVE", "PRIORITY", "BUSINESS_SERVICE", "OPENED_AT", "PARENT", "SPECIAL_INSTRUCTIONS", "WORK_NOTES", "SHORT_DESCRIPTION", "WORK_START", "WORK_NOTES_LIST", "COMPANY", "REQUESTED_DATE", "URGENCY", "CONTACT_TYPE", "CLOSED_BY", "CLOSE_NOTES", "ASSIGNED_TO", "ASSIGNED_TO_NAME", "COMMENTS", "APPROVAL", "SLA_DUE", "COMMENTS_AND_WORK_NOTES", "DUE_DATE", "REQUEST_STATE", "STAGE", "ESCALATION", "UPON_APPROVAL", "OPENED_BY", "OPENED_BY_NAME", "SKILLS", "REQUESTED_FOR", "REQUESTED_FOR_NAME", "MADE_SLA", "SYS_CREATED_BY", "SYS_CREATED_ON", "SYS_UPDATED_BY", "SYS_UPDATED_ON", "OWNED_BY_SYS_ID", "MANAGED_BY_SYS_ID") AS 
  SELECT
    r.name,
    'https://onepointdemo.service-now.com/nav_to.do?uri=sc_request.do?sys_id='||r.sys_id snow_url_link,
    r.sys_id,
    r.ticket_id,
    r.description,
    r.assignment_group,
    grp.name assignment_group_name,
    r.state,
    r.closed_at,
    r.active,
    r.priority,
    r.business_service,
    r.opened_at,
    r.parent,
    r.special_instructions,
    r.work_notes,
    r.short_description,
    r.work_start,
    r.work_notes_list,
    r.company,
    r.requested_date,
    r.urgency,
    r.contact_type,
    r.closed_by,
    r.close_notes,
    r.assigned_to,
    ap.name assigned_to_name,
    r.comments,
    r.approval,
    r.sla_due,
    r.comments_and_work_notes,
    r.due_date,
    r.request_state,
    r.stage,
    r.escalation,
    r.upon_approval,
    r.opened_by,
    oby.name opened_by_name,
    r.skills,
    r.requested_for,
    rfor.name requested_for_name ,
    r.made_sla,
    r.sys_created_by,
    r.sys_created_on,
    r.sys_updated_by,
    r.sys_updated_on,
    r.owned_by_sys_id,
    r.managed_by_sys_id
FROM
    v_itsm_sc_request r
    ,v_itsm_sys_user oby
    ,v_itsm_sys_user rfor
    ,v_itsm_sys_user ap
    ,v_itsm_sys_user_group grp
where
r.opened_by = oby.sys_id(+) 
and r.assigned_to = ap.sys_id(+) 
and r.requested_for = rfor.sys_id(+) 
and r.assignment_group =   grp.sys_id(+)
;
--------------------------------------------------------
--  DDL for View LOGGER_LOGS_5_MIN
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."LOGGER_LOGS_5_MIN" ("ID", "LOGGER_LEVEL", "TEXT", "TIME_STAMP", "SCOPE", "MODULE", "ACTION", "USER_NAME", "CLIENT_IDENTIFIER", "CALL_STACK", "UNIT_NAME", "LINE_NO", "SCN", "EXTRA", "SID", "CLIENT_INFO") AS 
  select "ID","LOGGER_LEVEL","TEXT","TIME_STAMP","SCOPE","MODULE","ACTION","USER_NAME","CLIENT_IDENTIFIER","CALL_STACK","UNIT_NAME","LINE_NO","SCN","EXTRA","SID","CLIENT_INFO" 
      from logger_logs 
	 where time_stamp > systimestamp - (5/1440)
;
--------------------------------------------------------
--  DDL for View LOGGER_LOGS_60_MIN
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."LOGGER_LOGS_60_MIN" ("ID", "LOGGER_LEVEL", "TEXT", "TIME_STAMP", "SCOPE", "MODULE", "ACTION", "USER_NAME", "CLIENT_IDENTIFIER", "CALL_STACK", "UNIT_NAME", "LINE_NO", "SCN", "EXTRA", "SID", "CLIENT_INFO") AS 
  select "ID","LOGGER_LEVEL","TEXT","TIME_STAMP","SCOPE","MODULE","ACTION","USER_NAME","CLIENT_IDENTIFIER","CALL_STACK","UNIT_NAME","LINE_NO","SCN","EXTRA","SID","CLIENT_INFO" 
      from logger_logs 
	 where time_stamp > systimestamp - (1/24)
;
--------------------------------------------------------
--  DDL for View LOGGER_LOGS_TERSE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."LOGGER_LOGS_TERSE" ("ID", "LOGGER_LEVEL", "TIME_AGO", "TEXT") AS 
  select id, logger_level, 
        substr(logger.date_text_format(time_stamp),1,20) time_ago,
        substr(text,1,200) text
   from logger_logs
  where time_stamp > systimestamp - (5/1440)
  order by id asc
;
--------------------------------------------------------
--  DDL for View NON_CLUSTERED_HOST_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."NON_CLUSTERED_HOST_VW" ("HOST_NAME", "DC_LOCATION") AS 
  Select Host_name, dc_location from v_host_inv_tbl where
  host_code not in (select distinct v_host_code from v_cluster_member_tbl)
  and os_type_version like 'Linux' and hardware_vendor not like 'ORACLE%'
;
--------------------------------------------------------
--  DDL for View PATCH_BURNDOWN_SUMMARY_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_BURNDOWN_SUMMARY_VW" ("PATCH_WEEK", "PATCH_WEEK_C", "TOTAL_PATCHED", "TOTAL_UNPATCHED", "TOTAL_DBS", "TOTAL_PATCHABLE", "TOTAL_UNPATCHABLE") AS 
  select
p.patch_Week
,to_char(p.patch_Week,'DD-MON-RR')patch_Week_c
,sum(p.patched) over (order by p.patch_Week) Total_patched
,s.total_patchable - sum(p.patched) over (order by p.patch_Week) Total_unpatched
,s.total_dbs
,s.total_patchable
,s.total_unpatchable
from
(select 

trunc(next_day(v.action_time,'MONDAY')) patch_Week
,sum(
case when v.action_time is not null then
 1
else
0
end
) patched
from 
host_db_all_detail_vw v
where
 v.action_time is not null
group by 
trunc(next_day(v.action_time,'MONDAY'))
union all
select
next_day(min(v.action_time) - 7,'MONDAY') patch_Week
,0 patched
from host_db_all_detail_vw v
order by 1
) p
,(
select
sum(db_cnt) total_dbs
,sum(
case 
when oracle_version like '11%' or oracle_version like '12%' then
 db_cnt
else
 0
end  
) total_patchable
,sum(
case 
when oracle_version like '8%' or oracle_version like '9%' or oracle_version like '10%' then
 db_cnt
else
 0
end  
) total_unpatchable
from PATCH_VERSION_SUMMARY_VW
) s
;
--------------------------------------------------------
--  DDL for View PATCH_HOST_VENDOR_VERSION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_HOST_VENDOR_VERSION_VW" ("HARDWARE_VENDOR", "ORACLE_VERSION", "DB_CNT", "PATCH_DB_CNT", "HOST_CNT", "PATCH_CNT", "HOST_PCT", "DB_PCT", "SUMMARY_TEXT") AS 
  select
v."HARDWARE_VENDOR",v."ORACLE_VERSION",v."DB_CNT",v."PATCH_DB_CNT",v."HOST_CNT",v."PATCH_CNT"
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) host_pct
,round((RATIO_TO_REPORT(db_cnt)OVER ()) * 100,0) db_pct
,initcap(v.Hardware_vendor)||' '||round((v.patch_db_cnt / v.db_cnt) * 100,0) ||'% of DB Fleet, patched  '||patch_db_cnt||' databases out of '||v.db_cnt||' for server population.' summary_text
from
(select  
v.Hardware_vendor
,v.oracle_version
,count( v.database_name) db_cnt
,count( p.database_name) patch_db_cnt
,count( v.host_name) host_cnt
,sum (
case
when p.db_id is not null then
 1
else
 0
end 
) patch_cnt
from HOST_DB_APP_DETAIL_VW  v
,host_db_patch_detail_vw p
where 
v.db_id = p.db_id(+)
and v.host_name = p.host_name(+)
group by
v.Hardware_vendor
,v.oracle_version
--,v.os_type
) v
;
--------------------------------------------------------
--  DDL for View PATCH_HOST_VENDOR_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_HOST_VENDOR_VW" ("HARDWARE_VENDOR", "DB_CNT", "PATCH_DB_CNT", "HOST_CNT", "PATCH_CNT", "HOST_PCT", "DB_PCT", "SUMMARY_TEXT") AS 
  select
v."HARDWARE_VENDOR",v."DB_CNT",v."PATCH_DB_CNT",v."HOST_CNT",v."PATCH_CNT"
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) host_pct
,round((RATIO_TO_REPORT(db_cnt)OVER ()) * 100,0) db_pct
,initcap(v.Hardware_vendor)||' '||round((v.patch_db_cnt / v.db_cnt) * 100,0) ||'% of DB Fleet, patched  '||patch_db_cnt||' databases out of '||v.db_cnt||' for server population.' summary_text
from
(select  
v.Hardware_vendor
--,v.os_type
,count( v.database_name) db_cnt
,count( p.database_name) patch_db_cnt
,count( v.host_name) host_cnt
,sum (
case
when p.db_id is not null then
 1
else
 0
end 
) patch_cnt
from HOST_DB_APP_DETAIL_VW  v
,host_db_patch_detail_vw p
where 
v.db_id = p.db_id(+)
and v.host_name = p.host_name(+)
group by
v.Hardware_vendor
--,v.os_type
) v
;
--------------------------------------------------------
--  DDL for View PATCH_SUMMARY_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_SUMMARY_VW" ("ID", "PSU_QUARTER", "PSU_NUMBER", "CREATED", "LS_INVENT", "CREATED_BY", "PSU_YEAR", "PATCH_LOG", "HOST_CODE", "PATCH_TYPE", "HOST_NAME", "DB_HOME", "PATCH_STATUS", "MIMETYPE") AS 
  SELECT
    id,
    psu_quarter,
    psu_number,
    created,
    ls_invent,
    created_by,
    psu_year,
    patch_log,
    host_code,
    patch_type,
    host_name,
    db_home,
    patch_status,
    'application/json' as MIMETYPE 
FROM
    v_db_patch_history
;
--------------------------------------------------------
--  DDL for View PATCH_SUMMARY_VW_OLD
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_SUMMARY_VW_OLD" ("ID", "DB_ID", "DATABASE_NAME", "ENVIRONMENT", "PSU_NUMBER", "PSU_QUARTER", "PSU_YEAR", "LS_INVENT", "PATCH_LOG", "V_HOST_CODE", "MIMETYPE") AS 
  SELECT b.ID,b.DB_ID, a.DATABASE_NAME,a.ENVIRONMENT,b.PSU_NUMBER,b.PSU_QUARTER,b.PSU_YEAR,b.LS_INVENT, b.PATCH_LOG, a.v_HOST_CODE , 'application/json' as MIMETYPE 
FROM v_db_inventory a
, v_db_patch_history b 
where a.ID = b.DB_ID(+)
    Order by DATABASE_NAME
;
--------------------------------------------------------
--  DDL for View PATCH_SYSTEM_TYPE_VERSION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_SYSTEM_TYPE_VERSION_VW" ("SYSTEM_TYPE", "ORACLE_VERSION", "DB_CNT", "PATCH_DB_CNT", "HOST_CNT", "PATCH_CNT", "HOST_PCT", "DB_PCT", "SUMMARY_TEXT") AS 
  select
v."SYSTEM_TYPE",v."ORACLE_VERSION",v."DB_CNT",v."PATCH_DB_CNT",v."HOST_CNT",v."PATCH_CNT"
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) host_pct
,round((RATIO_TO_REPORT(db_cnt)OVER ()) * 100,0) db_pct
,initcap(v.system_type)||' '||round((v.patch_db_cnt / v.db_cnt) * 100,0) ||'% of DB Fleet, patched  '||patch_db_cnt||' databases out of '||v.db_cnt||' for server population.' summary_text
from
(select  
v.system_type
,v.oracle_version
,count( v.database_name) db_cnt
,count( p.database_name) patch_db_cnt
,count( v.host_name) host_cnt
,sum (
case
when p.db_id is not null then
 1
else
 0
end 
) patch_cnt
from HOST_DB_APP_DETAIL_VW  v
,host_db_patch_detail_vw p
where 
v.db_id = p.db_id(+)
and v.host_name = p.host_name(+)
group by
v.system_type
,v.oracle_version
--,v.os_type
) v
;
--------------------------------------------------------
--  DDL for View PATCH_VERSION_SUMMARY_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."PATCH_VERSION_SUMMARY_VW" ("ORACLE_VERSION", "DB_CNT", "PATCH_DB_CNT", "HOST_CNT", "PATCH_CNT", "HOST_PCT", "DB_PCT", "SUMMARY_TEXT") AS 
  select
v."ORACLE_VERSION",v."DB_CNT",v."PATCH_DB_CNT",v."HOST_CNT",v."PATCH_CNT"
,round((RATIO_TO_REPORT(host_cnt)OVER ()) * 100,0) host_pct
,round((RATIO_TO_REPORT(db_cnt)OVER ()) * 100,0) db_pct
,initcap(v.oracle_version)||' '||round((v.patch_db_cnt / v.db_cnt) * 100,0) ||'% of DB Fleet, patched  '||patch_db_cnt||' databases out of '||v.db_cnt||' for version population.' summary_text
from
(select  
--v.Hardware_vendor
v.oracle_version
,count( v.database_name) db_cnt
,count( p.database_name) patch_db_cnt
,count( v.host_name) host_cnt
,sum (
case
when p.db_id is not null then
 1
else
 0
end 
) patch_cnt
from HOST_DB_APP_DETAIL_VW  v
,host_db_patch_detail_vw p
where 
v.db_id = p.db_id(+)
and v.host_name = p.host_name(+)
group by
--v.Hardware_vendor
v.oracle_version
--,v.os_type
) v
;
--------------------------------------------------------
--  DDL for View V_ANSIBLE_JOB_TEMPLATE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_ANSIBLE_JOB_TEMPLATE_VW" ("TEMPLATE_ID", "TEMPLATE_NAME", "INVENTORY_ID", "INVENTORY_NAME") AS 
  select 
t.id template_id
,t.name template_name
,i.id inventory_id
,nvl(i.name,'Workflow')  inventory_name
from
v_ansible_job_templates t
,v_ansible_inventories i
where
t.inventory = i.id(+)
;
--------------------------------------------------------
--  DDL for View V_APP_PRIVILEGE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_APP_PRIVILEGE_VW" ("USERNAME", "APP_ROLE", "DISPLAY_NAME", "EMAIL_ADDR", "ROLE_DESCRIPTION", "PERSON_ID", "ROLE_ID") AS 
  SELECT
    p.username,
    r.app_role,
    p.display_name,
    p.email_addr,
    r.description role_description,
    pr.person_id,
    pr.role_id

FROM
    v_app_person_roles pr
    ,v_app_role r 
    ,v_app_person p
where
 pr.person_id = p.person_id
and pr.role_id = r.role_id
;
--------------------------------------------------------
--  DDL for View V_HISTORY_V
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_HISTORY_V" ("ID", "TABLE_NAME", "COLUMN_NAME", "ACTION", "ACTION_DATE", "ACTION_BY", "TABLE_PRIMARY_KEY", "TABLE_ROW_VERSION", "CHANGE") AS 
  select id,
       table_name,
       column_name,
       decode(action,'U','Update','D','Delete') action,
       action_date,
       action_by,
       pk1 table_primary_key,
       tab_row_version table_row_version,
       decode(data_type,
         'NUMBER',old_number||' > '||new_number,
         'VARCHAR2',substr(old_vc,1,50)||' > '||substr(new_vc,1,50),
         'DATE',to_char(old_date,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_date,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP',to_char(old_ts,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_ts,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP WITH TIMEZONE',to_char(old_tswtz,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_tswtz,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP WITH LOCAL TIMEZONE',to_char(old_tswltz,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_tswltz,'DD-MON-YYY HH24:MI:SS'),
         'BLOB','length '||dbms_lob.getlength(old_blob)||' > '||' length '||dbms_lob.getlength(new_blob),
         'CLOB',dbms_lob.substr(old_vc,50,1)||' > '||dbms_lob.substr(new_vc,50,1)
         ) change
from charter2_inv.v_history
;
--------------------------------------------------------
--  DDL for View V_HOST_INV_TBL_BUS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_HOST_INV_TBL_BUS" ("V_HOST_CODE", "BUSINESS_UNIT") AS 
  select
v_host_code
,listagg(business_unit, ',') within group (order by 1) business_unit
from
(
select
v_host_code
,business_unit
from v_db_inventory
where
v_host_code is not null
group by 
v_host_code
,business_unit
)
group by 
v_host_code
;
--------------------------------------------------------
--  DDL for View V_HOST_INV_TBL_ENV
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_HOST_INV_TBL_ENV" ("V_HOST_CODE", "ENVIRONMENT") AS 
  select
v_host_code
,listagg(environment, ',') within group (order by 1) environment
from
(
select
v_host_code
,environment
from v_db_inventory
where
v_host_code is not null
group by 
v_host_code
,environment
)
group by 
v_host_code
;
--------------------------------------------------------
--  DDL for View V_HOST_INV_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_HOST_INV_VW" ("HOST_NAME", "NETWORK_TYPE", "CLUSTER_NAME", "DC_LOCATION", "CORE_COUNT", "OS_TYPE_VERSION", "PHY_VIRT", "HARDWARE_VENDOR", "SERVER_MODEL", "HOST_CODE") AS 
  SELECT a.HOST_NAME, a.NETWORK_TYPE, b.CLUSTER_NAME,a.DC_LOCATION, a.CORE_COUNT,a.OS_TYPE_VERSION, a.PHY_VIRT, a.HARDWARE_VENDOR,a.SERVER_MODEL, a.HOST_CODE
from V_HOST_INV_TBL a  LEFT OUTER JOIN V_CLUSTER_MEMBER_TBL b
on  a.HOST_CODE = b.V_HOST_CODE
order by a.HOST_CODE
;
--------------------------------------------------------
--  DDL for View V_ITSM_APPLICATION_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_ITSM_APPLICATION_VW" ("NAME", "SYS_ID", "OWNED_BY_SYS_ID", "MANAGED_BY_SYS_ID", "U_APPLICATION_ID", "CHANGE_CONTROL_GROUP", "ASSIGNMENT_GROUP", "CATEGORY", "U_DATA_CATEGORY", "U_DATA_CLASSIFICATION", "SYS_CREATED_BY", "SYS_CREATED_ON", "SYS_UPDATED_BY", "SYS_UPDATED_ON", "OWNED_BY_NAME", "MANAGED_BY_NAME", "CHANGE_GROUP_NAME") AS 
  SELECT
    r.name,
    r.sys_id,
    r.owned_by_sys_id,
    r.managed_by_sys_id,
    r.u_application_id,
    r.change_control_group,
    r.assignment_group,
    r.category,
    r.u_data_category,
    r.u_data_classification,
    r.sys_created_by,
    r.sys_created_on,
    r.sys_updated_by,
    r.sys_updated_on,
    o.name owned_by_name, 
    m.name managed_by_name,
    cgrp.name change_group_name
FROM
    v_itsm_cmdb_ci r
    ,v_itsm_sys_user o
    ,v_itsm_sys_user m
    ,v_itsm_sys_user_group cgrp
where
r.owned_by_sys_id = o.sys_id(+) 
and r.managed_by_sys_id = m.sys_id(+) 
and r.change_control_group =   cgrp.sys_id(+)
;
--------------------------------------------------------
--  DDL for View V_ITSM_CHANGE_REQUEST_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_ITSM_CHANGE_REQUEST_VW" ("REQUESTED_FOR_NAME", "SNOW_URL_LINK", "ASSIGNED_TO_NAME", "ASSIGNMENT_GROUP_NAME", "OPENED_BY_NAME", "CI_NAME", "CI_CATEGORY", "CI_APP_ID", "NAME", "SYS_ID", "CHANGE_ID", "DESCRIPTION", "TEST_PLAN", "IMPLEMENTATION_PLAN", "CHANGE_PLAN", "BACKOUT_PLAN", "ASSIGNMENT_GROUP", "STATE", "PHASE", "IMPACT", "CMDB_CI_SYS_ID", "CLOSED_AT", "ACTIVE", "PRIORITY", "PRODUCTION_SYSTEM", "REQUESTED_BY", "ASSIGNED_TO", "BUSINESS_SERVICE", "REVIEW_DATE", "START_DATE", "END_DATE", "CONFLICT_STATUS", "OPENED_AT", "PARENT", "SPECIAL_INSTRUCTIONS", "WORK_NOTES", "SHORT_DESCRIPTION", "WORK_START", "WORK_NOTES_LIST", "COMPANY", "REQUESTED_DATE", "URGENCY", "CONTACT_TYPE", "CLOSED_BY", "CLOSE_NOTES", "COMMENTS_AND_WORK_NOTES", "APPROVAL", "SLA_DUE", "DUE_DATE", "REQUEST_STATE", "STAGE", "ESCALATION", "UPON_APPROVAL", "OPENED_BY", "SKILLS", "REQUESTED_FOR", "MADE_SLA", "SYS_CREATED_BY", "SYS_UPDATED_BY", "SYS_UPDATED_ON", "OWNED_BY_SYS_ID", "MANAGED_BY_SYS_ID") AS 
  SELECT
    rfor.name requested_for_name ,
    'https://onepointdemo.service-now.com/nav_to.do?uri=change_request.do?sys_id='||r.sys_id snow_url_link,
    ap.name assigned_to_name,
    grp.name assignment_group_name,
    oby.name opened_by_name,
    ci.name ci_name,
    ci.category ci_category,
    ci.u_application_id ci_app_id,
    r.name,
    r.sys_id,
    r.change_id,
    r.description,
    r.test_plan,
    r.implementation_plan,
    r.change_plan,
    r.backout_plan,
    r.assignment_group,
    r.state,
    r.phase,
    r.impact,
    r.cmdb_ci_sys_id,
    r.closed_at,
    r.active,
    r.priority,
    r.production_system,
    r.requested_by,
    r.assigned_to,
    r.business_service,
    r.review_date,
    r.start_date,
    r.end_date,
    r.conflict_status,
    r.opened_at,
    r.parent,
    r.special_instructions,
    r.work_notes,
    r.short_description,
    r.work_start,
    r.work_notes_list,
    r.company,
    r.requested_date,
    r.urgency,
    r.contact_type,
    r.closed_by,
    r.close_notes,
    r.comments_and_work_notes,
    r.approval,
    r.sla_due,
    r.due_date,
    r.request_state,
    r.stage,
    r.escalation,
    r.upon_approval,
    r.opened_by,
    r.skills,
    r.requested_for,
    r.made_sla,
    r.sys_created_by,
    r.sys_updated_by,
    r.sys_updated_on,
    r.owned_by_sys_id,
    r.managed_by_sys_id
FROM
    v_itsm_change_request r
        ,v_itsm_sys_user oby
    ,v_itsm_sys_user rfor
    ,v_itsm_sys_user ap
    ,v_itsm_sys_user_group grp
    ,v_itsm_cmdb_ci ci
where
r.opened_by = oby.sys_id(+) 
and r.assigned_to = ap.sys_id(+) 
and r.requested_for = rfor.sys_id(+) 
and r.assignment_group =   grp.sys_id(+)  
and r.cmdb_ci_sys_id = ci.sys_id(+)
;
--------------------------------------------------------
--  DDL for View V_ITSM_SC_REQUEST_QUE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_ITSM_SC_REQUEST_QUE_VW" ("NAME", "SNOW_URL_LINK", "SYS_ID", "TICKET_ID", "DESCRIPTION", "ASSIGNMENT_GROUP", "ASSIGNMENT_GROUP_NAME", "STATE", "CLOSED_AT", "ACTIVE", "PRIORITY", "BUSINESS_SERVICE", "OPENED_AT", "PARENT", "SPECIAL_INSTRUCTIONS", "WORK_NOTES", "SHORT_DESCRIPTION", "WORK_START", "WORK_NOTES_LIST", "COMPANY", "REQUESTED_DATE", "URGENCY", "CONTACT_TYPE", "CLOSED_BY", "CLOSE_NOTES", "ASSIGNED_TO", "ASSIGNED_TO_NAME", "COMMENTS", "APPROVAL", "SLA_DUE", "COMMENTS_AND_WORK_NOTES", "DUE_DATE", "REQUEST_STATE", "STAGE", "ESCALATION", "UPON_APPROVAL", "OPENED_BY", "OPENED_BY_NAME", "SKILLS", "REQUESTED_FOR", "REQUESTED_FOR_NAME", "MADE_SLA", "SYS_CREATED_BY", "SYS_CREATED_ON", "SYS_UPDATED_BY", "SYS_UPDATED_ON", "OWNED_BY_SYS_ID", "MANAGED_BY_SYS_ID") AS 
  SELECT
    r.name,
    'https://onepointdemo.service-now.com/nav_to.do?uri=sc_request.do?sys_id='||r.sys_id snow_url_link,
    r.sys_id,
    r.ticket_id,
    r.description,
    r.assignment_group,
    grp.name assignment_group_name,
    r.state,
    r.closed_at,
    r.active,
    r.priority,
    r.business_service,
    r.opened_at,
    r.parent,
    r.special_instructions,
    r.work_notes,
    r.short_description,
    r.work_start,
    r.work_notes_list,
    r.company,
    r.requested_date,
    r.urgency,
    r.contact_type,
    r.closed_by,
    r.close_notes,
    r.assigned_to,
    ap.name assigned_to_name,
    r.comments,
    r.approval,
    r.sla_due,
    r.comments_and_work_notes,
    r.due_date,
    r.request_state,
    r.stage,
    r.escalation,
    r.upon_approval,
    r.opened_by,
    oby.name opened_by_name,
    r.skills,
    r.requested_for,
    rfor.name requested_for_name ,
    r.made_sla,
    r.sys_created_by,
    r.sys_created_on,
    r.sys_updated_by,
    r.sys_updated_on,
    r.owned_by_sys_id,
    r.managed_by_sys_id
FROM
    v_itsm_sc_request r
    ,v_itsm_sys_user oby
    ,v_itsm_sys_user rfor
    ,v_itsm_sys_user ap
    ,v_itsm_sys_user_group grp
where
r.opened_by = oby.sys_id(+) 
and r.assigned_to = ap.sys_id(+) 
and r.requested_for = rfor.sys_id(+) 
and r.assignment_group =   grp.sys_id(+)
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_BU_TOT_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_BU_TOT_SUM" ("BUSINESS_UNIT", "TOTAL_DATABASES", "PERCENT_RANK_BU_PCT", "BUSINESS_UNIT_LABEL") AS 
  select
    i.business_unit,
    i.total_databases,
ROUND(( i.total_databases/s.total_databases)*100, 1)  percent_rank_bu_pct,
    i.business_unit||' - '||ROUND(( i.total_databases/s.total_databases)*100, 1)||'%' business_unit_label
from
(SELECT
    i.business_unit,
    count(distinct i.database_name) total_databases
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    ) 
group by 
i.business_unit
) i
,(
SELECT
    count(distinct i.database_name) total_databases
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
    ) s
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_DETAIL" ("DATABASE_NAME", "PRODUCT", "V_HOST_CODE", "ORACLE_VERSION", "DATABASE_ROLE", "USAGE", "FIRST_USAGE_DATE", "LAST_USAGE_DATE", "DATABASE_ID", "BASELINE_ID") AS 
  SELECT
    i.database_name,
    'Enterprise Edition' product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    'CURRENT_USAGE' usage    ,
    sysdate - 360 first_usage_date,
    sysdate last_usage_date,
    i.database_id,
    i.baseline_id
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )    
union all
SELECT distinct
    p.database_name,
    p.product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    usage    ,
    p.first_usage_date,
    p.last_usage_date,
    i.database_id,
    p.baseline_id
FROM
    v_lic_product_usage p
    ,v_lic_db_inventory i
WHERE
p.baseline_id = i.baseline_id
and p.database_name = i.database_name
and p.usage in ('CURRENT_USAGE','PAST_USAGE')
and    p.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_DETAIL_ALL
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_DETAIL_ALL" ("DATABASE_NAME", "PRODUCT", "V_HOST_CODE", "ORACLE_VERSION", "DATABASE_ROLE", "USAGE", "FIRST_USAGE_DATE", "LAST_USAGE_DATE", "DATABASE_ID", "BASELINE_ID") AS 
  SELECT
    i.database_name,
    'Enterprise Edition' product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    'CURRENT_USAGE' usage    ,
    sysdate - 360 first_usage_date,
    sysdate last_usage_date,
    i.database_id,
    i.baseline_id
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )    
union all
SELECT distinct
    p.database_name,
    p.product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    usage    ,
    p.first_usage_date,
    p.last_usage_date,
    i.database_id,
    p.baseline_id
FROM
    v_lic_product_usage p
    ,v_lic_db_inventory i
WHERE
p.baseline_id = i.baseline_id
and p.database_name = i.database_name
--and p.usage in ('CURRENT_USAGE','PAST_USAGE')
and    p.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_DETAIL_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_DETAIL_C1" ("DATABASE_NAME", "PRODUCT", "V_HOST_CODE", "ORACLE_VERSION", "DATABASE_ROLE", "USAGE", "FIRST_USAGE_DATE", "LAST_USAGE_DATE", "DATABASE_ID", "BASELINE_ID") AS 
  SELECT
    i.database_name,
    'Enterprise Edition' product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    'CURRENT_USAGE' usage    ,
    sysdate - 360 first_usage_date,
    sysdate last_usage_date,
    i.database_id,
    i.baseline_id
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP1'
    )    
union all
SELECT distinct
    p.database_name,
    p.product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    usage    ,
    p.first_usage_date,
    p.last_usage_date,
    i.database_id,
    p.baseline_id
FROM
    v_lic_product_usage p
    ,v_lic_db_inventory i
WHERE
p.baseline_id = i.baseline_id
and p.database_name = i.database_name
and p.usage in ('CURRENT_USAGE','PAST_USAGE')
and    p.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP1'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_DETAIL_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_DETAIL_C2" ("DATABASE_NAME", "PRODUCT", "V_HOST_CODE", "ORACLE_VERSION", "DATABASE_ROLE", "USAGE", "FIRST_USAGE_DATE", "LAST_USAGE_DATE", "DATABASE_ID", "BASELINE_ID") AS 
  SELECT
    i.database_name,
    'Enterprise Edition' product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    'CURRENT_USAGE' usage    ,
    sysdate - 360 first_usage_date,
    sysdate last_usage_date,
    i.database_id,
    i.baseline_id
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP2'
    )    
union all
SELECT distinct
    p.database_name,
    p.product,
    i.v_host_code ,
    i.oracle_version,
    i.database_role,
    usage    ,
    p.first_usage_date,
    p.last_usage_date,
    i.database_id,
    p.baseline_id
FROM
    v_lic_product_usage p
    ,v_lic_db_inventory i
WHERE
p.baseline_id = i.baseline_id
and p.database_name = i.database_name
and p.usage in ('CURRENT_USAGE','PAST_USAGE')
and    p.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP2'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_INV_DET
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_INV_DET" ("DATABASE_ID", "BASELINE_ID", "DATABASE_NAME", "APPLICATION_NAME", "ENVIRONMENT", "ORACLE_VERSION", "RAC_TYPE", "BUSINESS_UNIT", "APPLIANCE", "DATABASE_ROLE", "PCI_REQUIRED", "SOX_REQUIRED", "ENCRYPTION_REQUIRED", "DATAGUARD", "GOLDEN_GATE", "BACKUP_ENABLED", "END_OF_LIFE", "DB_MONITORING_TOOL", "MONITORING", "COMMENTS", "INSTANCE_COUNT", "DB_SOURCE", "DR_SOLUTION", "DR_LOCATION", "ENV_CATEGORY", "V_HOST_CODE", "CREATED", "CREATED_BY", "UPDATED", "UPDATED_BY", "APP_ID", "STORAGE_TYPE", "DB_HOME", "SW_CSI", "REF_APP_ID") AS 
  SELECT
    database_id,
    baseline_id,
    database_name,
    application_name,
    environment,
    oracle_version,
    rac_type,
    business_unit,
    appliance,
    database_role,
    pci_required,
    sox_required,
    encryption_required,
    dataguard,
    golden_gate,
    backup_enabled,
    end_of_life,
    db_monitoring_tool,
    monitoring,
    comments,
    instance_count,
    db_source,
    dr_solution,
    dr_location,
    env_category,
    v_host_code,
    created,
    created_by,
    updated,
    updated_by,
    app_id,
    storage_type,
    db_home,
    sw_csi,
    ref_app_id
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_DATABASE_VER_TOT_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DATABASE_VER_TOT_SUM" ("ORACLE_VERSION", "TOTAL_DATABASES") AS 
  SELECT
    i.oracle_version,
    count(distinct i.database_name) total_databases
FROM
    v_lic_db_inventory i
WHERE
    baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    ) 
group by 
i.oracle_version
;
--------------------------------------------------------
--  DDL for View V_LIC_DISCOVERY_SCHEDULE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_DISCOVERY_SCHEDULE_VW" ("LIC_SCHEDULE_ID", "SCHEDULE_NAME", "SCHEDULE_TYPE", "TICKET_REF", "NUMBER_HOSTS", "HOST_NAME", "FILTER_PARMS", "EXECUTE_INTERVAL", "SCHEDULE_START_HR", "LAST_START_TIME", "NUMBER_OF_RUNS", "STATUS", "CREATED", "CREATED_BY", "UPDATED", "UPDATED_BY", "SCHEDULE_START_DATE", "LAST_RUN_TIME", "CURRENT_RUN_TIME", "LAST_SCHEDULE_ID", "CURRENT_SCHEDULE_ID", "SELF_SERVICE_REQUEST_ID") AS 
  SELECT
    d.lic_schedule_id,
    d.schedule_name,
    d.schedule_type,
    d.ticket_ref,
     case
     when d.host_name is not null then
     length(d.host_name) - length(replace(d.host_name,',')) +  1
     else
     0
     end number_hosts,
    d.host_name,
    d.filter_parms,
    d.execute_interval,
    d.schedule_start_hr,
    d.last_start_time,
    d.number_of_runs,
    d.status,
    d.created,
    d.created_by,
    d.updated,
    d.updated_by,
    d.schedule_start_date,
   l.process_start_time last_run_time ,
   c.process_start_time current_run_time ,
    d.last_schedule_id,
    d.CURRENT_SCHEDULE_ID,
    c.self_service_request_id 
FROM
    v_lic_discovery_schedule d
    ,    V_SCHEDULE_QUEUE  l
    ,    V_SCHEDULE_QUEUE_VW  c
    
where
d.last_schedule_id  = l.schedule_id(+)
and d.CURRENT_SCHEDULE_ID = c.schedule_id(+)
;
--------------------------------------------------------
--  DDL for View V_LIC_JSONLOAD_FEATURE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_JSONLOAD_FEATURE_VW" ("STATUS_ID", "RECORD_CREATED", "HOST_NAME", "INSTANCE_NAME", "DATABASE_NAME", "OPEN_MODE", "DATABASE_ROLE", "CREATED", "DBID", "VERSION", "BANNER", "PRODUCT", "FEATURE_BEING_USED", "USAGE", "LAST_SAMPLE_DATE", "DETECTED_USAGES", "TOTAL_SAMPLES", "CURRENTLY_USED", "FIRST_USAGE_DATE", "LAST_USAGE_DATE", "EXTRA_FEATURE_INFO") AS 
  select
tp.status_id,tp.record_created,x."HOST_NAME",x."INSTANCE_NAME",x."DATABASE_NAME",x."OPEN_MODE",x."DATABASE_ROLE",x."CREATED",x."DBID",x."VERSION",x."BANNER",x."PRODUCT",x."FEATURE_BEING_USED",x."USAGE",x."LAST_SAMPLE_DATE",x."DETECTED_USAGES",x."TOTAL_SAMPLES",x."CURRENTLY_USED",x."FIRST_USAGE_DATE",x."LAST_USAGE_DATE",x."EXTRA_FEATURE_INFO"
from
(SELECT
    task_body
    ,created record_created
    ,status_id
FROM
    v_process_status tp
 where
tp. record_type  = 'LOAD_JSON'
 and tp.task_message like '%Feature Data%'
 )tp
 , XMLTABLE(
    '/json/row' PASSING apex_json.to_xmltype(tp.task_body) 
    COLUMNS 
      host_name VARCHAR2(255) PATH 'host_name'
    ,instance_name VARCHAR2(255) PATH 'instance_name'
    ,database_name VARCHAR2(255) PATH 'database_name'
    ,open_mode VARCHAR2(255) PATH 'open_mode'
    ,database_role VARCHAR2(255) PATH 'database_role'
    ,created VARCHAR2(255) PATH 'created'
    ,dbid VARCHAR2(255) PATH 'dbid'
    ,version VARCHAR2(255) PATH 'version'
    ,banner VARCHAR2(255) PATH 'banner'
    ,product VARCHAR2(1000) PATH 'product'
    ,feature_being_used VARCHAR2(1000) PATH 'feature_being_used'
    ,usage VARCHAR2(255) PATH 'usage'
    ,last_sample_date VARCHAR2(255) PATH 'last_sample_date'
        ,detected_usages VARCHAR2(255) PATH 'detected_usages'
    ,total_samples VARCHAR2(255) PATH 'total_samples'
    ,currently_used VARCHAR2(255) PATH 'currently_used'
    ,first_usage_date VARCHAR2(255) PATH 'first_usage_date'
    ,last_usage_date VARCHAR2(255) PATH 'last_usage_date'
    ,extra_feature_info VARCHAR2(255) PATH 'extra_feature_info'

    ) x
;
--------------------------------------------------------
--  DDL for View V_LIC_JSONLOAD_PRODUCT_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_JSONLOAD_PRODUCT_VW" ("STATUS_ID", "RECORD_CREATED", "HOST_NAME", "INSTANCE_NAME", "DATABASE_NAME", "OPEN_MODE", "DATABASE_ROLE", "CREATED", "DBID", "VERSION", "BANNER", "GID", "CON_ID", "CON_NAME", "PRODUCT", "FEATURE_BEING_USED", "USAGE", "LAST_SAMPLE_DATE", "CURRENTLY_USED", "FIRST_USAGE_DATE", "LAST_USAGE_DATE") AS 
  select
tp.status_id,tp.record_created,x."HOST_NAME",x."INSTANCE_NAME",x."DATABASE_NAME",x."OPEN_MODE",x."DATABASE_ROLE",x."CREATED",x."DBID",x."VERSION",x."BANNER",x."GID",x."CON_ID",x."CON_NAME",x."PRODUCT",x."FEATURE_BEING_USED",x."USAGE",x."LAST_SAMPLE_DATE",x."CURRENTLY_USED",x."FIRST_USAGE_DATE",x."LAST_USAGE_DATE"
from
(SELECT
    task_body
    ,created record_created
    ,status_id
FROM
    v_process_status tp
 where
tp. record_type  = 'LOAD_JSON'
 and tp.task_message like '%Product Data%'
 )tp
 , XMLTABLE(
    '/json/row' PASSING apex_json.to_xmltype(tp.task_body) 
    COLUMNS 
      host_name VARCHAR2(255) PATH 'host_name'
    ,instance_name VARCHAR2(255) PATH 'instance_name'
    ,database_name VARCHAR2(255) PATH 'database_name'
    ,open_mode VARCHAR2(255) PATH 'open_mode'
    ,database_role VARCHAR2(255) PATH 'database_role'
    ,created VARCHAR2(255) PATH 'created'
    ,dbid VARCHAR2(255) PATH 'dbid'
    ,version VARCHAR2(255) PATH 'version'
    ,banner VARCHAR2(255) PATH 'banner'
    ,gid VARCHAR2(255) PATH 'gid'
    ,con_id VARCHAR2(255) PATH 'con_id'
    ,con_name VARCHAR2(255) PATH 'con_name'    
    ,product VARCHAR2(1000) PATH 'product'
    ,feature_being_used VARCHAR2(1000) PATH 'feature_being_used'
    ,usage VARCHAR2(255) PATH 'usage'
    ,last_sample_date VARCHAR2(255) PATH 'last_sample_date'
    ,currently_used VARCHAR2(255) PATH 'currently_used'
    ,first_usage_date VARCHAR2(255) PATH 'first_usage_date'
    ,last_usage_date VARCHAR2(255) PATH 'last_usage_date'
    ) x
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_DETAIL" ("HOST_NAME", "LIC_CORE", "CORE_COUNT", "HARDWARE_VENDOR", "PRODUCT", "V_HOST_CODE", "USAGE", "BASELINE_ID", "PRICE_PER_PROCESSOR", "MAINT_PER_PROCESSOR", "SERVER_MAINT", "SERVER_LICENSE") AS 
  SELECT distinct
    h.host_name,
    h.lic_core,
    h.core_count,
    h.hardware_vendor,
    d. product,
    d.v_host_code,
    d.usage,
--    d.first_usage_date,
--    d.last_usage_date,
    d.baseline_id,
    l.price_per_processor,
    (l.price_per_processor * .1) maint_per_processor,
    (l.price_per_processor * .1) * h.lic_core server_maint,
    (l.price_per_processor  * h.lic_core) server_license
FROM
    v_lic_database_detail d
    ,v_lic_host_inv h
   ,v_lic_product_price_list l
where
d.v_host_code = h.host_code
and d.product = l.product_key(+)
and    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_DETAIL_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_DETAIL_C1" ("HOST_NAME", "LIC_CORE", "CORE_COUNT", "HARDWARE_VENDOR", "PRODUCT", "V_HOST_CODE", "USAGE", "BASELINE_ID", "PRICE_PER_PROCESSOR", "MAINT_PER_PROCESSOR", "SERVER_MAINT", "SERVER_LICENSE") AS 
  SELECT distinct
    h.host_name,
    h.lic_core,
    h.core_count,
    h.hardware_vendor,
    d. product,
    d.v_host_code,
    d.usage,
--    d.first_usage_date,
--    d.last_usage_date,
    d.baseline_id,
    l.price_per_processor,
    (l.price_per_processor * .1) maint_per_processor,
    (l.price_per_processor * .1) * h.lic_core server_maint,
    (l.price_per_processor  * h.lic_core) server_license
FROM
    v_lic_database_detail d
    ,v_lic_host_inv h
   ,v_lic_product_price_list l
where
d.v_host_code = h.host_code
and d.product = l.product_key(+)
and    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.compare_key = 'COMP1'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_DETAIL_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_DETAIL_C2" ("HOST_NAME", "LIC_CORE", "CORE_COUNT", "HARDWARE_VENDOR", "PRODUCT", "V_HOST_CODE", "USAGE", "BASELINE_ID", "PRICE_PER_PROCESSOR", "MAINT_PER_PROCESSOR", "SERVER_MAINT", "SERVER_LICENSE") AS 
  SELECT distinct
    h.host_name,
    h.lic_core,
    h.core_count,
    h.hardware_vendor,
    d. product,
    d.v_host_code,
    d.usage,
--    d.first_usage_date,
--    d.last_usage_date,
    d.baseline_id,
    l.price_per_processor,
    (l.price_per_processor * .1) maint_per_processor,
    (l.price_per_processor * .1) * h.lic_core server_maint,
    (l.price_per_processor  * h.lic_core) server_license
FROM
    v_lic_database_detail d
    ,v_lic_host_inv h
   ,v_lic_product_price_list l
where
d.v_host_code = h.host_code
and d.product = l.product_key(+)
and    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.compare_key = 'COMP2'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_PROD_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_PROD_SUM" ("PRODUCT", "LIC_CORE", "CORE_COUNT", "TOTAL_COST", "MAINT_COST") AS 
  SELECT
    s.product,
    sum(s.lic_core) lic_core,
    sum(s.core_count) core_count,
    sum(s.lic_core * l.price_per_processor ) total_cost,
    sum((s.lic_core * l.price_per_processor )* .1 ) maint_cost
FROM
    v_lic_server_detail s
    ,v_lic_product_price_list l
where    
s.product = l.product_key
group by s.product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_PROD_SUM_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_PROD_SUM_C1" ("PRODUCT", "LIC_CORE", "CORE_COUNT", "TOTAL_COST", "MAINT_COST") AS 
  SELECT
    s.product,
    sum(s.lic_core) lic_core,
    sum(s.core_count) core_count,
    sum(s.lic_core * l.price_per_processor ) total_cost,
    sum((s.lic_core * l.price_per_processor )* .1 ) maint_cost
FROM
    v_lic_server_detail_c1 s
    ,v_lic_product_price_list l
where    
s.product = l.product_key
group by s.product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_PROD_SUM_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_PROD_SUM_C2" ("PRODUCT", "LIC_CORE", "CORE_COUNT", "TOTAL_COST", "MAINT_COST") AS 
  SELECT
    s.product,
    sum(s.lic_core) lic_core,
    sum(s.core_count) core_count,
    sum(s.lic_core * l.price_per_processor ) total_cost,
    sum((s.lic_core * l.price_per_processor )* .1 ) maint_cost
FROM
    v_lic_server_detail_c2 s
    ,v_lic_product_price_list l
where    
s.product = l.product_key
group by s.product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_TOT_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_TOT_SUM" ("TOTAL_NAME", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    'Server Fleet' total_name,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_TOT_SUM_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_TOT_SUM_C1" ("TOTAL_NAME", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    'Server Fleet' total_name,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP1'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_TOT_SUM_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_TOT_SUM_C2" ("TOTAL_NAME", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    'Server Fleet' total_name,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP2'
    )
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_PROD_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_PROD_SUM" ("HARDWARE_VENDOR", "PRODUCT", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    hardware_vendor,    
    product,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_server_detail
group by     hardware_vendor,product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_PROD_SUM_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_PROD_SUM_C1" ("HARDWARE_VENDOR", "PRODUCT", "LIC_CORE", "CORE_COUNT", "TOTAL_COST", "MAINT_COST") AS 
  SELECT
    s.hardware_vendor,    
    s.product,
    sum(lic_core) lic_core,
    sum(core_count) core_count,
    sum(s.lic_core * l.price_per_processor ) total_cost,
    sum((s.lic_core * l.price_per_processor )* .1 ) maint_cost
FROM
    v_lic_server_detail_c1 s
        ,v_lic_product_price_list l
where    
s.product = l.product_key
group by     hardware_vendor,product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_PROD_SUM_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_PROD_SUM_C2" ("HARDWARE_VENDOR", "PRODUCT", "LIC_CORE", "CORE_COUNT", "TOTAL_COST", "MAINT_COST") AS 
  SELECT
    s.hardware_vendor,    
    s.product,
    sum(lic_core) lic_core,
    sum(core_count) core_count,
    sum(s.lic_core * l.price_per_processor ) total_cost,
    sum((s.lic_core * l.price_per_processor )* .1 ) maint_cost
FROM
    v_lic_server_detail_c2 s
        ,v_lic_product_price_list l
where    
s.product = l.product_key
group by     hardware_vendor,product
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_SUM" ("HARDWARE_VENDOR", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    h.hardware_vendor,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
            b.status = 'Active'
    )    
group by h.hardware_vendor
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_SUM_C1
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_SUM_C1" ("HARDWARE_VENDOR", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    h.hardware_vendor,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP1'
    )    
group by h.hardware_vendor
;
--------------------------------------------------------
--  DDL for View V_LIC_SERVER_VENDOR_SUM_C2
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LIC_SERVER_VENDOR_SUM_C2" ("HARDWARE_VENDOR", "TOTAL_HOSTS", "LIC_CORE", "CORE_COUNT") AS 
  SELECT
    h.hardware_vendor,
    count(distinct h.host_name) total_hosts,
    sum(lic_core) lic_core,
    sum(core_count) core_count
FROM
    v_lic_host_inv h
where    h.baseline_id = (
        SELECT
            MAX(baseline_id)
        FROM
            v_lic_baseline b
        WHERE
           compare_key like 'COMP2'
    )    
group by h.hardware_vendor
;
--------------------------------------------------------
--  DDL for View V_LOV_TBL_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_LOV_TBL_VW" ("LOV_VALUE", "LOV_CATEGORY", "LOV_ACTIVE") AS 
  SELECT
    t.lov_value
    ,t.lov_category
    ,t.lov_active
FROM
    v_lov_tbl t
union all
SELECT
    compare_key
    , 'BASELINE_KEY' lov_category
    ,'ACTIVE' lov_active 
FROM
    v_lic_baseline
;
--------------------------------------------------------
--  DDL for View V_PATCH_SCHEDULE_CALENDAR
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_PATCH_SCHEDULE_CALENDAR" ("PATCH_SCHED_ID", "HOST_CODE", "PATCH_DATE", "DC_LOCATION", "PATCH_LOOKUP_ID", "PATCH_END", "PATCH_TARGET", "HOST_NAME", "CLUSTER_NAME", "PATCH_NAME", "TICKET_REF") AS 
  SELECT
    ps.patch_sched_id,
    ps.host_code,
    ps.patch_date,
        ps.dc_location,
--    ps.app_id,
    ps.patch_lookup_id,
    max(ps.patch_date + 4/24) patch_end,
    nvl(max(c.cluster_name),max(h.host_name)) patch_target,
    max(h.host_name) host_name,
    max(c.cluster_name) cluster_name,
    max(pl.PATCH_TYPE||' '||pl.SOFTWARE_VERSION||' -'|| pl.PATCH_QUARTER||' '||pl.PATCH_YEAR) patch_name,
    max(ticket_ref) ticket_ref
   -- max(a.application_name) application_name,
  --  max(a.business_unit) business_unit
FROM
    charter2_inv.v_patch_schedule ps
     ,charter2_inv.v_host_inv_tbl h
   --  ,charter2_inv.v_application_details_tbl a
     , charter2_inv.v_cluster_member_tbl c
     ,charter2_inv.V_PATCH_LOOKUP_TBL pl
 where
 ps.host_code = h.host_code(+)
-- and ps.app_id = a.id(+)
 and h.host_code = c.v_host_code(+)
 and ps.patch_lookup_id = pl.id
 group by 
    ps.patch_sched_id,
    ps.host_code,
    ps.patch_date,
        ps.dc_location,
 --   ps.app_id,
    ps.patch_lookup_id
;
--------------------------------------------------------
--  DDL for View V_PATCH_SCHEDULE_CALENDAR_08NOV
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_PATCH_SCHEDULE_CALENDAR_08NOV" ("PATCH_SCHED_ID", "HOST_CODE", "PATCH_DATE", "PATCH_LOOKUP_ID", "PATCH_END", "PATCH_TARGET", "HOST_NAME", "CLUSTER_NAME", "PATCH_NAME", "TICKET_REF") AS 
  SELECT
    ps.patch_sched_id,
    ps.host_code,
    ps.patch_date,
--    ps.app_id,
    ps.patch_lookup_id,
    max(ps.patch_date + 4/24) patch_end,
    nvl(max(c.cluster_name),max(h.host_name)) patch_target,
    max(h.host_name) host_name,
    max(c.cluster_name) cluster_name,
    max(pl.PATCH_TYPE||' '||pl.SOFTWARE_VERSION||' -'|| pl.PATCH_QUARTER||' '||pl.PATCH_YEAR) patch_name,
    max(ticket_ref) ticket_ref
   -- max(a.application_name) application_name,
  --  max(a.business_unit) business_unit
FROM
    charter2_inv.v_patch_schedule ps
     ,charter2_inv.v_host_inv_tbl h
   --  ,charter2_inv.v_application_details_tbl a
     , charter2_inv.v_cluster_member_tbl c
     ,charter2_inv.V_PATCH_LOOKUP_TBL pl
 where
 ps.host_code = h.host_code(+)
-- and ps.app_id = a.id(+)
 and h.host_code = c.v_host_code(+)
 and ps.patch_lookup_id = pl.id
 group by 
    ps.patch_sched_id,
    ps.host_code,
    ps.patch_date,
 --   ps.app_id,
    ps.patch_lookup_id
;
--------------------------------------------------------
--  DDL for View V_PATCH_SCHEDULE_CALENDAR_HOSTNAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_PATCH_SCHEDULE_CALENDAR_HOSTNAME" ("PATCH_SCHED_ID", "HOST_CODE", "PATCH_DATE", "DC_LOCATION", "PATCH_LOOKUP_ID", "PATCH_END", "PATCH_TARGET", "HOST_NAME", "CLUSTER_NAME", "PATCH_NAME", "TICKET_REF") AS 
  SELECT
    ps.patch_sched_id,
    h.host_code,
    ps.patch_date,
    ps.dc_location,
    ps.patch_lookup_id,
    max(ps.patch_date + 4/24) patch_end,
    nvl(max(c.cluster_name),max(h.host_name)) patch_target,
    max(h.host_name) host_name,
    max(c.cluster_name) cluster_name,
    max(pl.PATCH_TYPE||' '||pl.SOFTWARE_VERSION||' -'|| pl.PATCH_QUARTER||' '||pl.PATCH_YEAR) patch_name,
    max(ticket_ref) ticket_ref
   -- max(a.application_name) application_name,
  --  max(a.business_unit) business_unit
FROM
    charter2_inv.v_patch_schedule ps
     ,charter2_inv.v_host_inv_tbl h
   --  ,charter2_inv.v_application_details_tbl a
     , charter2_inv.v_cluster_member_tbl c
     ,charter2_inv.V_PATCH_LOOKUP_TBL pl
 where
 ps.host_name = h.host_name(+)
-- and ps.app_id = a.id(+)
 and h.host_code = c.v_host_code(+)
 and ps.patch_lookup_id = pl.id
 group by 
    ps.patch_sched_id,
    h.host_code,
    ps.patch_date,
    ps.dc_location,
    ps.patch_lookup_id
;
--------------------------------------------------------
--  DDL for View V_SCHEDULE_QUEUE_VW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" ("SCHEDULE_ID", "SCHEDULE_TYPE", "SCHEDULE_PROCESS", "TASK_ID", "APPROVAL_PROCESS_ID", "APPROVAL_REQUIRED", "TICKET_REF", "UNIQUE_GRP", "REQ_QUEUE_ID", "SELF_SERVICE_REQUEST_ID", "HOST_NAME", "TASK_PARMS", "REQUEST_START_TIME_C", "REQUEST_START_TIME", "PROCESS_START_TIME", "STATUS", "CREATED", "CREATED_BY", "UPDATED", "UPDATED_BY", "TASK_TYPE", "EXECUTION_MODE", "DESCRIPTION", "PRIVILEGE_ROLE", "TASK_STATUS", "TASK_KEY") AS 
  SELECT
    s.schedule_id,
    s.schedule_type,
    s.schedule_process,
    s.task_id,
    s.approval_process_id,
    s.approval_required,
    s.ticket_ref,
    s.unique_grp,
    s.req_queue_id,
    (select max(self_service_request_id)  from  v_schedule_queue_detail d
    where 
    d.schedule_id = s.schedule_id )self_service_request_id,
    s.host_name,
   s.task_parms,
    s.request_start_time_c,
    s.request_start_time,
    s.process_start_time,
    s.status,
    s.created,
    s.created_by,
    s.updated,
    s.updated_by,
    t.task_type,
    t.execution_mode,
    t.description,
    t.privilege_role,
    t.status task_status,
    t.task_key
 FROM
    v_schedule_queue s
    ,V_SCHEDULE_TASK t
where
 s.task_id = t.task_id
;
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT DELETE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT INSERT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT SELECT ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT UPDATE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT REFERENCES ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT READ ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT ON COMMIT REFRESH ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT QUERY REWRITE ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT DEBUG ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT FLASHBACK ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
  GRANT MERGE VIEW ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "OPENSOURCE_USER";
  GRANT MERGE VIEW ON "CHARTER2_INV"."V_SCHEDULE_QUEUE_VW" TO "CHARTER2_SQL";
--------------------------------------------------------
--  DDL for Index V_REST_DEFINITIONS_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_REST_DEFINITIONS_ID_PK" ON "CHARTER2_INV"."V_REST_DEFINITIONS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ANSIBLE_TEMPLATE_STORE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE_PK" ON "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ANSIBLE_TEMPLATE_STORE_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE_UK1" ON "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" ("TEMPLATE_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index V_PATCH_REQUEST_QUEUE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE_PK" ON "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHARTS_PROJ_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHARTS_PROJ_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_TASKS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_TASKS_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_STOCKS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_STOCKS_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_STOCKS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_POP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_POP_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_POPULATION" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_DEPT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_DEPT_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_DEPT" ("DEPTNO") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_EMP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_EMP_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ("EMPNO") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_BBALL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_BBALL_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_BBALL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_PROD_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_PROD_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" ("PRODUCT_ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_ORDER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_ORDER_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" ("ORDER_ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_STATS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_STATS_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_STATS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index PK_CLUSTER_NAME
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."PK_CLUSTER_NAME" ON "CHARTER2_INV"."CLUSTER_MEMBER_TBL" ("CLUSTER_NAME", "HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index DB_CHECK_LIST_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."DB_CHECK_LIST_PK" ON "CHARTER2_INV"."DB_CHECK_LIST" ("EXECUTION_ID", "DB_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_HOST_INV_TBL_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_HOST_INV_TBL_ID_PK" ON "CHARTER2_INV"."V_HOST_INV_TBL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_CLUSTER_MEMBER_T_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_CLUSTER_MEMBER_T_ID_PK" ON "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" ("ID", "V_HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index V_DB_INVENTORY_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_DB_INVENTORY_ID_PK" ON "CHARTER2_INV"."V_DB_INVENTORY" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_APPLICATION_DETA_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_APPLICATION_DETA_ID_PK" ON "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_DB_SCHEDULE_TBL_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_DB_SCHEDULE_TBL_ID_PK" ON "CHARTER2_INV"."V_DB_SCHEDULE_TBL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_APP_PERSON_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_APP_PERSON_PK" ON "CHARTER2_INV"."V_APP_PERSON" ("PERSON_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ANSIBLE_REST_LOGS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_ANSIBLE_REST_LOGS_PK" ON "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_ACL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_ACL_PK" ON "CHARTER2_INV"."APEX$_ACL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_WEBPG_SECTIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS_PK" ON "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_ROWS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_ROWS_PK" ON "CHARTER2_INV"."APEX$_WS_ROWS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_ROWS_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_ROWS_UK1" ON "CHARTER2_INV"."APEX$_WS_ROWS" ("WS_APP_ID", "DATA_GRID_ID", "UNIQUE_VALUE") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_NOTES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_NOTES_PK" ON "CHARTER2_INV"."APEX$_WS_NOTES" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_LINKS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_LINKS_PK" ON "CHARTER2_INV"."APEX$_WS_LINKS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_TAGS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_TAGS_PK" ON "CHARTER2_INV"."APEX$_WS_TAGS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_FILES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."APEX$_WS_FILES_PK" ON "CHARTER2_INV"."APEX$_WS_FILES" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_PREFS_BY_CLIENT_ID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID_PK" ON "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" ("CLIENT_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_REGISTRY_SQLPATCH_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_REGISTRY_SQLPATCH_PK" ON "CHARTER2_INV"."V_REGISTRY_SQLPATCH" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_BASELINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_BASELINE_PK" ON "CHARTER2_INV"."V_LIC_BASELINE" ("BASELINE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_PURCHASED_PRODUCTS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_PURCHASED_PRODUCTS_PK" ON "CHARTER2_INV"."V_LIC_PURCHASED_PRODUCTS" ("PRODUCT_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_HOST_INV_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_HOST_INV_PK" ON "CHARTER2_INV"."V_LIC_HOST_INV" ("HOST_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_DB_INVENTORY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_DB_INVENTORY_PK" ON "CHARTER2_INV"."V_LIC_DB_INVENTORY" ("DATABASE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_FEATURE_USAGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_FEATURE_USAGE_PK" ON "CHARTER2_INV"."V_LIC_FEATURE_USAGE" ("FEATURE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_PRODUCT_USAGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_PRODUCT_USAGE_PK" ON "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" ("PRODUCT_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_PRODUCT_PRICE_LIST_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_PRODUCT_PRICE_LIST_PK" ON "CHARTER2_INV"."V_LIC_PRODUCT_PRICE_LIST" ("PRODUCT_PRICE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_BASELINE_JSON_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_LIC_BASELINE_JSON_PK" ON "CHARTER2_INV"."V_LIC_BASELINE_JSONLOAD" ("JSON_LOAD_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_APP_ROLE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_APP_ROLE_PK" ON "CHARTER2_INV"."V_APP_ROLE" ("ROLE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_APP_PERSON_ROLES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_APP_PERSON_ROLES_PK" ON "CHARTER2_INV"."V_APP_PERSON_ROLES" ("PERSON_ID", "ROLE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index SOURCE_APP_UPDATE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."SOURCE_APP_UPDATE_PK" ON "CHARTER2_INV"."SOURCE_APP_UPDATE" ("SOURCE_APP_UPDATE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index ORACLE_TEAM_USERS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."ORACLE_TEAM_USERS_PK" ON "CHARTER2_INV"."ORACLE_TEAM_USERS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index MSSQL_TEAM_USERS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."MSSQL_TEAM_USERS_PK" ON "CHARTER2_INV"."MSSQL_TEAM_USERS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_APP_SETTINGS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_APP_SETTINGS_PK" ON "CHARTER2_INV"."V_APP_SETTINGS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_LOGS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."LOGGER_LOGS_PK" ON "CHARTER2_INV"."LOGGER_LOGS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_PREFS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."LOGGER_PREFS_PK" ON "CHARTER2_INV"."LOGGER_PREFS" ("PREF_TYPE", "PREF_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_LOGS_APX_ITMS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."LOGGER_LOGS_APX_ITMS_PK" ON "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_REQUEST_QUEUE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_REQUEST_QUEUE_PK" ON "CHARTER2_INV"."V_REQUEST_QUEUE" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index LOOKUP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."LOOKUP_PK" ON "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_SAMPLES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_SAMPLES_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_SAMPLE_DATA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."EBA_DEMO_SAMPLE_DATA_PK" ON "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_DATA" ("ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_API_RESULT_RUN_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_API_RESULT_RUN_ID" ON "CHARTER2_INV"."V_ITSM_API_RESULT" ("RUN_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LICENSE_PRODUCT_USAGEDN
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LICENSE_PRODUCT_USAGEDN" ON "CHARTER2_INV"."V_LICENSE_PRODUCT_USAGE" ("DATABASE_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_LOGS_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."LOGGER_LOGS_IDX1" ON "CHARTER2_INV"."LOGGER_LOGS" ("TIME_STAMP", "LOGGER_LEVEL") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_EMP_2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_EMP_2" ON "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ("DEPTNO") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_ORD_1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_ORD_1" ON "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" ("QUANTITY") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_TASKS_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_TASKS_IDX1" ON "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" ("PROJECT") 
  ;
--------------------------------------------------------
--  DDL for Index V_HISTORY_IDX2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_HISTORY_IDX2" ON "CHARTER2_INV"."V_HISTORY" ("TABLE_NAME", "COLUMN_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_HOST_INV_HC
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_HOST_INV_HC" ON "CHARTER2_INV"."V_LIC_HOST_INV" ("HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index V_DB_SCHEDULE_TBL_I1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_DB_SCHEDULE_TBL_I1" ON "CHARTER2_INV"."V_DB_SCHEDULE_TBL" ("DB_ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_ACL_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_ACL_IDX1" ON "CHARTER2_INV"."APEX$_ACL" ("WS_APP_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SC_REQ_ASGN_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SC_REQ_ASGN_ID" ON "CHARTER2_INV"."V_ITSM_SC_REQUEST" ("ASSIGNED_TO") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SYS_USER_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SYS_USER_ID" ON "CHARTER2_INV"."V_ITSM_SYS_USER" ("SYS_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_BASELINE_JSON_STATID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_BASELINE_JSON_STATID" ON "CHARTER2_INV"."V_LIC_BASELINE_JSONLOAD" ("STATUS_ID", "BASELINE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_HOST_INV_HN
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_HOST_INV_HN" ON "CHARTER2_INV"."V_LIC_HOST_INV" ("HOST_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_NOTES_IDX2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_NOTES_IDX2" ON "CHARTER2_INV"."APEX$_WS_NOTES" ("WS_APP_ID", "WEBPAGE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index HOST_NAME_HOST_CODE_VHIT_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."HOST_NAME_HOST_CODE_VHIT_IDX" ON "CHARTER2_INV"."V_HOST_INV_TBL" ("HOST_NAME", "HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_PROD_1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_PROD_1" ON "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" ("LIST_PRICE") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_TAGS_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_TAGS_IDX1" ON "CHARTER2_INV"."APEX$_WS_TAGS" ("WS_APP_ID", "DATA_GRID_ID", "ROW_ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_STATS_3
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_STATS_3" ON "CHARTER2_INV"."EBA_DEMO_CHART_STATS" ("TOTAL") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_STATS_1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_STATS_1" ON "CHARTER2_INV"."EBA_DEMO_CHART_STATS" ("EMPLOYEE") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_PRODUCT_USAGE_DN
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_PRODUCT_USAGE_DN" ON "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" ("DATABASE_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_FILES_IDX2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_FILES_IDX2" ON "CHARTER2_INV"."APEX$_WS_FILES" ("WS_APP_ID", "WEBPAGE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SC_REQ_ITEM_RID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SC_REQ_ITEM_RID" ON "CHARTER2_INV"."V_ITSM_SC_REQ_ITEM" ("REQUEST_SYS_ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_ORD_2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_ORD_2" ON "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" ("PRODUCT_ID") 
  ;
--------------------------------------------------------
--  DDL for Index LOGGER_APEX_ITEMS_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."LOGGER_APEX_ITEMS_IDX1" ON "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" ("LOG_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_CLUSTER_MEMBER_TBL_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_UK" ON "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" ("CLUSTER_NAME", "V_HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_STATS_2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_STATS_2" ON "CHARTER2_INV"."EBA_DEMO_CHART_STATS" ("EMPLOYER") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_LINKS_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_LINKS_IDX1" ON "CHARTER2_INV"."APEX$_WS_LINKS" ("WS_APP_ID", "DATA_GRID_ID", "ROW_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_HISTORY_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_HISTORY_IDX1" ON "CHARTER2_INV"."V_HISTORY" ("PK1") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SYS_USER_GROUP_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SYS_USER_GROUP_ID" ON "CHARTER2_INV"."V_ITSM_SYS_USER_GROUP" ("SYS_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SC_REQ_REQFOR
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SC_REQ_REQFOR" ON "CHARTER2_INV"."V_ITSM_SC_REQUEST" ("REQUESTED_FOR") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_WEBPG_SECHIST_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_WEBPG_SECHIST_IDX1" ON "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" ("WS_APP_ID", "WEBPAGE_ID", "SECTION_ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_NOTES_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_NOTES_IDX1" ON "CHARTER2_INV"."APEX$_WS_NOTES" ("WS_APP_ID", "DATA_GRID_ID", "ROW_ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_FILES_IDX1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_FILES_IDX1" ON "CHARTER2_INV"."APEX$_WS_FILES" ("WS_APP_ID", "DATA_GRID_ID", "ROW_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SC_REQ_OPENBY_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SC_REQ_OPENBY_ID" ON "CHARTER2_INV"."V_ITSM_SC_REQUEST" ("OPENED_BY") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_DB_INVENTORY_HC
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_DB_INVENTORY_HC" ON "CHARTER2_INV"."V_LIC_DB_INVENTORY" ("V_HOST_CODE") 
  ;
--------------------------------------------------------
--  DDL for Index V_LICENSE_FEATURE_USAGEDN
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LICENSE_FEATURE_USAGEDN" ON "CHARTER2_INV"."V_LICENSE_FEATURE_USAGE" ("DATABASE_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_TAGS_IDX2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_TAGS_IDX2" ON "CHARTER2_INV"."APEX$_WS_TAGS" ("WS_APP_ID", "WEBPAGE_ID") 
  ;
--------------------------------------------------------
--  DDL for Index V_ITSM_SC_REQUEST_ID
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_ITSM_SC_REQUEST_ID" ON "CHARTER2_INV"."V_ITSM_SC_REQUEST" ("SYS_ID") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_EMP_1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_EMP_1" ON "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ("MGR") 
  ;
--------------------------------------------------------
--  DDL for Index EBA_DEMO_CHART_BBALL_1
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."EBA_DEMO_CHART_BBALL_1" ON "CHARTER2_INV"."EBA_DEMO_CHART_BBALL" ("WINS") 
  ;
--------------------------------------------------------
--  DDL for Index V_LIC_FEATURE_USAGE_DN
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."V_LIC_FEATURE_USAGE_DN" ON "CHARTER2_INV"."V_LIC_FEATURE_USAGE" ("DATABASE_NAME") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_ROWS_IDX
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_ROWS_IDX" ON "CHARTER2_INV"."APEX$_WS_ROWS" ("WS_APP_ID", "DATA_GRID_ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_HISTORY_IDX
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_HISTORY_IDX" ON "CHARTER2_INV"."APEX$_WS_HISTORY" ("WS_APP_ID", "DATA_GRID_ID", "ROW_ID") 
  ;
--------------------------------------------------------
--  DDL for Index APEX$_WS_LINKS_IDX2
--------------------------------------------------------

  CREATE INDEX "CHARTER2_INV"."APEX$_WS_LINKS_IDX2" ON "CHARTER2_INV"."APEX$_WS_LINKS" ("WS_APP_ID", "WEBPAGE_ID") 
  ;
--------------------------------------------------------
--  DDL for Trigger APEX$TEAM_DEV_FILES_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$TEAM_DEV_FILES_BIU" 
          before insert or update on apex$team_dev_files
          for each row
        declare
           l_filesize_quota number := 15728640;
           l_filesize_mb    number;
        begin
          for c1 in
          (
              select
                  team_dev_fs_limit
              from
                  apex_workspaces
              where
                  workspace_id = v( 'APP_SECURITY_GROUP_ID' )
          )
          loop
            l_filesize_quota := c1.team_dev_fs_limit;
            l_filesize_mb    := l_filesize_quota/1048576;
          end loop;
          if :new."ID" is null then
            select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
          end if;
          if inserting then
           :new.created := localtimestamp;
           :new.created_by := nvl(wwv_flow.g_user,user);
           :new.updated := localtimestamp;
           :new.updated_by := nvl(wwv_flow.g_user,user);
           :new.row_version_number := 1;
         elsif updating then
           :new.row_version_number := nvl(:old.row_version_number,1) + 1;
         end if;
         if (inserting or updating) and nvl(sys.dbms_lob.getlength(:new.file_blob),0) > l_filesize_quota then
           raise_application_error(-20000, wwv_flow_lang.system_message('FILE_TOO_LARGE', trunc(l_filesize_mb)));
         end if;
         if inserting or updating then
           :new.updated := localtimestamp;
           :new.updated_by := nvl(wwv_flow.g_user,user);
         end if;
        end;
        
/
ALTER TRIGGER "CHARTER2_INV"."APEX$TEAM_DEV_FILES_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_ACL_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_ACL_T1" 
before insert or update on "APEX$_ACL"
for each row
begin
    --
    -- maintain pk and timestamps
    --
    :new.username := upper(:new.username);
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_ACL_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_FILES_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_FILES_T1" 
before insert or update on "APEX$_WS_FILES"
for each row
begin
    --
    -- maintain pk and timestamps
    --
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        :new.content_last_update := sysdate;
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        if nvl(length(:new.content),0) <> nvl(length(:old.content),0) then
            :new.content_last_update := sysdate;
        end if;
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_FILES_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_LINKS_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_LINKS_T1" 
before insert or update on "APEX$_WS_LINKS"
for each row
begin
    --
    -- maintain pk and timestamps
    --
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_LINKS_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_NOTES_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_NOTES_T1" 
before insert or update on "APEX$_WS_NOTES"
for each row
begin
    --
    -- maintain pk and timestamps
    --
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_NOTES_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_ROWS_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_ROWS_T1" 
before insert or update on "APEX$_WS_ROWS"
for each row
declare
    l_tag_list apex_application_global.vc_arr2;
    type col_arr is table of varchar2(32767) index by varchar2(255);
    la_col_label col_arr;
    procedure datagrid_logging( 
        p_row_id       in number,
        p_ws_app_id    in number,
        p_data_grid_id in number,
        p_col_name     in varchar2,
        p_type         in varchar2,
        p_old_c        in varchar2 default null,
        p_new_c        in varchar2 default null,
        p_old_d        in date default null,
        p_new_d        in date default null,
        p_old_n        in number default null,
        p_new_n        in number default null)
    is
    begin
        case p_type
        when 'C' then
          if (p_old_c is null and p_new_c is not null) or (p_old_c is not null and p_new_c is null) or (p_old_c != p_new_c) then
              insert into apex$_ws_history (row_id, ws_app_id, data_grid_id, column_name, old_value, new_value, change_date, application_user_id)
              values (p_row_id, p_ws_app_id, p_data_grid_id, p_col_name, p_old_c, p_new_c, sysdate, nvl(v('APP_USER'),user));
          end if;
        when 'D' then
          if (p_old_d is null and p_new_d is not null) or (p_old_d is not null and p_new_d is null) or (p_old_d != p_new_d) then
              insert into apex$_ws_history (row_id, ws_app_id, data_grid_id, column_name, old_value,  new_value, change_date, application_user_id)
              values (p_row_id, p_ws_app_id, p_data_grid_id, p_col_name, p_old_d, p_new_d, sysdate, nvl(v('APP_USER'),user));
        	  end if;
        when 'N' then
          if (p_old_n is null and p_new_n is not null) or (p_old_n is not null and p_new_n is null) or (p_old_n != p_new_n) then
              insert into apex$_ws_history (row_id, ws_app_id, data_grid_id, column_name, old_value,  new_value, change_date, application_user_id)
              values (p_row_id, p_ws_app_id, p_data_grid_id, p_col_name, p_old_n, p_new_n, sysdate, nvl(v('APP_USER'),user));
          end if;
        end case;
    end datagrid_logging;
    procedure wa( p_c in out nocopy clob, p_buf in varchar2 )
    is
    l_lf varchar2(2) := unistr('\000a');
    begin
    if p_buf is not null then sys.dbms_lob.writeappend( p_c, length(p_buf||l_lf), upper(p_buf)||l_lf); end if;
    end wa;
begin
    --
    -- maintain pk and timestamps
    --
    if inserting then
        if :new.id is null then
            select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
        end if;
        
        -- manintain readable row key
        if :new.unique_value is null then
            :new.unique_value := apex_util.compress_int(apex$_ws_seq.nextval);
        end if;
        
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.load_order from sys.dual;
        :new.change_count := 0;
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        :new.change_count := :old.change_count + 1;
    end if;
    --
    -- inserting remove chr 13
    --
    if instr(:new.c001,chr(13)) > 0 then :new.c001 := replace(:new.c001,chr(13),null); end if;
    if instr(:new.c002,chr(13)) > 0 then :new.c002 := replace(:new.c002,chr(13),null); end if;
    if instr(:new.c003,chr(13)) > 0 then :new.c003 := replace(:new.c003,chr(13),null); end if;
    if instr(:new.c004,chr(13)) > 0 then :new.c004 := replace(:new.c004,chr(13),null); end if;
    if instr(:new.c005,chr(13)) > 0 then :new.c005 := replace(:new.c005,chr(13),null); end if;
    if instr(:new.c006,chr(13)) > 0 then :new.c006 := replace(:new.c006,chr(13),null); end if;
    if instr(:new.c007,chr(13)) > 0 then :new.c007 := replace(:new.c007,chr(13),null); end if;
    if instr(:new.c008,chr(13)) > 0 then :new.c008 := replace(:new.c008,chr(13),null); end if;
    if instr(:new.c009,chr(13)) > 0 then :new.c009 := replace(:new.c009,chr(13),null); end if;
    if instr(:new.c010,chr(13)) > 0 then :new.c010 := replace(:new.c010,chr(13),null); end if;
    if instr(:new.c011,chr(13)) > 0 then :new.c011 := replace(:new.c011,chr(13),null); end if;
    if instr(:new.c012,chr(13)) > 0 then :new.c012 := replace(:new.c012,chr(13),null); end if;
    if instr(:new.c013,chr(13)) > 0 then :new.c013 := replace(:new.c013,chr(13),null); end if;
    if instr(:new.c014,chr(13)) > 0 then :new.c014 := replace(:new.c014,chr(13),null); end if;
    if instr(:new.c015,chr(13)) > 0 then :new.c015 := replace(:new.c015,chr(13),null); end if;
    if instr(:new.c016,chr(13)) > 0 then :new.c016 := replace(:new.c016,chr(13),null); end if;
    if instr(:new.c017,chr(13)) > 0 then :new.c017 := replace(:new.c017,chr(13),null); end if;
    if instr(:new.c018,chr(13)) > 0 then :new.c018 := replace(:new.c018,chr(13),null); end if;
    if instr(:new.c019,chr(13)) > 0 then :new.c019 := replace(:new.c019,chr(13),null); end if;
    if instr(:new.c020,chr(13)) > 0 then :new.c020 := replace(:new.c010,chr(23),null); end if;
    if instr(:new.c021,chr(13)) > 0 then :new.c021 := replace(:new.c001,chr(23),null); end if;
    if instr(:new.c022,chr(13)) > 0 then :new.c022 := replace(:new.c002,chr(23),null); end if;
    if instr(:new.c023,chr(13)) > 0 then :new.c023 := replace(:new.c003,chr(23),null); end if;
    if instr(:new.c024,chr(13)) > 0 then :new.c024 := replace(:new.c004,chr(23),null); end if;
    if instr(:new.c025,chr(13)) > 0 then :new.c025 := replace(:new.c005,chr(23),null); end if;
    if instr(:new.c026,chr(13)) > 0 then :new.c026 := replace(:new.c006,chr(23),null); end if;
    if instr(:new.c027,chr(13)) > 0 then :new.c027 := replace(:new.c007,chr(23),null); end if;
    if instr(:new.c028,chr(13)) > 0 then :new.c028 := replace(:new.c008,chr(23),null); end if;
    if instr(:new.c029,chr(13)) > 0 then :new.c029 := replace(:new.c009,chr(23),null); end if;
    if instr(:new.c030,chr(13)) > 0 then :new.c030 := replace(:new.c030,chr(13),null); end if;
    if instr(:new.c031,chr(13)) > 0 then :new.c031 := replace(:new.c031,chr(13),null); end if;
    if instr(:new.c032,chr(13)) > 0 then :new.c032 := replace(:new.c032,chr(13),null); end if;
    if instr(:new.c033,chr(13)) > 0 then :new.c033 := replace(:new.c033,chr(13),null); end if;
    if instr(:new.c034,chr(13)) > 0 then :new.c034 := replace(:new.c034,chr(13),null); end if;
    if instr(:new.c035,chr(13)) > 0 then :new.c035 := replace(:new.c035,chr(13),null); end if;
    if instr(:new.c036,chr(13)) > 0 then :new.c036 := replace(:new.c036,chr(13),null); end if;
    if instr(:new.c037,chr(13)) > 0 then :new.c037 := replace(:new.c037,chr(13),null); end if;
    if instr(:new.c038,chr(13)) > 0 then :new.c038 := replace(:new.c038,chr(13),null); end if;
    if instr(:new.c039,chr(13)) > 0 then :new.c039 := replace(:new.c039,chr(13),null); end if;
    if instr(:new.c040,chr(13)) > 0 then :new.c040 := replace(:new.c040,chr(13),null); end if;
    if instr(:new.c041,chr(13)) > 0 then :new.c041 := replace(:new.c041,chr(13),null); end if;
    if instr(:new.c042,chr(13)) > 0 then :new.c042 := replace(:new.c042,chr(13),null); end if;
    if instr(:new.c043,chr(13)) > 0 then :new.c043 := replace(:new.c043,chr(13),null); end if;
    if instr(:new.c044,chr(13)) > 0 then :new.c044 := replace(:new.c044,chr(13),null); end if;
    if instr(:new.c045,chr(13)) > 0 then :new.c045 := replace(:new.c045,chr(13),null); end if;
    if instr(:new.c046,chr(13)) > 0 then :new.c046 := replace(:new.c046,chr(13),null); end if;
    if instr(:new.c047,chr(13)) > 0 then :new.c047 := replace(:new.c047,chr(13),null); end if;
    if instr(:new.c048,chr(13)) > 0 then :new.c048 := replace(:new.c048,chr(13),null); end if;
    if instr(:new.c049,chr(13)) > 0 then :new.c049 := replace(:new.c049,chr(13),null); end if;
    if instr(:new.c050,chr(13)) > 0 then :new.c050 := replace(:new.c050,chr(13),null); end if;
    if :new.search_clob is null then
        sys.dbms_lob.createtemporary( :new.search_clob, false, sys.dbms_lob.session );
    else
        sys.dbms_lob.trim( :new.search_clob, 0 );
    end if;
    wa(:new.search_clob,:new.c001);wa(:new.search_clob,:new.c002);wa(:new.search_clob,:new.c003);
    wa(:new.search_clob,:new.c004);wa(:new.search_clob,:new.c005);wa(:new.search_clob,:new.c006);
    wa(:new.search_clob,:new.c007);wa(:new.search_clob,:new.c008);wa(:new.search_clob,:new.c009);
    wa(:new.search_clob,:new.c010);wa(:new.search_clob,:new.c011);wa(:new.search_clob,:new.c012);
    wa(:new.search_clob,:new.c013);wa(:new.search_clob,:new.c014);wa(:new.search_clob,:new.c015);
    wa(:new.search_clob,:new.c016);wa(:new.search_clob,:new.c017);wa(:new.search_clob,:new.c018);
    wa(:new.search_clob,:new.c019);wa(:new.search_clob,:new.c020);wa(:new.search_clob,:new.c021);
    wa(:new.search_clob,:new.c022);wa(:new.search_clob,:new.c023);wa(:new.search_clob,:new.c024);
    wa(:new.search_clob,:new.c025);wa(:new.search_clob,:new.c026);wa(:new.search_clob,:new.c027);
    wa(:new.search_clob,:new.c028);wa(:new.search_clob,:new.c029);wa(:new.search_clob,:new.c030);
    wa(:new.search_clob,:new.c031);wa(:new.search_clob,:new.c032);wa(:new.search_clob,:new.c033);
    wa(:new.search_clob,:new.c034);wa(:new.search_clob,:new.c035);wa(:new.search_clob,:new.c036);
    wa(:new.search_clob,:new.c037);wa(:new.search_clob,:new.c038);wa(:new.search_clob,:new.c039);
    wa(:new.search_clob,:new.c040);wa(:new.search_clob,:new.c041);wa(:new.search_clob,:new.c042);
    wa(:new.search_clob,:new.c043);wa(:new.search_clob,:new.c044);wa(:new.search_clob,:new.c045);
    wa(:new.search_clob,:new.c046);wa(:new.search_clob,:new.c047);wa(:new.search_clob,:new.c048);
    wa(:new.search_clob,:new.c049);wa(:new.search_clob,:new.c050);
    --
    -- history
    --
    if updating then
       -- initialize column label array
       for i in 1..50
       loop
           la_col_label('C'||to_char(i,'FM009')) := null;
           la_col_label('N'||to_char(i,'FM009')) := null;
           la_col_label('D'||to_char(i,'FM009')) := null;
       end loop;
       -- get column label array
       for c1 in (select column_alias, report_label 
                  from apex_ws_data_grid_col
                  where data_grid_id = :new.data_grid_id)
       loop
           la_col_label(c1.column_alias) := c1.report_label;
       end loop;
       -- strings
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C001'),'C',:old.c001,:new.c001);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C002'),'C',:old.c002,:new.c002);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C003'),'C',:old.c003,:new.c003);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C004'),'C',:old.c004,:new.c004);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C005'),'C',:old.c005,:new.c005);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C006'),'C',:old.c006,:new.c006);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C007'),'C',:old.c007,:new.c007);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C008'),'C',:old.c008,:new.c008);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C009'),'C',:old.c009,:new.c009);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C010'),'C',:old.c010,:new.c010);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C011'),'C',:old.c011,:new.c011);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C012'),'C',:old.c012,:new.c012);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C013'),'C',:old.c013,:new.c013);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C014'),'C',:old.c014,:new.c014);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C015'),'C',:old.c015,:new.c015);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C016'),'C',:old.c016,:new.c016);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C017'),'C',:old.c017,:new.c017);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C018'),'C',:old.c018,:new.c018);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C019'),'C',:old.c019,:new.c019);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C020'),'C',:old.c020,:new.c020);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C021'),'C',:old.c021,:new.c021);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C022'),'C',:old.c022,:new.c022);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C023'),'C',:old.c023,:new.c023);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C024'),'C',:old.c024,:new.c024);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C025'),'C',:old.c025,:new.c025);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C026'),'C',:old.c026,:new.c026);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C027'),'C',:old.c027,:new.c027);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C028'),'C',:old.c028,:new.c028);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C029'),'C',:old.c029,:new.c029);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C030'),'C',:old.c030,:new.c030);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C031'),'C',:old.c031,:new.c031);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C032'),'C',:old.c032,:new.c032);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C033'),'C',:old.c033,:new.c033);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C034'),'C',:old.c034,:new.c034);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C035'),'C',:old.c035,:new.c035);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C036'),'C',:old.c036,:new.c036);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C037'),'C',:old.c037,:new.c037);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C038'),'C',:old.c038,:new.c038);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C039'),'C',:old.c039,:new.c039);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C040'),'C',:old.c040,:new.c040);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C041'),'C',:old.c041,:new.c041);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C042'),'C',:old.c042,:new.c042);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C043'),'C',:old.c043,:new.c043);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C044'),'C',:old.c044,:new.c044);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C045'),'C',:old.c045,:new.c045);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C046'),'C',:old.c046,:new.c046);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C047'),'C',:old.c047,:new.c047);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C048'),'C',:old.c048,:new.c048);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C049'),'C',:old.c049,:new.c049);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('C050'),'C',:old.c050,:new.c050);
       -- numbers
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N001'),'N',null,null,null,null,:old.n001,:new.n001);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N002'),'N',null,null,null,null,:old.n002,:new.n002);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N003'),'N',null,null,null,null,:old.n003,:new.n003);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N004'),'N',null,null,null,null,:old.n004,:new.n004);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N005'),'N',null,null,null,null,:old.n005,:new.n005);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N006'),'N',null,null,null,null,:old.n006,:new.n006);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N007'),'N',null,null,null,null,:old.n007,:new.n007);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N008'),'N',null,null,null,null,:old.n008,:new.n008);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N009'),'N',null,null,null,null,:old.n009,:new.n009);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N010'),'N',null,null,null,null,:old.n010,:new.n010);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N011'),'N',null,null,null,null,:old.n011,:new.n011);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N012'),'N',null,null,null,null,:old.n012,:new.n012);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N013'),'N',null,null,null,null,:old.n013,:new.n013);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N014'),'N',null,null,null,null,:old.n014,:new.n014);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N015'),'N',null,null,null,null,:old.n015,:new.n015);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N016'),'N',null,null,null,null,:old.n016,:new.n016);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N017'),'N',null,null,null,null,:old.n017,:new.n017);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N018'),'N',null,null,null,null,:old.n018,:new.n018);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N019'),'N',null,null,null,null,:old.n019,:new.n019);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N020'),'N',null,null,null,null,:old.n020,:new.n020);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N021'),'N',null,null,null,null,:old.n021,:new.n021);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N022'),'N',null,null,null,null,:old.n022,:new.n022);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N023'),'N',null,null,null,null,:old.n023,:new.n023);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N024'),'N',null,null,null,null,:old.n024,:new.n024);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N025'),'N',null,null,null,null,:old.n025,:new.n025);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N026'),'N',null,null,null,null,:old.n026,:new.n026);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N027'),'N',null,null,null,null,:old.n027,:new.n027);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N028'),'N',null,null,null,null,:old.n028,:new.n028);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N029'),'N',null,null,null,null,:old.n029,:new.n029);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N030'),'N',null,null,null,null,:old.n030,:new.n030);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N031'),'N',null,null,null,null,:old.n031,:new.n031);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N032'),'N',null,null,null,null,:old.n032,:new.n032);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N033'),'N',null,null,null,null,:old.n033,:new.n033);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N034'),'N',null,null,null,null,:old.n034,:new.n034);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N035'),'N',null,null,null,null,:old.n035,:new.n035);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N036'),'N',null,null,null,null,:old.n036,:new.n036);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N037'),'N',null,null,null,null,:old.n037,:new.n037);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N038'),'N',null,null,null,null,:old.n038,:new.n038);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N039'),'N',null,null,null,null,:old.n039,:new.n039);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N040'),'N',null,null,null,null,:old.n040,:new.n040);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N041'),'N',null,null,null,null,:old.n041,:new.n041);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N042'),'N',null,null,null,null,:old.n042,:new.n042);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N043'),'N',null,null,null,null,:old.n043,:new.n043);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N044'),'N',null,null,null,null,:old.n044,:new.n044);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N045'),'N',null,null,null,null,:old.n045,:new.n045);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N046'),'N',null,null,null,null,:old.n046,:new.n046);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N047'),'N',null,null,null,null,:old.n047,:new.n047);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N048'),'N',null,null,null,null,:old.n048,:new.n048);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N049'),'N',null,null,null,null,:old.n049,:new.n049);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('N050'),'N',null,null,null,null,:old.n050,:new.n050);
       -- dates
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D001'),'D',null,null,:old.d001,:new.d001);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D002'),'D',null,null,:old.d002,:new.d002);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D003'),'D',null,null,:old.d003,:new.d003);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D004'),'D',null,null,:old.d004,:new.d004);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D005'),'D',null,null,:old.d005,:new.d005);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D006'),'D',null,null,:old.d006,:new.d006);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D007'),'D',null,null,:old.d007,:new.d007);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D008'),'D',null,null,:old.d008,:new.d008);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D009'),'D',null,null,:old.d009,:new.d009);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D010'),'D',null,null,:old.d010,:new.d010);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D011'),'D',null,null,:old.d011,:new.d011);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D012'),'D',null,null,:old.d012,:new.d012);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D013'),'D',null,null,:old.d013,:new.d013);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D014'),'D',null,null,:old.d014,:new.d014);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D015'),'D',null,null,:old.d015,:new.d015);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D016'),'D',null,null,:old.d016,:new.d016);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D017'),'D',null,null,:old.d017,:new.d017);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D018'),'D',null,null,:old.d018,:new.d018);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D019'),'D',null,null,:old.d019,:new.d019);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D020'),'D',null,null,:old.d020,:new.d020);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D021'),'D',null,null,:old.d021,:new.d021);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D022'),'D',null,null,:old.d022,:new.d022);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D023'),'D',null,null,:old.d023,:new.d023);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D024'),'D',null,null,:old.d024,:new.d024);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D025'),'D',null,null,:old.d025,:new.d025);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D026'),'D',null,null,:old.d026,:new.d026);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D027'),'D',null,null,:old.d027,:new.d027);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D028'),'D',null,null,:old.d028,:new.d028);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D029'),'D',null,null,:old.d029,:new.d029);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D030'),'D',null,null,:old.d030,:new.d030);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D031'),'D',null,null,:old.d031,:new.d031);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D032'),'D',null,null,:old.d032,:new.d032);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D033'),'D',null,null,:old.d033,:new.d033);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D034'),'D',null,null,:old.d034,:new.d034);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D035'),'D',null,null,:old.d035,:new.d035);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D036'),'D',null,null,:old.d036,:new.d036);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D037'),'D',null,null,:old.d037,:new.d037);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D038'),'D',null,null,:old.d038,:new.d038);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D039'),'D',null,null,:old.d039,:new.d039);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D040'),'D',null,null,:old.d040,:new.d040);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D041'),'D',null,null,:old.d041,:new.d041);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D042'),'D',null,null,:old.d042,:new.d042);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D043'),'D',null,null,:old.d043,:new.d043);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D044'),'D',null,null,:old.d044,:new.d044);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D045'),'D',null,null,:old.d045,:new.d045);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D046'),'D',null,null,:old.d046,:new.d046);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D047'),'D',null,null,:old.d047,:new.d047);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D048'),'D',null,null,:old.d048,:new.d048);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D049'),'D',null,null,:old.d049,:new.d049);
       datagrid_logging(:new.id,:new.ws_app_id,:new.data_grid_id,la_col_label('D050'),'D',null,null,:old.d050,:new.d050);
    end if;
    --
    -- set owner
    --
    if :new.owner is null then
        :new.owner := :new.created_by;
    end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_ROWS_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_TAGS_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_TAGS_T1" 
before insert or update on "APEX$_WS_TAGS"
for each row
begin
    --
    -- maintain pk and timestamps
    --
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_TAGS_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger APEX$_WS_WEBPG_SECTIONS_T1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS_T1" 
before insert or update on "APEX$_WS_WEBPG_SECTIONS"
for each row
declare
    l_sequence_changed varchar2(1) := 'N';
    l_title_changed varchar2(1) := 'N';
    l_content_changed varchar2(1) := 'N';
    procedure clob_upper( p_content in clob, p_content_upper in out nocopy clob)
    is
    l_buf varchar2(32767);
    l_off number;
    l_amt number;
    begin
    if p_content is not null then
        l_amt := 8000;
        l_off := 1;
         sys.dbms_lob.trim( p_content_upper, 0);
         begin
             loop
                 sys.dbms_lob.read( p_content, l_amt, l_off, l_buf );
                 l_buf := upper( l_buf );
                 sys.dbms_lob.writeappend( p_content_upper, length(l_buf), l_buf);
                 l_off := l_off + l_amt;
                 l_amt := 8000;
             end loop;
         exception
             when no_data_found then null;
         end;
     end if;
end clob_upper;
begin
    --
    -- maintain pk and timestamps
    --
    if inserting and :new.id is null then
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from sys.dual;
    end if;
    if :new.section_type = 'NAV_PAGE' then
        if :new.nav_include_link is null then
            :new.nav_include_link := 'Y';
        end if;
    end if;
    if inserting and :new.content is not null then
        sys.dbms_lob.createtemporary( :new.content_upper, false, sys.dbms_lob.call );
        clob_upper( :new.content, :new.content_upper );
    elsif updating then
        if :new.content_upper is null then
            sys.dbms_lob.createtemporary( :new.content_upper, false, sys.dbms_lob.call );
        end if;
        clob_upper( :new.content, :new.content_upper );
    end if;
    if inserting then
        :new.created_on := sysdate;
        :new.created_by := nvl(v('APP_USER'),user);
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        :new.change_count := 0;
    elsif updating then
        :new.updated_on := sysdate;
        :new.updated_by := nvl(v('APP_USER'),user);
        :new.change_count := nvl(:old.change_count,0) + 1;
        if nvl(:old.display_sequence,-999) != nvl(:new.display_sequence,-999) then
            l_sequence_changed := 'Y';
        end if;
        if nvl(:old.title,'jKKwZk') != nvl(:new.title,'jKKwZk') then
            l_title_changed := 'Y';
        end if;
        if sys.dbms_lob.compare(:new.content,:old.content) != 0 or nvl(length(:new.content),0) != nvl(length(:old.content),0) then
            l_content_changed := 'Y';
        end if;
        if l_sequence_changed = 'Y' or l_title_changed = 'Y' or l_content_changed = 'Y' then
            insert into apex$_ws_webpg_section_history (section_id, ws_app_id, webpage_id, old_display_sequence, new_display_sequence,
            old_title, new_title, old_content, new_content, change_date, application_user_id)
            values (:new.id, :new.ws_app_id, :new.webpage_id,
                    decode(l_sequence_changed,'Y',:old.display_sequence,null), decode(l_sequence_changed,'Y',:new.display_sequence,null),
                    decode(l_title_changed,'Y',:old.title,null), decode(l_title_changed,'Y',:new.title,null),
                    decode(l_content_changed,'Y',:old.content,null), decode(l_content_changed,'Y',:new.content,null), sysdate, nvl(v('APP_USER'),user));
        end if;
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS_T1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_BBALL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_BBALL" 
   before insert or update on eba_demo_chart_bball
   for each row
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_BBALL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_ORDERS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_ORDERS" 
   before insert or update on eba_demo_chart_orders
   for each row
begin  
   if :new."ORDER_ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.order_id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_ORDERS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_POP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_POP" 
   before insert or update on eba_demo_chart_population
   for each row
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting then
       :new.row_version_number := 1;
   elsif updating then
       :new.row_version_number := nvl(:old.row_version_number,1) + 1;
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_POP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_PRODUCTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_PRODUCTS" 
   before insert or update on eba_demo_chart_products
   for each row
begin  
   if :new."PRODUCT_ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.product_id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_PRODUCTS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_PROJ
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_PROJ" 
   before insert or update on eba_demo_chart_projects
   for each row 
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting then
       :new.row_version_number := 1;
   elsif updating then
       :new.row_version_number := nvl(:old.row_version_number,1) + 1;
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_PROJ" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_SAMPLE_DATA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_SAMPLE_DATA" 
   before insert or update on eba_demo_chart_sample_data
   for each row 
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_SAMPLE_DATA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_STATS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_STATS" 
   before insert or update on eba_demo_chart_stats
   for each row
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_STATS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_STOCKS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_STOCKS" 
   before insert or update on eba_demo_chart_stocks
   for each row
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting then
       :new.row_version_number := 1;
   elsif updating then
       :new.row_version_number := nvl(:old.row_version_number,1) + 1;
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_STOCKS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_EBA_DEMO_CHART_TASKS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_TASKS" 
   before insert or update on eba_demo_chart_tasks
   for each row
begin  
   if :new."ID" is null then
     select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') into :new.id from dual;
   end if;
   if inserting then
       :new.created := localtimestamp;
       :new.created_by := nvl(wwv_flow.g_user,user);
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting or updating then
       :new.updated := localtimestamp;
       :new.updated_by := nvl(wwv_flow.g_user,user);
   end if;
   if inserting then
       :new.row_version_number := 1;
   elsif updating then
       :new.row_version_number := nvl(:old.row_version_number,1) + 1;
   end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_EBA_DEMO_CHART_TASKS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_LOGGER_APEX_ITEMS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_LOGGER_APEX_ITEMS" 
  before insert or update on logger_logs_apex_items
for each row
begin
  $if $$logger_no_op_install $then
    null;
  $else
    :new.id := logger_apx_items_seq.nextval;
  $end
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_LOGGER_APEX_ITEMS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BIU_LOGGER_PREFS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BIU_LOGGER_PREFS" 
  before insert or update on logger_prefs
  for each row
begin
  $if $$logger_no_op_install $then
    null;
  $else
    :new.pref_name := upper(:new.pref_name);
    :new.pref_type := upper(:new.pref_type);

    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name = 'LEVEL' then
      :new.pref_value := upper(:new.pref_value);
    end if;

    -- TODO mdsouza: 3.1.1
    -- TODO mdsouza: if removing then decrease indent
    -- $if $$currently_installing is null or not $$currently_installing $then
      -- Since logger.pks may not be installed when this trigger is compiled, need to move some code here
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name = 'LEVEL'
        and upper(:new.pref_value) not in (logger.g_off_name, logger.g_permanent_name, logger.g_error_name, logger.g_warning_name, logger.g_information_name, logger.g_debug_name, logger.g_timing_name, logger.g_sys_context_name, logger.g_apex_name) then
        raise_application_error(-20000, '"LEVEL" must be one of the following values: ' ||
          logger.g_off_name || ', ' || logger.g_permanent_name || ', ' || logger.g_error_name || ', ' ||
          logger.g_warning_name || ', ' || logger.g_information_name || ', ' || logger.g_debug_name || ', ' ||
          logger.g_timing_name || ', ' || logger.g_sys_context_name || ', ' || logger.g_apex_name);
      end if;

      -- Allow for null to be used for Plugins, then default to NONE
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name like 'PLUGIN_FN%'
        and :new.pref_value is null then
        :new.pref_value := 'NONE';
      end if;

      -- #103
      -- Only predefined preferences and Custom Preferences are allowed
      -- Custom Preferences must be prefixed with CUST_
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name not in (
          'GLOBAL_CONTEXT_NAME'
          ,'INCLUDE_CALL_STACK'
          ,'INSTALL_SCHEMA'
          ,'LEVEL'
          ,'LOGGER_DEBUG'
          ,'LOGGER_VERSION'
          ,'PLUGIN_FN_ERROR'
          ,'PREF_BY_CLIENT_ID_EXPIRE_HOURS'
          ,'PROTECT_ADMIN_PROCS'
          ,'PURGE_AFTER_DAYS'
          ,'PURGE_MIN_LEVEL'
        )
      then
        raise_application_error (-20000, 'Setting system level preferences are restricted to a set list.');
      end if;

      -- this is because the logger package is not installed yet.  We enable it in logger_configure
      logger.null_global_contexts;
    -- TODO mdsouza: 3.1.1
    -- $end
  $end -- $$logger_no_op_install
end;

/
ALTER TRIGGER "CHARTER2_INV"."BIU_LOGGER_PREFS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_APP_PERSON
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_APP_PERSON" 
BEFORE
insert on v_app_person
for each row
begin
if :NEW.PERSON_ID is null then
 :NEW.PERSON_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
 :NEW.CREATED_ON := sysdate;
end if; 
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_APP_PERSON" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_APP_PERSON_ROLES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_APP_PERSON_ROLES" 
BEFORE
insert on v_app_person_roles
for each row
begin
 :NEW.CREATED_ON := sysdate;
end;

/
ALTER TRIGGER "CHARTER2_INV"."BI_V_APP_PERSON_ROLES" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_APP_ROLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_APP_ROLE" 
BEFORE
insert on v_app_role
for each row
begin
if  :NEW.ROLE_ID is null then

 :NEW.ROLE_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
 :NEW.CREATED_ON := sysdate;
end if;

end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_APP_ROLE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_BASELINE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_BASELINE" 
BEFORE insert or update ON V_LIC_BASELINE
for each row
begin

 if inserting then
       :NEW.BASELINE_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_BASELINE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_BASELINE_JSONLOAD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_BASELINE_JSONLOAD" 
BEFORE insert or update ON V_LIC_BASELINE_JSONLOAD
for each row
begin

 if inserting then
       :NEW.JSON_LOAD_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;

/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_BASELINE_JSONLOAD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_DB_INVENTORY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_DB_INVENTORY" 
BEFORE insert or update ON V_LIC_DB_INVENTORY
for each row
begin

 if inserting then
      :NEW.DATABASE_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_DB_INVENTORY" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_FEATURE_USAGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_FEATURE_USAGE" 
BEFORE insert or update ON V_LIC_FEATURE_USAGE
for each row
begin

 if inserting then
      :NEW.FEATURE_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_FEATURE_USAGE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_HOST_INV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_HOST_INV" 
BEFORE insert or update ON V_LIC_HOST_INV
for each row
begin
 if inserting then
      :NEW.HOST_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_HOST_INV" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_PRODUCT_PRICE_LIST
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_PRODUCT_PRICE_LIST" 
BEFORE insert or update ON V_LIC_PRODUCT_PRICE_LIST
for each row
begin
 if inserting then
 :NEW.PRODUCT_PRICE_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;

/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_PRODUCT_PRICE_LIST" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_LIC_PURCHASED_PRODUCTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_LIC_PURCHASED_PRODUCTS" 
BEFORE insert or update ON V_LIC_PURCHASED_PRODUCTS
for each row
begin
 if inserting then
 :NEW.PRODUCT_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_LIC_PURCHASED_PRODUCTS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger BI_V_V_LIC_PRODUCT_USAGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."BI_V_V_LIC_PRODUCT_USAGE" 
BEFORE insert or update ON V_LIC_PRODUCT_USAGE
for each row
begin
 if inserting then
 :NEW.PRODUCT_ID :=  to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end;
/
ALTER TRIGGER "CHARTER2_INV"."BI_V_V_LIC_PRODUCT_USAGE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DEPT_TRG1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."DEPT_TRG1" 
              before insert on dept
              for each row
              begin
                  if :new.deptno is null then
                      select dept_seq.nextval into :new.deptno from sys.dual;
                 end if;
              end;
/
ALTER TRIGGER "CHARTER2_INV"."DEPT_TRG1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger EMP_TRG1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."EMP_TRG1" 
              before insert on emp
              for each row
              begin
                  if :new.empno is null then
                      select emp_seq.nextval into :new.empno from sys.dual;
                 end if;
              end;
/
ALTER TRIGGER "CHARTER2_INV"."EMP_TRG1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger LOV_BI_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."LOV_BI_TRG" 
before insert on v_lov_tbl 
for each row 
begin
  if :new.LOV_id is null then
        :new.lov_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."LOV_BI_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger SOURCE_APP_UPDATE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."SOURCE_APP_UPDATE_BIU" 
    before insert or update
    on charter2_inv.SOURCE_APP_UPDATE
    for each row
begin
    if :new.SOURCE_APP_UPDATE_ID is null then
        :new.SOURCE_APP_UPDATE_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if :new.RELEASED_DT is null then
    :new.RELEASED_DT := sysdate;
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end SOURCE_APP_UPDATE_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."SOURCE_APP_UPDATE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_ANSIBLE_API_RESULT_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_ANSIBLE_API_RESULT_BIU" 
    before insert or update
    on charter2_inv.V_ANSIBLE_API_RESULT
    for each row
begin
    if :new.request_id is null then
        :new.request_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_ANSIBLE_API_RESULT_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_ANSIBLE_API_RESULT_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_ANSIBLE_REST_LOGS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_ANSIBLE_REST_LOGS_BIU" 
    before insert or update 
    on v_ansible_rest_logs
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
        :new.STATUS := nvl(:new.STATUS,'I');
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_ansible_rest_logs_biu;
/
ALTER TRIGGER "CHARTER2_INV"."V_ANSIBLE_REST_LOGS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_ANSIBLE_TEMPLATE_STORE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE_BIU" 
    before insert or update
    on charter2_inv.V_ANSIBLE_TEMPLATE_STORE
    for each row
begin
    if inserting then 
        if :new.id is null then
            :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        end if;
    end if;
   :new.TEMPLATE_STATUS := upper(:new.TEMPLATE_STATUS) ;
    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;


end V_ANSIBLE_TEMPLATE_STORE_BIU;
/
ALTER TRIGGER "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_APPLICATION_DETAILS_TBL_
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_" 
    before insert or update
    on charter2_inv.v_application_details_tbl
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_application_details_tbl_;

/
ALTER TRIGGER "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_APPLICATION_DETAILS_TBL_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_AUD" 
    after update or delete on charter2_inv.v_application_details_tbl
    for each row
declare
    t varchar2(128) := 'V_APPLICATION_DETAILS_TBL';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.application_name is null and :new.application_name is not null) or
        (:old.application_name is not null and :new.application_name is null) or
        :old.application_name != :new.application_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APPLICATION_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.application_name, :new.application_name);

    end if;
    if (:old.business_unit is null and :new.business_unit is not null) or
        (:old.business_unit is not null and :new.business_unit is null) or
        :old.business_unit != :new.business_unit then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'BUSINESS_UNIT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.business_unit, :new.business_unit);

    end if;
    if (:old.technical_contact is null and :new.technical_contact is not null) or
        (:old.technical_contact is not null and :new.technical_contact is null) or
        :old.technical_contact != :new.technical_contact then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'TECHNICAL_CONTACT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.technical_contact, :new.technical_contact);

    end if;
    if (:old.tech_contact_email is null and :new.tech_contact_email is not null) or
        (:old.tech_contact_email is not null and :new.tech_contact_email is null) or
        :old.tech_contact_email != :new.tech_contact_email then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'TECH_CONTACT_EMAIL', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.tech_contact_email, :new.tech_contact_email);

    end if;
    if (:old.app_desc is null and :new.app_desc is not null) or
        (:old.app_desc is not null and :new.app_desc is null) or
        :old.app_desc != :new.app_desc then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APP_DESC', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.app_desc, :new.app_desc);

    end if;
    if (:old.app_owner is null and :new.app_owner is not null) or
        (:old.app_owner is not null and :new.app_owner is null) or
        :old.app_owner != :new.app_owner then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APP_OWNER', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.app_owner, :new.app_owner);

    end if;
    if (:old.app_owner_email is null and :new.app_owner_email is not null) or
        (:old.app_owner_email is not null and :new.app_owner_email is null) or
        :old.app_owner_email != :new.app_owner_email then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APP_OWNER_EMAIL', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.app_owner_email, :new.app_owner_email);

    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APPLICATION_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.application_name, :new.application_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'BUSINESS_UNIT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.business_unit, :new.business_unit);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'TECHNICAL_CONTACT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.technical_contact, :new.technical_contact);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'TECH_CONTACT_EMAIL', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.tech_contact_email, :new.tech_contact_email);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APP_DESC', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.app_desc, :new.app_desc);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APP_OWNER', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.app_owner, :new.app_owner);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APP_OWNER_EMAIL', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.app_owner_email, :new.app_owner_email);

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_APP_SETTINGS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_APP_SETTINGS_BIU" 
    before insert or update
   on CHARTER2_INV.v_APP_SETTINGS
    for each row
begin

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;


end V_APP_SETTINGS_BIU;


/
ALTER TRIGGER "CHARTER2_INV"."V_APP_SETTINGS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_CHECKLIST_STATUS_BUI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_CHECKLIST_STATUS_BUI" 
    before insert or update
    on charter2_inv.V_CHECKLIST_STATUS
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.STATUS_ID is null then
        :new.STATUS_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end V_PROCESS_STATUS_BUI;

/
ALTER TRIGGER "CHARTER2_INV"."V_CHECKLIST_STATUS_BUI" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_CHECK_LIST_LOG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_CHECK_LIST_LOG" 
before insert on v_CHECK_LIST_LOGS
for each row 
begin
  if :new.log_id is null then
        :new.log_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        :new.created := sysdate;
    end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_CHECK_LIST_LOG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_CHECK_LIST_LOGS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_CHECK_LIST_LOGS_BIU" 
    before insert or update
    on charter2_inv.v_check_list_logs
    for each row
begin
    if :new.LOG_id is null then
        :new.LOG_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
    end if;

end V_CHECK_LIST_LOGS_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_CHECK_LIST_LOGS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_CLUSTER_MEMBER_TBL_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_AUD" 
    after update or delete on charter2_inv.v_cluster_member_tbl
    for each row
declare
    t varchar2(128) := 'V_CLUSTER_MEMBER_TBL';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.cluster_name is null and :new.cluster_name is not null) or
        (:old.cluster_name is not null and :new.cluster_name is null) or
        :old.cluster_name != :new.cluster_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'CLUSTER_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.cluster_name, :new.cluster_name);

    end if;
    if (:old.cluster_type is null and :new.cluster_type is not null) or
        (:old.cluster_type is not null and :new.cluster_type is null) or
        :old.cluster_type != :new.cluster_type then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'CLUSTER_TYPE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.cluster_type, :new.cluster_type);

    end if;
    if (:old.gi_version is null and :new.gi_version is not null) or
        (:old.gi_version is not null and :new.gi_version is null) or
        :old.gi_version != :new.gi_version then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GI_VERSION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.gi_version, :new.gi_version);

    end if;
    if (:old.gi_current_patchset is null and :new.gi_current_patchset is not null) or
        (:old.gi_current_patchset is not null and :new.gi_current_patchset is null) or
        :old.gi_current_patchset != :new.gi_current_patchset then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GI_CURRENT_PATCHSET', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.gi_current_patchset, :new.gi_current_patchset);

    end if;
    if (:old.v_HOST_CODE is null and :new.v_HOST_CODE is not null) or
        (:old.v_HOST_CODE is not null and :new.v_HOST_CODE is null) or
        :old.v_HOST_CODE != :new.v_HOST_CODE then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'v_HOST_CODE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.v_HOST_CODE, :new.v_HOST_CODE);

    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'CLUSTER_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.cluster_name, :new.cluster_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'CLUSTER_TYPE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.cluster_type, :new.cluster_type);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GI_VERSION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.gi_version, :new.gi_version);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GI_CURRENT_PATCHSET', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.gi_current_patchset, :new.gi_current_patchset);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'v_HOST_CODE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.v_HOST_CODE, :new.v_HOST_CODE);

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_CLUSTER_MEMBER_TBL_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_BIU" 
    before insert or update
    on charter2_inv.v_cluster_member_tbl
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_cluster_member_tbl_biu;

/
ALTER TRIGGER "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_CHECK_LIST_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_CHECK_LIST_AUD" 
    after update or delete on charter2_inv.v_db_check_list
    for each row
declare
    t varchar2(128) := 'V_DB_CHECK_LIST';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.check_list_id is null and :new.check_list_id is not null) or
        (:old.check_list_id is not null and :new.check_list_id is null) or
        :old.check_list_id != :new.check_list_id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'check_list_id', :old.check_list_id, null, 'U', sysdate, u, 'NUMBER', :old.check_list_id, :new.check_list_id);

    end if;
    
     if (:old.db_name is null and :new.db_name is not null) or
        (:old.db_name is not null and :new.db_name is null) or
        :old.db_name != :new.db_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'db_name', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_name, :new.db_name);

    end if;
    if (:old.checklist_type is null and :new.checklist_type is not null) or
        (:old.checklist_type is not null and :new.checklist_type is null) or
        :old.checklist_type != :new.checklist_type then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'CHECKLIST_TYPE', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.checklist_type, :new.checklist_type);

    end if;
    if (:old.post_build_status is null and :new.post_build_status is not null) or
        (:old.post_build_status is not null and :new.post_build_status is null) or
        :old.post_build_status != :new.post_build_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'POST_BUILD_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.post_build_status, :new.post_build_status);

    end if;
    if (:old.cluster_verify is null and :new.cluster_verify is not null) or
        (:old.cluster_verify is not null and :new.cluster_verify is null) or
        :old.cluster_verify != :new.cluster_verify then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'CLUSTER_VERIFY', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.cluster_verify, :new.cluster_verify);

    end if;
    if (:old.gi_install_status is null and :new.gi_install_status is not null) or
        (:old.gi_install_status is not null and :new.gi_install_status is null) or
        :old.gi_install_status != :new.gi_install_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GI_INSTALL_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.gi_install_status, :new.gi_install_status);

    end if;
    if (:old.db_install_status is null and :new.db_install_status is not null) or
        (:old.db_install_status is not null and :new.db_install_status is null) or
        :old.db_install_status != :new.db_install_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DB_INSTALL_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_install_status, :new.db_install_status);

    end if;
    if (:old.db_upgrade_status is null and :new.db_upgrade_status is not null) or
        (:old.db_upgrade_status is not null and :new.db_upgrade_status is null) or
        :old.db_upgrade_status != :new.db_upgrade_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DB_UPGRADE_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_upgrade_status, :new.db_upgrade_status);

    end if;
    if (:old.gi_upgrade_status is null and :new.gi_upgrade_status is not null) or
        (:old.gi_upgrade_status is not null and :new.gi_upgrade_status is null) or
        :old.gi_upgrade_status != :new.gi_upgrade_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GI_UPGRADE_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.gi_upgrade_status, :new.gi_upgrade_status);

    end if;
    if (:old.migration_status is null and :new.migration_status is not null) or
        (:old.migration_status is not null and :new.migration_status is null) or
        :old.migration_status != :new.migration_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.migration_status, :new.migration_status);

    end if;
    if (:old.post_migration_status is null and :new.post_migration_status is not null) or
        (:old.post_migration_status is not null and :new.post_migration_status is null) or
        :old.post_migration_status != :new.post_migration_status then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'POST_MIGRATION_STATUS', :old.check_list_id, null, 'U', sysdate, u, 'VARCHAR2', :old.post_migration_status, :new.post_migration_status);

    end if;
  

elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.check_list_id, null, 'D', sysdate, u, 'NUMBER', :old.check_list_id, :new.check_list_id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'DB_NAME', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_name, :new.db_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'CHECKLIST_TYPE', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.checklist_type, :new.checklist_type);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'POST_BUILD_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.post_build_status, :new.post_build_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'CLUSTER_VERIFY', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.cluster_verify, :new.cluster_verify);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GI_INSTALL_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.gi_install_status, :new.gi_install_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DB_INSTALL_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_install_status, :new.db_install_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DB_UPGRADE_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_upgrade_status, :new.db_upgrade_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GI_UPGRADE_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.gi_upgrade_status, :new.gi_upgrade_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'MIGRATION_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.migration_status, :new.migration_status);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'POST_MIGRATION_STATUS', :old.check_list_id, null, 'D', sysdate, u, 'VARCHAR2', :old.post_migration_status, :new.post_migration_status);
  

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_CHECK_LIST_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_CHECK_LIST_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_CHECK_LIST_BIU" 
    before insert or update
    on charter2_inv.v_db_check_list
    for each row
begin
    if :new.check_list_id is null then
        :new.check_list_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_db_check_list_biu;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_CHECK_LIST_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_INVENTORY_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_INVENTORY_AUD" 
    after update or delete on charter2_inv.v_db_inventory
    for each row
declare
    t varchar2(128) := 'V_DB_INVENTORY';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.database_name is null and :new.database_name is not null) or
        (:old.database_name is not null and :new.database_name is null) or
        :old.database_name != :new.database_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DATABASE_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.database_name, :new.database_name);

    end if;
    if (:old.application_name is null and :new.application_name is not null) or
        (:old.application_name is not null and :new.application_name is null) or
        :old.application_name != :new.application_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APPLICATION_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.application_name, :new.application_name);

    end if;
    if (:old.environment is null and :new.environment is not null) or
        (:old.environment is not null and :new.environment is null) or
        :old.environment != :new.environment then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'ENVIRONMENT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.environment, :new.environment);

    end if;
   
    if (:old.oracle_version is null and :new.oracle_version is not null) or
        (:old.oracle_version is not null and :new.oracle_version is null) or
        :old.oracle_version != :new.oracle_version then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'ORACLE_VERSION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.oracle_version, :new.oracle_version);

    end if;
    
    if (:old.rac_type is null and :new.rac_type is not null) or
        (:old.rac_type is not null and :new.rac_type is null) or
        :old.rac_type != :new.rac_type then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'RAC_TYPE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.rac_type, :new.rac_type);

    end if;
    if (:old.business_unit is null and :new.business_unit is not null) or
        (:old.business_unit is not null and :new.business_unit is null) or
        :old.business_unit != :new.business_unit then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'BUSINESS_UNIT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.business_unit, :new.business_unit);

    end if;
    if (:old.storage_type is null and :new.storage_type is not null) or
        (:old.storage_type is not null and :new.storage_type is null) or
        :old.storage_type != :new.storage_type then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'storage_type', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.storage_type, :new.storage_type);

    end if;
    
    if (:old.appliance is null and :new.appliance is not null) or
        (:old.appliance is not null and :new.appliance is null) or
        :old.appliance != :new.appliance then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'APPLIANCE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.appliance, :new.appliance);

    end if;
    if (:old.database_role is null and :new.database_role is not null) or
        (:old.database_role is not null and :new.database_role is null) or
        :old.database_role != :new.database_role then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DATABASE_ROLE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.database_role, :new.database_role);

    end if;
    if (:old.pci_required is null and :new.pci_required is not null) or
        (:old.pci_required is not null and :new.pci_required is null) or
        :old.pci_required != :new.pci_required then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'PCI_REQUIRED', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.pci_required, :new.pci_required);

    end if;
    if (:old.sox_required is null and :new.sox_required is not null) or
        (:old.sox_required is not null and :new.sox_required is null) or
        :old.sox_required != :new.sox_required then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SOX_REQUIRED', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.sox_required, :new.sox_required);

    end if;
    if (:old.encryption_required is null and :new.encryption_required is not null) or
        (:old.encryption_required is not null and :new.encryption_required is null) or
        :old.encryption_required != :new.encryption_required then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'ENCRYPTION_REQUIRED', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.encryption_required, :new.encryption_required);

    end if;
    if (:old.dataguard is null and :new.dataguard is not null) or
        (:old.dataguard is not null and :new.dataguard is null) or
        :old.dataguard != :new.dataguard then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DATAGUARD', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.dataguard, :new.dataguard);

    end if;
    if (:old.golden_gate is null and :new.golden_gate is not null) or
        (:old.golden_gate is not null and :new.golden_gate is null) or
        :old.golden_gate != :new.golden_gate then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GOLDEN_GATE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.golden_gate, :new.golden_gate);

    end if;
    if (:old.backup_enabled is null and :new.backup_enabled is not null) or
        (:old.backup_enabled is not null and :new.backup_enabled is null) or
        :old.backup_enabled != :new.backup_enabled then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'BACKUP_ENABLED', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.backup_enabled, :new.backup_enabled);

    end if;
    if (:old.end_of_life is null and :new.end_of_life is not null) or
        (:old.end_of_life is not null and :new.end_of_life is null) or
        :old.end_of_life != :new.end_of_life then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'END_OF_LIFE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.end_of_life, :new.end_of_life);

    end if;
    if (:old.db_monitoring_tool is null and :new.db_monitoring_tool is not null) or
        (:old.db_monitoring_tool is not null and :new.db_monitoring_tool is null) or
        :old.db_monitoring_tool != :new.db_monitoring_tool then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DB_MONITORING_TOOL', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_monitoring_tool, :new.db_monitoring_tool);

    end if;
    if (:old.monitoring is null and :new.monitoring is not null) or
        (:old.monitoring is not null and :new.monitoring is null) or
        :old.monitoring != :new.monitoring then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MONITORING', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.monitoring, :new.monitoring);

    end if;
    if (:old.comments is null and :new.comments is not null) or
        (:old.comments is not null and :new.comments is null) or
        :old.comments != :new.comments then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'COMMENTS', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.comments, :new.comments);

    end if;
    if (:old.instance_count is null and :new.instance_count is not null) or
        (:old.instance_count is not null and :new.instance_count is null) or
        :old.instance_count != :new.instance_count then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'INSTANCE_COUNT', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.instance_count, :new.instance_count);

    end if;
    if (:old.db_source is null and :new.db_source is not null) or
        (:old.db_source is not null and :new.db_source is null) or
        :old.db_source != :new.db_source then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DB_SOURCE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_source, :new.db_source);

    end if;
   
    if (:old.dr_solution is null and :new.dr_solution is not null) or
        (:old.dr_solution is not null and :new.dr_solution is null) or
        :old.dr_solution != :new.dr_solution then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DR_SOLUTION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.dr_solution, :new.dr_solution);

    end if;
    if (:old.dr_location is null and :new.dr_location is not null) or
        (:old.dr_location is not null and :new.dr_location is null) or
        :old.dr_location != :new.dr_location then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DR_LOCATION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.dr_location, :new.dr_location);

    end if;
    if (:old.env_category is null and :new.env_category is not null) or
        (:old.env_category is not null and :new.env_category is null) or
        :old.env_category != :new.env_category then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'ENV_CATEGORY', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.env_category, :new.env_category);

    end if;
    if (:old.db_home is null and :new.db_home is not null) or
        (:old.db_home is not null and :new.db_home is null) or
        :old.db_home != :new.db_home then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'db_home', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.db_home, :new.db_home);
            end if;
    if (:old.SW_CSI is null and :new.SW_CSI is not null) or
        (:old.SW_CSI is not null and :new.SW_CSI is null) or
        :old.SW_CSI != :new.SW_CSI then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SW_CSI', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.SW_CSI, :new.SW_CSI);

    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DATABASE_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.database_name, :new.database_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APPLICATION_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.application_name, :new.application_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'ENVIRONMENT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.environment, :new.environment);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'ORACLE_VERSION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.oracle_version, :new.oracle_version);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'storage_type', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.storage_type, :new.storage_type);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'RAC_TYPE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.rac_type, :new.rac_type);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'BUSINESS_UNIT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.business_unit, :new.business_unit);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'APPLIANCE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.appliance, :new.appliance);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DATABASE_ROLE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.database_role, :new.database_role);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'PCI_REQUIRED', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.pci_required, :new.pci_required);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SOX_REQUIRED', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.sox_required, :new.sox_required);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'ENCRYPTION_REQUIRED', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.encryption_required, :new.encryption_required);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DATAGUARD', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.dataguard, :new.dataguard);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GOLDEN_GATE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.golden_gate, :new.golden_gate);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'BACKUP_ENABLED', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.backup_enabled, :new.backup_enabled);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'END_OF_LIFE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.end_of_life, :new.end_of_life);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DB_MONITORING_TOOL', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_monitoring_tool, :new.db_monitoring_tool);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'MONITORING', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.monitoring, :new.monitoring);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'COMMENTS', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.comments, :new.comments);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'INSTANCE_COUNT', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.instance_count, :new.instance_count);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DB_SOURCE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_source, :new.db_source);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DR_SOLUTION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.dr_solution, :new.dr_solution);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DR_LOCATION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.dr_location, :new.dr_location);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'ENV_CATEGORY', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.env_category, :new.env_category);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'HOST_CODE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.v_host_code, :new.v_host_code);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DB_HOME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.db_home, :new.db_home);
         insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SW_CSI', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.SW_CSI, :new.SW_CSI);


end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_INVENTORY_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_INVENTORY_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_INVENTORY_BIU" 
    before insert or update
    on charter2_inv.v_db_inventory
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
       
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
          insert into V_DB_SCHEDULE_TBL (DB_ID) values (:new.id);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    
   
end v_db_inventory_biu;

/
ALTER TRIGGER "CHARTER2_INV"."V_DB_INVENTORY_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_PATCH_HISTORY_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_PATCH_HISTORY_AUD" 
    after update or delete on charter2_inv.v_db_patch_history
    for each row
declare
    t varchar2(128) := 'v_db_patch_history';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.db_id is null and :new.db_id is not null) or
        (:old.db_id is not null and :new.db_id is null) or
        :old.db_id != :new.db_id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'DB_ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.db_id, :new.db_id);

    end if;
    if (:old.PSU_QUARTER is null and :new.PSU_QUARTER is not null) or
        (:old.PSU_QUARTER is not null and :new.PSU_QUARTER is null) or
        :old.PSU_QUARTER != :new.PSU_QUARTER then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'PSU_QUARTER', :old.id, null, 'U', sysdate, u, 'DATE', :old.PSU_QUARTER, :new.PSU_QUARTER);

    end if;
    if (:old.PSU_NUMBER is null and :new.PSU_NUMBER is not null) or
        (:old.PSU_NUMBER is not null and :new.PSU_NUMBER is null) or
        :old.PSU_NUMBER != :new.PSU_NUMBER then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'PSU_NUMBER', :old.id, null, 'U', sysdate, u, 'DATE', :old.PSU_NUMBER, :new.PSU_NUMBER);

    end if;
    if (:old.PSU_YEAR is null and :new.PSU_YEAR is not null) or
        (:old.PSU_YEAR is not null and :new.PSU_YEAR is null) or
        :old.PSU_YEAR != :new.PSU_YEAR then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'PSU_YEAR', :old.id, null, 'U', sysdate, u, 'DATE', :old.PSU_YEAR, :new.PSU_YEAR);

    end if;
    if (:old.PATCH_TYPE is null and :new.PATCH_TYPE is not null) or
        (:old.PSU_YEAR is not null and :new.PATCH_TYPE is null) or
        :old.PATCH_TYPE != :new.PATCH_TYPE then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'PATCH_TYPE', :old.id, null, 'U', sysdate, u, 'DATE', :old.PATCH_TYPE, :new.PATCH_TYPE);

    end if;

elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'DB_ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.db_id, :new.db_id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'PSU_QUARTER', :old.id, null, 'D', sysdate, u, 'DATE', :old.PSU_QUARTER, :new.PSU_QUARTER);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'PSU_NUMBER', :old.id, null, 'D', sysdate, u, 'DATE', :old.PSU_NUMBER, :new.PSU_NUMBER);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'PSU_YEAR', :old.id, null, 'D', sysdate, u, 'DATE', :old.PSU_YEAR, :new.PSU_YEAR);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'PATCH_TYPE', :old.id, null, 'D', sysdate, u, 'DATE', :old.PATCH_TYPE, :new.PATCH_TYPE);

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_PATCH_HISTORY_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_PATCH_HISTORY_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_PATCH_HISTORY_BIU" 
before insert on v_DB_patch_history 
for each row 
begin
  if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
     if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;

end;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_PATCH_HISTORY_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_SCHEDULE_TBL_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_SCHEDULE_TBL_AUD" 
    after update or delete on charter2_inv.v_db_schedule_tbl
    for each row
declare
    t varchar2(128) := 'V_DB_SCHEDULE_TBL';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.db_id is null and :new.db_id is not null) or
        (:old.db_id is not null and :new.db_id is null) or
        :old.db_id != :new.db_id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'DB_ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.db_id, :new.db_id);

    end if;
    if (:old.upgrade_start_date is null and :new.upgrade_start_date is not null) or
        (:old.upgrade_start_date is not null and :new.upgrade_start_date is null) or
        :old.upgrade_start_date != :new.upgrade_start_date then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'UPGRADE_START_DATE', :old.id, null, 'U', sysdate, u, 'DATE', :old.upgrade_start_date, :new.upgrade_start_date);

    end if;
    if (:old.upgrade_end_date is null and :new.upgrade_end_date is not null) or
        (:old.upgrade_end_date is not null and :new.upgrade_end_date is null) or
        :old.upgrade_end_date != :new.upgrade_end_date then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'UPGRADE_END_DATE', :old.id, null, 'U', sysdate, u, 'DATE', :old.upgrade_end_date, :new.upgrade_end_date);

    end if;
    if (:old.migration_start_date is null and :new.migration_start_date is not null) or
        (:old.migration_start_date is not null and :new.migration_start_date is null) or
        :old.migration_start_date != :new.migration_start_date then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_START_DATE', :old.id, null, 'U', sysdate, u, 'DATE', :old.migration_start_date, :new.migration_start_date);

    end if;
    if (:old.migration_end_date is null and :new.migration_end_date is not null) or
        (:old.migration_end_date is not null and :new.migration_end_date is null) or
        :old.migration_end_date != :new.migration_end_date then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_END_DATE', :old.id, null, 'U', sysdate, u, 'DATE', :old.migration_end_date, :new.migration_end_date);

    end if;
    if (:old.upgrade_completion_time is null and :new.upgrade_completion_time is not null) or
        (:old.upgrade_completion_time is not null and :new.upgrade_completion_time is null) or
        :old.upgrade_completion_time != :new.upgrade_completion_time then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'upgrade_completion_time', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.upgrade_completion_time, :new.upgrade_completion_time);

    end if;
    if (:old.migration_completion_time is null and :new.migration_completion_time is not null) or
        (:old.migration_completion_time is not null and :new.migration_completion_time is null) or
        :old.migration_completion_time != :new.migration_completion_time then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_COMPLETION_TIME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.migration_completion_time, :new.migration_completion_time);

    end if;
    if (:old.migration_method is null and :new.migration_method is not null) or
        (:old.migration_method is not null and :new.migration_method is null) or
        :old.migration_method != :new.migration_method then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_METHOD', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.migration_method, :new.migration_method);

    end if;
    if (:old.outage_window is null and :new.outage_window is not null) or
        (:old.outage_window is not null and :new.outage_window is null) or
        :old.outage_window != :new.outage_window then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'OUTAGE_WINDOW', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.outage_window, :new.outage_window);

    end if;
    if (:old.comments is null and :new.comments is not null) or
        (:old.comments is not null and :new.comments is null) or
        :old.comments != :new.comments then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'COMMENTS', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.comments, :new.comments);

    end if;
    
    if (:old.MIGRATION_DEST is null and :new.MIGRATION_DEST is not null) or
        (:old.MIGRATION_DEST is not null and :new.MIGRATION_DEST is null) or
        :old.MIGRATION_DEST != :new.MIGRATION_DEST then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_DEST', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.MIGRATION_DEST, :new.MIGRATION_DEST);

    end if;
    
     if (:old.MIGRATION_DEST_HOST_CODE is null and :new.MIGRATION_DEST_HOST_CODE is not null) or
        (:old.MIGRATION_DEST_HOST_CODE is not null and :new.MIGRATION_DEST_HOST_CODE is null) or
        :old.MIGRATION_DEST_HOST_CODE != :new.MIGRATION_DEST_HOST_CODE then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MIGRATION_DEST_HOST_CODE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.MIGRATION_DEST_HOST_CODE, :new.MIGRATION_DEST_HOST_CODE);

    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'DB_ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.db_id, :new.db_id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'UPGRADE_START_DATE', :old.id, null, 'D', sysdate, u, 'DATE', :old.upgrade_start_date, :new.upgrade_start_date);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'UPGRADE_END_DATE', :old.id, null, 'D', sysdate, u, 'DATE', :old.upgrade_end_date, :new.upgrade_end_date);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'MIGRATION_START_DATE', :old.id, null, 'D', sysdate, u, 'DATE', :old.migration_start_date, :new.migration_start_date);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_date, new_date
    ) values (
        v_history_seq.nextval, t, 'MIGRATION_END_DATE', :old.id, null, 'D', sysdate, u, 'DATE', :old.migration_end_date, :new.migration_end_date);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'UPGRADE_COMPLETION_TIME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.upgrade_completion_time, :new.upgrade_completion_time);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'MIGRATION_COMPLETION_TIME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.migration_completion_time, :new.migration_completion_time);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'MIGRATION_METHOD', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.migration_method, :new.migration_method);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'OUTAGE_WINDOW', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.outage_window, :new.outage_window);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'COMMENTS', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.comments, :new.comments);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'Migration_Dest', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.Migration_Dest, :new.Migration_Dest);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'Migration_Dest_host_code', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.Migration_Dest_host_code, :new.Migration_Dest_host_code);

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_DB_SCHEDULE_TBL_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_DB_SCHEDULE_TBL_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_DB_SCHEDULE_TBL_BIU" 
    before insert or update
    on charter2_inv.v_db_schedule_tbl
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_db_schedule_tbl_biu;

/
ALTER TRIGGER "CHARTER2_INV"."V_DB_SCHEDULE_TBL_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_HOST_INV_TBL_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_HOST_INV_TBL_AUD" 
    after update or delete on charter2_inv.v_host_inv_tbl
    for each row
declare
    t varchar2(128) := 'V_HOST_INV_TBL';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.host_name is null and :new.host_name is not null) or
        (:old.host_name is not null and :new.host_name is null) or
        :old.host_name != :new.host_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'HOST_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.host_name, :new.host_name);

    end if;
    if (:old.network_type is null and :new.network_type is not null) or
        (:old.network_type is not null and :new.network_type is null) or
        :old.network_type != :new.network_type then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'NETWORK_TYPE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.network_type, :new.network_type);

    end if;
    if (:old.core_count is null and :new.core_count is not null) or
        (:old.core_count is not null and :new.core_count is null) or
        :old.core_count != :new.core_count then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'CORE_COUNT', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.core_count, :new.core_count);

    end if;
    if (:old.processor_config_speed is null and :new.processor_config_speed is not null) or
        (:old.processor_config_speed is not null and :new.processor_config_speed is null) or
        :old.processor_config_speed != :new.processor_config_speed then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'PROCESSOR_CONFIG_SPEED', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.processor_config_speed, :new.processor_config_speed);

    end if;
    if (:old.server_model is null and :new.server_model is not null) or
        (:old.server_model is not null and :new.server_model is null) or
        :old.server_model != :new.server_model then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SERVER_MODEL', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.server_model, :new.server_model);

    end if;
    if (:old.hardware_vendor is null and :new.hardware_vendor is not null) or
        (:old.hardware_vendor is not null and :new.hardware_vendor is null) or
        :old.hardware_vendor != :new.hardware_vendor then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'HARDWARE_VENDOR', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.hardware_vendor, :new.hardware_vendor);

    end if;
    if (:old.os_type_version is null and :new.os_type_version is not null) or
        (:old.os_type_version is not null and :new.os_type_version is null) or
        :old.os_type_version != :new.os_type_version then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'OS_TYPE_VERSION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.os_type_version, :new.os_type_version);

    end if;
    if (:old.processor_bit is null and :new.processor_bit is not null) or
        (:old.processor_bit is not null and :new.processor_bit is null) or
        :old.processor_bit != :new.processor_bit then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'PROCESSOR_BIT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.processor_bit, :new.processor_bit);

    end if;
    if (:old.server_creation_date is null and :new.server_creation_date is not null) or
        (:old.server_creation_date is not null and :new.server_creation_date is null) or
        :old.server_creation_date != :new.server_creation_date then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SERVER_CREATION_DATE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.server_creation_date, :new.server_creation_date);

    end if;
    if (:old.phy_virt is null and :new.phy_virt is not null) or
        (:old.phy_virt is not null and :new.phy_virt is null) or
        :old.phy_virt != :new.phy_virt then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'PHY_VIRT', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.phy_virt, :new.phy_virt);

    end if;
    if (:old.dc_location is null and :new.dc_location is not null) or
        (:old.dc_location is not null and :new.dc_location is null) or
        :old.dc_location != :new.dc_location then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'DC_LOCATION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.dc_location, :new.dc_location);

    end if;
    if (:old.global_zone_solaris is null and :new.global_zone_solaris is not null) or
        (:old.global_zone_solaris is not null and :new.global_zone_solaris is null) or
        :old.global_zone_solaris != :new.global_zone_solaris then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'GLOBAL_ZONE_SOLARIS', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.global_zone_solaris, :new.global_zone_solaris);

    end if;
    if (:old.phy_memory is null and :new.phy_memory is not null) or
        (:old.phy_memory is not null and :new.phy_memory is null) or
        :old.phy_memory != :new.phy_memory then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'PHY_MEMORY', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.phy_memory, :new.phy_memory);

    end if;
    if (:old.server_monitoring_tool is null and :new.server_monitoring_tool is not null) or
        (:old.server_monitoring_tool is not null and :new.server_monitoring_tool is null) or
        :old.server_monitoring_tool != :new.server_monitoring_tool then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SERVER_MONITORING_TOOL', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.server_monitoring_tool, :new.server_monitoring_tool);

    end if;
    if (:old.host_code is null and :new.host_code is not null) or
        (:old.host_code is not null and :new.host_code is null) or
        :old.host_code != :new.host_code then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'HOST_CODE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.host_code, :new.host_code);
    end if;
    
      if (:old.HW_CSI is null and :new.HW_CSI is not null) or
        (:old.HW_CSI is not null and :new.HW_CSI is null) or
        :old.HW_CSI != :new.HW_CSI then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'HW_CSI', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.HW_CSI, :new.HW_CSI);
    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'HOST_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.host_name, :new.host_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'NETWORK_TYPE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.network_type, :new.network_type);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'CORE_COUNT', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.core_count, :new.core_count);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'PROCESSOR_CONFIG_SPEED', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.processor_config_speed, :new.processor_config_speed);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SERVER_MODEL', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.server_model, :new.server_model);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'HARDWARE_VENDOR', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.hardware_vendor, :new.hardware_vendor);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'OS_TYPE_VERSION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.os_type_version, :new.os_type_version);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'PROCESSOR_BIT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.processor_bit, :new.processor_bit);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SERVER_CREATION_DATE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.server_creation_date, :new.server_creation_date);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'PHY_VIRT', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.phy_virt, :new.phy_virt);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'DC_LOCATION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.dc_location, :new.dc_location);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'GLOBAL_ZONE_SOLARIS', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.global_zone_solaris, :new.global_zone_solaris);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'PHY_MEMORY', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.phy_memory, :new.phy_memory);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SERVER_MONITORING_TOOL', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.server_monitoring_tool, :new.server_monitoring_tool);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'HOST_CODE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.host_code, :new.host_code);
            insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'HW_CSI', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.hw_csi, :new.hw_csi);


end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_HOST_INV_TBL_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_HOST_INV_TBL_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_HOST_INV_TBL_BIU" 
    before insert or update
    on charter2_inv.v_host_inv_tbl
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        if :new.clustered = 'N' then
        if     :new.host_code is null then
            :new.host_code := get_host_code(:new.env_source);
        end if;
        end if;
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_host_inv_tbl_biu;
/
ALTER TRIGGER "CHARTER2_INV"."V_HOST_INV_TBL_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_ITSM_API_RESULT_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_ITSM_API_RESULT_BIU" 
    before insert or update
    on charter2_inv.V_ITSM_API_RESULT
    for each row
begin
    if :new.request_id is null then
        :new.request_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_ITSM_API_RESULT_BIU;


/
ALTER TRIGGER "CHARTER2_INV"."V_ITSM_API_RESULT_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_LIC_DISCOVERY_SCHEDULE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_LIC_DISCOVERY_SCHEDULE_BIU" 
    before insert or update
    on charter2_inv.V_LIC_DISCOVERY_SCHEDULE
    for each row
begin
    if :new.LIC_SCHEDULE_ID is null then
        :new.LIC_SCHEDULE_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_LIC_DISCOVERY_SCHEDULE_BIU;


/
ALTER TRIGGER "CHARTER2_INV"."V_LIC_DISCOVERY_SCHEDULE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_PATCH_REQUEST_QUEUE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE_BIU" 
    before insert or update
    on CHARTER2_INV.v_patch_request_queue
    for each row
begin
    if inserting then 
        if :new.id is null then
            :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        end if;
    end if;
   :new.STATUS := upper(:new.STATUS) ;
    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;


end V_PATCH_REQUEST_QUEUE_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_PROCESS_STATUS_BUI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_PROCESS_STATUS_BUI" 
    before insert or update
    on charter2_inv.V_PROCESS_STATUS
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.STATUS_ID is null then
        :new.STATUS_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end V_PROCESS_STATUS_BUI;

/
ALTER TRIGGER "CHARTER2_INV"."V_PROCESS_STATUS_BUI" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_REGISTRY_SQLPATCH_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_REGISTRY_SQLPATCH_BIU" 
    before insert or update
    on charter2_inv.V_REGISTRY_SQLPATCH
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.ID is null then
        :new.ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end V_REGISTRY_SQLPATCH_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_REGISTRY_SQLPATCH_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_REQUEST_QUEUE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_REQUEST_QUEUE_BIU" 
    before insert or update
    on charter2_inv.V_REQUEST_QUEUE
    for each row
begin
    if inserting then 
        if :new.id is null then
            :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
        end if;
    end if;
   :new.STATUS := upper(:new.STATUS) ;
    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;


end V_REQUEST_QUEUE_BIU;
/
ALTER TRIGGER "CHARTER2_INV"."V_REQUEST_QUEUE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_REST_DEFINITIONS_AUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_REST_DEFINITIONS_AUD" 
    after update or delete on charter2_inv.v_rest_definitions
    for each row
declare
    t varchar2(128) := 'V_REST_DEFINITIONS';
    u varchar2(128) := nvl(sys_context('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.id is null and :new.id is not null) or
        (:old.id is not null and :new.id is null) or
        :old.id != :new.id then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            v_history_seq.nextval, t, 'ID', :old.id, null, 'U', sysdate, u, 'NUMBER', :old.id, :new.id);

    end if;
    if (:old.schema_enable is null and :new.schema_enable is not null) or
        (:old.schema_enable is not null and :new.schema_enable is null) or
        :old.schema_enable != :new.schema_enable then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SCHEMA_ENABLE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.schema_enable, :new.schema_enable);

    end if;
    if (:old.schema_enable_flag is null and :new.schema_enable_flag is not null) or
        (:old.schema_enable_flag is not null and :new.schema_enable_flag is null) or
        :old.schema_enable_flag != :new.schema_enable_flag then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'SCHEMA_ENABLE_FLAG', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.schema_enable_flag, :new.schema_enable_flag);

    end if;
    if (:old.module_name is null and :new.module_name is not null) or
        (:old.module_name is not null and :new.module_name is null) or
        :old.module_name != :new.module_name then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'MODULE_NAME', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.module_name, :new.module_name);

    end if;
    if (:old.uri_prefix is null and :new.uri_prefix is not null) or
        (:old.uri_prefix is not null and :new.uri_prefix is null) or
        :old.uri_prefix != :new.uri_prefix then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'URI_PREFIX', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.uri_prefix, :new.uri_prefix);

    end if;
    if (:old.uri_template is null and :new.uri_template is not null) or
        (:old.uri_template is not null and :new.uri_template is null) or
        :old.uri_template != :new.uri_template then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'URI_TEMPLATE', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.uri_template, :new.uri_template);

    end if;
    if (:old.method is null and :new.method is not null) or
        (:old.method is not null and :new.method is null) or
        :old.method != :new.method then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'METHOD', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.method, :new.method);

    end if;
    if (:old.rest_action is null and :new.rest_action is not null) or
        (:old.rest_action is not null and :new.rest_action is null) or
        :old.rest_action != :new.rest_action then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            v_history_seq.nextval, t, 'REST_ACTION', :old.id, null, 'U', sysdate, u, 'VARCHAR2', :old.rest_action, :new.rest_action);

    end if;
    if (:old.rest_code is null and :new.rest_code is not null) or
        (:old.rest_code is not null and :new.rest_code is null) or
        dbms_lob.getlength(:old.rest_code) != dbms_lob.getlength(:new.rest_code) or
        NVL(dbms_lob.compare(:old.rest_code,:new.rest_code),0) > 0 then
        insert into charter2_inv.v_history (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_clob, new_clob
        ) values (
            v_history_seq.nextval, t, 'REST_CODE', :old.id, null, 'U', sysdate, u, 'CLOB', :old.rest_code, :new.rest_code);

    end if;
elsif deleting then
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        v_history_seq.nextval, t, 'ID', :old.id, null, 'D', sysdate, u, 'NUMBER', :old.id, :new.id);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SCHEMA_ENABLE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.schema_enable, :new.schema_enable);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'SCHEMA_ENABLE_FLAG', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.schema_enable_flag, :new.schema_enable_flag);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'MODULE_NAME', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.module_name, :new.module_name);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'URI_PREFIX', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.uri_prefix, :new.uri_prefix);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'URI_TEMPLATE', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.uri_template, :new.uri_template);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'METHOD', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.method, :new.method);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        v_history_seq.nextval, t, 'REST_ACTION', :old.id, null, 'D', sysdate, u, 'VARCHAR2', :old.rest_action, :new.rest_action);
    insert into charter2_inv.v_history (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_clob, new_clob
    ) values (
        v_history_seq.nextval, t, 'REST_CODE', :old.id, null, 'D', sysdate, u, 'CLOB', :old.rest_code, :new.rest_code);

end if;
end;
/
ALTER TRIGGER "CHARTER2_INV"."V_REST_DEFINITIONS_AUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_REST_DEFINITIONS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_REST_DEFINITIONS_BIU" 
    before insert or update
    on charter2_inv.v_rest_definitions
    for each row
begin
    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_rest_definitions_biu;

/
ALTER TRIGGER "CHARTER2_INV"."V_REST_DEFINITIONS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_QUEUE_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_QUEUE_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_QUEUE
    for each row
begin
    if :new.SCHEDULE_ID is null then
        :new.SCHEDULE_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_QUEUE_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_QUEUE_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_QUEUE_DETAIL_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_QUEUE_DETAIL
    for each row
begin
    if :new.SCHEDULE_DETAIL_ID is null then
        :new.SCHEDULE_DETAIL_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_QUEUE_DETAIL_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_TASK_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_TASK
    for each row
begin
    if :new.TASK_ID is null then
        :new.TASK_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_QUEUE_BIU;


/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_TASK_PARMS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_TASK_PARMS
    for each row
begin
    if :new.PARM_ID is null then
        :new.PARM_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_TASK_PARMS_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_TASK_REPORT_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_TASK_REPORT
    for each row
begin
    if :new.REPORT_ID is null then
        :new.REPORT_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_TASK_REPORT_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SCHEDULE_TASK_STEP_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_STEP_BIU" 
    before insert or update
    on charter2_inv.V_SCHEDULE_TASK_STEP
    for each row
begin
    if :new.STEP_ID is null then
        :new.STEP_ID := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;

    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SCHEDULE_TASK_STEP_BIU;

/
ALTER TRIGGER "CHARTER2_INV"."V_SCHEDULE_TASK_STEP_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger V_SELF_SERVICE_STATUS_BIU
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."V_SELF_SERVICE_STATUS_BIU" 
    before insert or update
    on charter2_inv.v_self_service_status
    for each row
begin
    if :new.request_id is null then
        :new.request_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    
    if updating then
        :new.updated := sysdate ;
        :new.updated_by := coalesce( sys_context('APEX$SESSION','app_user') , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')  
                                    , sys_context('userenv','session_user') ) ;
    end if;

end V_SELF_SERVICE_STATUS_BIU;
/
ALTER TRIGGER "CHARTER2_INV"."V_SELF_SERVICE_STATUS_BIU" ENABLE;
--------------------------------------------------------
--  DDL for Trigger bi_MSSQL_TEAM_USERS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."bi_MSSQL_TEAM_USERS" 
  before insert on "MSSQL_TEAM_USERS"              
  for each row 
begin  
  if :new."ID" is null then
    select "MSSQL_TEAM_USERS_SEQ".nextval into :new."ID" from sys.dual;
  end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."bi_MSSQL_TEAM_USERS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger bi_ORACLE_TEAM_USERS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."bi_ORACLE_TEAM_USERS" 
  before insert on "ORACLE_TEAM_USERS"              
  for each row 
begin  
  if :new."ID" is null then
    select "ORACLE_TEAM_USERS_SEQ".nextval into :new."ID" from sys.dual;
  end if;
end;

/
ALTER TRIGGER "CHARTER2_INV"."bi_ORACLE_TEAM_USERS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger v_APP_SETTING_BUI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."v_APP_SETTING_BUI" 
    before insert or update
    on charter2_inv.V_APP_SETTINGS
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_APP_SETTING_BUI;
/
ALTER TRIGGER "CHARTER2_INV"."v_APP_SETTING_BUI" ENABLE;
--------------------------------------------------------
--  DDL for Trigger v_Patch_Lookup_BUI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."v_Patch_Lookup_BUI" 
    before insert or update
    on charter2_inv.V_PATCH_LOOKUP_TBL
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.id is null then
        :new.id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_Patch_Lookup_BUI;
/
ALTER TRIGGER "CHARTER2_INV"."v_Patch_Lookup_BUI" ENABLE;
--------------------------------------------------------
--  DDL for Trigger v_Patch_SCHEDULE_BUI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "CHARTER2_INV"."v_Patch_SCHEDULE_BUI" 
    before insert or update
    on charter2_inv.v_patch_schedule
    for each row
 Declare
  PRAGMA AUTONOMOUS_TRANSACTION;
begin

    if :new.PATCH_SCHED_id is null then
        :new.PATCH_SCHED_id := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
    end if;
    if inserting then

        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end v_Patch_SCHEDULE_BUI;
/
ALTER TRIGGER "CHARTER2_INV"."v_Patch_SCHEDULE_BUI" ENABLE;
--------------------------------------------------------
--  DDL for Procedure EBA_DEMO_CHART_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "CHARTER2_INV"."EBA_DEMO_CHART_DATA" 
as
  l_open   number;
  l_close  number;
  l_high   number;
  l_low    number;
  l_volume number;
begin
    delete from eba_demo_chart_projects;
    delete from eba_demo_chart_tasks;
    delete from eba_demo_chart_population;
    delete from eba_demo_chart_emp;
    delete from eba_demo_chart_dept;
    delete from eba_demo_chart_bball;
    delete from eba_demo_chart_orders;
    delete from eba_demo_chart_products;
    delete from eba_demo_chart_stats;
    delete from eba_demo_chart_stocks;
/* Charts Projects Table Data */
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (1,'Maintain Support Systems',to_date('01-11-2011','DD-MM-YYYY'), to_date('30-12-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (2,'Load Software',to_date('03-12-2011','DD-MM-YYYY'), to_date('10-12-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (3,'Email Integration',to_date('12-01-2012','DD-MM-YYYY'), to_date('17-02-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (4,'Documentation',to_date('19-11-2011','DD-MM-YYYY'), to_date('25-11-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (5,'Training',to_date('01-12-2011','DD-MM-YYYY'), to_date('08-12-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (6,'Bug Tracker',to_date('16-12-2011','DD-MM-YYYY'), to_date('19-01-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (7,'Migrate Old Systems',to_date('28-12-2011','DD-MM-YYYY'), to_date('22-02-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (8,'Software Projects Tracking',to_date('15-12-2012','DD-MM-YYYY'), to_date('20-01-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (9,'Public Website',to_date('06-12-2011','DD-MM-YYYY'), to_date('09-12-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (10,'Early Adopter Release',to_date('05-12-2011','DD-MM-YYYY'), to_date('06-02-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (11,'Environment Configuration',to_date('01-11-2011','DD-MM-YYYY'), to_date('22-11-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (12,'Customer Satisfaction Survey',to_date('18-12-2011','DD-MM-YYYY'), to_date('01-01-2011','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (13,'Convert Excel Spreadsheet',to_date('15-12-2011','DD-MM-YYYY'), to_date('15-03-2012','DD-MM-YYYY'));
    insert into eba_demo_chart_projects (ID,PROJECT,CREATED,CREATED_BY) values (14,'Upgrade Equipment',to_date('01-02-2012','DD-MM-YYYY'), to_date('30-05-2012','DD-MM-YYYY'));
    
/* Charts Tasks Table Data */
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (74,14,'Decommission servers',to_date('01-02-12','DD-MM-RR'),to_date('30-04-12','DD-MM-RR'),'Pending','Al Bines',0,500,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (75,6,'Measure effectiveness of improved QA',to_date('01-02-12','DD-MM-RR'),to_date('02-03-12','DD-MM-RR'),'Pending','Myra Sutcliff',0,1500,18);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (76,10,'Response to Customer Feedback',to_date('01-02-12','DD-MM-RR'),to_date('25-05-12','DD-MM-RR'),'Pending','Russ Saunders',0,6000,33);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (77,10,'User acceptance testing',to_date('16-02-12','DD-MM-RR'),to_date('20-05-12','DD-MM-RR'),'Pending','Russ Saunders',0,2500,33);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (78,10,'End-user Training',to_date('20-03-12','DD-MM-RR'),to_date('01-06-12','DD-MM-RR'),'Pending','Myra Sutcliff',0,2500,79);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (79,10,'Rollout sample applications',to_date('23-05-12','DD-MM-RR'),to_date('03-06-12','DD-MM-RR'),'Pending','Pam King',0,500,32);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (72,14,'Installation',to_date('03-02-12','DD-MM-RR'),to_date('04-03-12','DD-MM-RR'),'Pending','Mark Nile',0,1500,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (73,14,'Notify users',to_date('06-03-12','DD-MM-RR'),to_date('09-03-12','DD-MM-RR'),'Pending','Mark Nile',0,200,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (34,10,'Plan production release schedule',to_date('22-12-11','DD-MM-RR'),to_date('22-12-11','DD-MM-RR'),'Closed','Pam King',100,100,32);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (37,12,'Complete questionnaire',to_date('18-12-11','DD-MM-RR'),to_date('01-01-11','DD-MM-RR'),'On-Hold','Irene Jones',1200,800,38);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (59,11,'Select servers for Development, Test, Production',to_date('03-11-11','DD-MM-RR'),to_date('08-11-11','DD-MM-RR'),'Closed','James Cassidy',200,600,61);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (3,1,'HR Support Systems',to_date('01-11-11','DD-MM-RR'),to_date('12-03-12','DD-MM-RR'),'Closed','Al Bines',300,500,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (1,1,'HR software upgrades',to_date('01-11-11','DD-MM-RR'),to_date('27-02-12','DD-MM-RR'),'On-Hold','Pam King',8000,7000,3);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (2,1,'Arrange for vacation coverage',to_date('01-11-11','DD-MM-RR'),to_date('31-12-11','DD-MM-RR'),'On-Hold','Russ Sanders',9500,7000,3);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (4,3,'Complete plan',to_date('08-11-11','DD-MM-RR'),to_date('14-12-11','DD-MM-RR'),'Closed','Mark Nile',3000,1500,44);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (5,3,'Check software licenses',to_date('12-12-11','DD-MM-RR'),to_date('13-12-11','DD-MM-RR'),'Closed','Mark Nile',200,200,44);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (6,5,'Create training workspace',to_date('01-12-11','DD-MM-RR'),to_date('08-12-11','DD-MM-RR'),'Closed','James Cassidy',500,700,36);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (7,5,'Publish links to self-study courses',to_date('01-12-11','DD-MM-RR'),to_date('01-12-11','DD-MM-RR'),'Closed','John Watson',100,100,36);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (8,2,'Identify point solutions required',to_date('03-12-11','DD-MM-RR'),to_date('05-12-11','DD-MM-RR'),'Closed','John Watson',200,300,49);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (9,2,'Install in development',to_date('07-12-11','DD-MM-RR'),to_date('07-12-11','DD-MM-RR'),'Closed','John Watson',100,100,49);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (15,4,'Identify owners',to_date('19-11-11','DD-MM-RR'),to_date('22-11-11','DD-MM-RR'),'Closed','Hank Davis',250,300,17);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (16,4,'Initial Draft Review',to_date('23-11-11','DD-MM-RR'),to_date('23-11-11','DD-MM-RR'),'Closed','Hank Davis',100,100,17);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (17,4,'Monitor Review Comments',to_date('23-11-11','DD-MM-RR'),to_date('31-12-11','DD-MM-RR'),'Closed','Hank Davis',450,500,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (18,6,'Implement bug tracking software',to_date('15-11-11','DD-MM-RR'),to_date('15-11-11','DD-MM-RR'),'Closed','Myra Sutcliff',100,100,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (19,6,'Review automated testing tools',to_date('16-11-11','DD-MM-RR'),to_date('15-12-11','DD-MM-RR'),'Closed','Myra Sutcliff',2750,1500,18);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (20,7,'Identify pilot applications',to_date('10-11-11','DD-MM-RR'),to_date('15-11-11','DD-MM-RR'),'Closed','Mark Nile',300,500,53);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (21,7,'Migrate pilot applications to ',to_date('20-11-11','DD-MM-RR'),to_date('25-11-11','DD-MM-RR'),'Closed','Mark Nile',500,500,53);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (22,8,'Customize Software Projects software',to_date('15-12-12','DD-MM-RR'),to_date('20-01-12','DD-MM-RR'),'Open','Tom Suess',600,1000,28);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (23,7,'Post-migration review',to_date('01-12-11','DD-MM-RR'),to_date('01-12-11','DD-MM-RR'),'Closed','Mark Nile',100,100,53);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (24,7,'User acceptance testing',to_date('03-12-11','DD-MM-RR'),to_date('04-12-11','DD-MM-RR'),'Closed','Mark Nile',600,200,23);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (25,8,'Enter base data (Projects, Milestones, etc.)',to_date('10-12-11','DD-MM-RR'),to_date('11-12-11','DD-MM-RR'),'Closed','Tom Suess',200,200,28);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (26,8,'Load current tasks and enhancements',to_date('12-12-11','DD-MM-RR'),to_date('16-12-11','DD-MM-RR'),'Closed','Tom Suess',400,500,28);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (27,6,'Document quality assurance procedures',to_date('16-12-11','DD-MM-RR'),to_date('19-01-12','DD-MM-RR'),'On-Hold','Myra Sutcliff',3500,4000,18);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (28,8,'Conduct project kickoff meeting',to_date('05-12-11','DD-MM-RR'),to_date('05-12-11','DD-MM-RR'),'Closed','Pam King',100,100,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (29,9,'Determine host server',to_date('06-12-11','DD-MM-RR'),to_date('07-12-11','DD-MM-RR'),'Closed','Tiger Scott',200,200,40);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (30,9,'Check software licenses',to_date('07-12-11','DD-MM-RR'),to_date('07-12-11','DD-MM-RR'),'Closed','Tom Suess',100,100,40);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (31,10,'Identify pilot users',to_date('05-12-11','DD-MM-RR'),to_date('06-12-11','DD-MM-RR'),'Closed','Scott Spencer',200,200,33);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (32,10,'Software Deliverable',to_date('07-12-11','DD-MM-RR'),to_date('20-12-11','DD-MM-RR'),'Closed','Scott Spencer',400,500,33);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (33,10,'Early Adopter Release',to_date('21-12-11','DD-MM-RR'),to_date('21-12-11','DD-MM-RR'),'Closed','Pam King',100,100,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (35,11,'Determine midtier configuration(s)',to_date('02-11-11','DD-MM-RR'),to_date('02-11-11','DD-MM-RR'),'Closed','James Cassidy',100,100,61);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (36,5,'Manage Training Activities',to_date('28-11-11','DD-MM-RR'),to_date('03-02-12','DD-MM-RR'),'On-Hold','John Watson',1000,2000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (38,12,'Review feedback',to_date('09-01-12','DD-MM-RR'),to_date('15-01-12','DD-MM-RR'),'On-Hold','Irene Jones',200,400,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (39,12,'Plan rollout schedule',to_date('16-01-12','DD-MM-RR'),to_date('24-01-12','DD-MM-RR'),'On-Hold','Irene Jones',0,750,38);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (40,9,'Plan rollout schedule',to_date('10-12-11','DD-MM-RR'),to_date('02-01-12','DD-MM-RR'),'On-Hold','Al Bines',300,1000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (41,9,'Develop web pages',to_date('10-01-12','DD-MM-RR'),to_date('15-02-12','DD-MM-RR'),'On-Hold','Tiger Scott',800,2000,40);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (42,9,'Purchase additional software licenses, if needed',to_date('17-02-12','DD-MM-RR'),to_date('17-02-12','DD-MM-RR'),'On-Hold','Tom Suess',0,100,40);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (43,1,'Investigate new Virus Protection software',to_date('29-12-11','DD-MM-RR'),to_date('13-01-12','DD-MM-RR'),'Open','Pam King',1700,1500,3);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (44,3,'Get RFPs for new server',to_date('13-12-11','DD-MM-RR'),to_date('03-01-12','DD-MM-RR'),'Open','Mark Nile',2000,1000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (45,13,'Collect mission-critical spreadsheets',to_date('15-12-11','DD-MM-RR'),to_date('15-02-12','DD-MM-RR'),'Open','Pam King',2500,4000,46);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (46,13,'Create  applications from spreadsheets',to_date('15-12-11','DD-MM-RR'),to_date('30-05-12','DD-MM-RR'),'Open','Pam King',6000,10000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (47,13,'Lock spreadsheets',to_date('15-12-11','DD-MM-RR'),to_date('30-05-12','DD-MM-RR'),'Open','Pam King',1000,800,46);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (48,13,'Send links to previous spreadsheet owners',to_date('16-12-11','DD-MM-RR'),to_date('01-06-12','DD-MM-RR'),'Open','Pam King',1000,1500,46);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (49,2,'Customize solutions',to_date('08-12-11','DD-MM-RR'),to_date('01-03-12','DD-MM-RR'),'Open','John Watson',1500,4000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (50,2,'Train developers / users',to_date('10-01-12','DD-MM-RR'),to_date('25-03-12','DD-MM-RR'),'Pending','John Watson',0,8000,49);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (51,2,'Implement in Production',to_date('27-12-11','DD-MM-RR'),to_date('03-05-12','DD-MM-RR'),'Open','John Watson',200,1500,49);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (52,7,'Migrate applications',to_date('15-12-11','DD-MM-RR'),to_date('20-02-12','DD-MM-RR'),'Open','Mark Nile',1000,8000,53);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (53,7,'Plan migration schedule',to_date('22-12-11','DD-MM-RR'),to_date('03-03-12','DD-MM-RR'),'Open','Mark Nile',1500,6000,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (54,10,'Publish Feedback application',to_date('26-12-11','DD-MM-RR'),to_date('04-05-12','DD-MM-RR'),'Open','Pam King',300,12000,33);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (55,6,'Train developers on tracking bugs',to_date('20-01-12','DD-MM-RR'),to_date('10-03-12','DD-MM-RR'),'On-Hold','Myra Sutcliff',0,2000,18);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (56,7,'End-user Training',to_date('28-12-11','DD-MM-RR'),to_date('22-02-12','DD-MM-RR'),'Open','John Watson',0,2000,53);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (57,11,'Identify server requirements',to_date('01-11-11','DD-MM-RR'),to_date('02-11-11','DD-MM-RR'),'Closed','John Watson',100,200,61);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (58,11,'Specify security authentication scheme(s)',to_date('03-11-11','DD-MM-RR'),to_date('05-11-11','DD-MM-RR'),'Closed','John Watson',200,300,61);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (60,11,'Create pilot workspace',to_date('10-11-11','DD-MM-RR'),to_date('10-11-11','DD-MM-RR'),'Closed','John Watson',100,100,61);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (61,11,'Configure Workspace provisioning',to_date('10-11-11','DD-MM-RR'),to_date('10-11-11','DD-MM-RR'),'Closed','John Watson',200,100,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (62,11,'Run installation',to_date('11-11-11','DD-MM-RR'),to_date('11-11-11','DD-MM-RR'),'Closed','James Cassidy',100,100,57);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (64,14,'Obtain equipment specifications',to_date('03-01-12','DD-MM-RR'),to_date('06-01-12','DD-MM-RR'),'Pending','James Cassidy',0,500,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (65,3,'Purchase backup server',to_date('12-01-12','DD-MM-RR'),to_date('07-02-12','DD-MM-RR'),'Pending','Mark Nile',0,3000,44);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (66,14,'Identify integration points',to_date('08-01-12','DD-MM-RR'),to_date('28-01-12','DD-MM-RR'),'Pending','Mark Nile',0,2000,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (67,14,'Decommission machines',to_date('08-01-12','DD-MM-RR'),to_date('08-01-12','DD-MM-RR'),'Pending','Scott Spencer',0,100,null);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (68,14,'Map data usage',to_date('20-01-12','DD-MM-RR'),to_date('03-03-12','DD-MM-RR'),'Pending','Mark Nile',0,8000,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (69,14,'Purchase new machines',to_date('24-02-12','DD-MM-RR'),to_date('20-03-12','DD-MM-RR'),'Pending','John Watson',0,2500,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (70,14,'Import data',to_date('25-02-12','DD-MM-RR'),to_date('23-03-12','DD-MM-RR'),'Pending','John Watson',0,1000,67);
    insert into eba_demo_chart_tasks (ID,PROJECT,TASK_NAME,START_DATE,END_DATE,STATUS,ASSIGNED_TO,COST,BUDGET,PARENT_TASK) values (71,14,'Convert processes',to_date('02-02-12','DD-MM-RR'),to_date('01-04-12','DD-MM-RR'),'Pending','Pam King',0,3000,67);
update eba_demo_chart_tasks
   set start_date = start_date + (SYSDATE - TO_DATE('01012012','MMDDYYYY')),
       end_date = end_date + (SYSDATE - TO_DATE('01012012','MMDDYYYY'));
/* Charts Population Table Data */
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (51,'Wyoming','WY',563626,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (9,'Georgia','GA',9687653,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (17,'Tennessee','TN',6346105,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (18,'Missouri','MO',5988927,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (19,'Maryland','MD',5773552,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (21,'Minnesota','MN',5303925,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (36,'New Mexico','NM',2059179,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (1,'California','CA',37253956,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (2,'Texas','TX',25145561,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (3,'New York','NY',19378102,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (4,'Florida','FL',18801310,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (5,'Illinois','IL',12830310,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (6,'Pennsylvania','PA',12702379,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (7,'Ohio','OH',11536504,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (8,'Michigan','MI',9883640,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (10,'North Carolina','NC',9535483,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (11,'New Jersey','NJ',8791894,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (12,'Virginia','VA',8001024,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (13,'Washington','WA',6724540,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (14,'Arizona','AZ',6392017,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (15,'Massachusetts','MA',6547629,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (16,'Indiana','IN',6483802,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (20,'Wisconsin','WI',5686986,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (22,'Colorado','CO',5029196,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (23,'Alabama','AL',4779736,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (24,'South Carolina','SC',4625364,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (25,'Louisiana','LA',4533372,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (26,'Kentucky','KY',4339367,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (27,'Oregon','OR',3831074,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (28,'Oklahoma','OK',3751351,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (29,'Connecticut','CT',3574097,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (30,'Iowa','IA',3046355,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (31,'Mississippi','MS',2967297,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (32,'Arkansas','AR',2915918,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (33,'Kansas','KS',2853118,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (34,'Utah','UT',2763885,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (35,'Nevada','NV',2700551,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (37,'West Virginia','WV',1852994,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (38,'Nebraska','NE',1826341,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (39,'Idaho','ID',1567582,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (40,'Maine','ME',1328361,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (41,'New Hampshire','NH',1316470,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (42,'Hawaii','HI',1360301,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (43,'Rhode Island','RI',1052567,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (44,'Montana','MT',989415,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (45,'Delaware','DE',897934,3);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (46,'South Dakota','SD',814180,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (47,'Alaska','AK',710231,4);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (48,'North Dakota','ND',672591,2);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (49,'Vermont','VT',625741,1);
    insert into eba_demo_chart_population (ID,STATE_NAME,STATE_CODE,POPULATION,REGION) values (50,'District of Columbia','DC',601723,3);
/* Charts Dept Table */
    insert into eba_demo_chart_dept (DEPTNO,DNAME,LOC) values (10,'ACCOUNTING','NEW YORK');
    insert into eba_demo_chart_dept (DEPTNO,DNAME,LOC) values (20,'RESEARCH','DALLAS');
    insert into eba_demo_chart_dept (DEPTNO,DNAME,LOC) values (30,'SALES','CHICAGO');
    insert into eba_demo_chart_dept (DEPTNO,DNAME,LOC) values (40,'OPERATIONS','BOSTON');
/* Charts Emp Table */
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7839,'KING','PRESIDENT',null,to_date('17-11-81','DD-MM-RR'),5000,null,10);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7698,'BLAKE','MANAGER',7839,to_date('01-05-81','DD-MM-RR'),2850,null,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7782,'CLARK','MANAGER',7839,to_date('09-06-81','DD-MM-RR'),2450,null,10);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7566,'JONES','MANAGER',7839,to_date('02-04-81','DD-MM-RR'),2975,null,20);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7788,'SCOTT','ANALYST',7566,to_date('09-12-82','DD-MM-RR'),3000,null,20);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7902,'FORD','ANALYST',7566,to_date('03-12-81','DD-MM-RR'),3000,null,20);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7369,'SMITH','CLERK',7902,to_date('17-12-80','DD-MM-RR'),800,null,20);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7499,'ALLEN','SALESMAN',7698,to_date('20-02-81','DD-MM-RR'),1600,300,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7521,'WARD','SALESMAN',7698,to_date('22-02-81','DD-MM-RR'),1250,500,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7654,'MARTIN','SALESMAN',7698,to_date('28-09-81','DD-MM-RR'),1250,1400,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7844,'TURNER','SALESMAN',7698,to_date('08-09-81','DD-MM-RR'),1500,0,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7876,'ADAMS','CLERK',7788,to_date('12-01-83','DD-MM-RR'),1100,null,20);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7900,'JAMES','CLERK',7698,to_date('03-12-81','DD-MM-RR'),950,null,30);
    insert into eba_demo_chart_emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7934,'MILLER','CLERK',7782,to_date('23-01-82','DD-MM-RR'),1300,null,10);
/* Charts BBall Table */
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (1,'Boston','Celtics','East',17);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (2,'Los Angeles','Lakers','West',16);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (3,'Chicago','Bulls','East',6);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (4,'San Antonio','Spurs','West',5);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (5,'Golden Gate','Warriors','West',4);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (6,'Philadelphia','76ers','East',3);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (7,'Detroit','Pistons','East',3);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (8,'Miami','Heat','East',3);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (9,'New York','Knicks','East',2);
    insert into eba_demo_chart_bball (ID,CITY,TEAM,CONFERENCE,WINS) values (10,'Houston','Rockets','West',2);
/* Charts Products Tables */
    insert into eba_demo_chart_products(product_id, product_name, product_description, list_price) values(1,'Apples','Red pink lady apples',1.20);
    insert into eba_demo_chart_products(product_id, product_name, product_description, list_price) values(2,'Bananas','Bunches of yellow bananas',3.80);
    insert into eba_demo_chart_products(product_id, product_name, product_description, list_price) values(3,'Cantaloupe','Coral coloured melon',2.95);
    insert into eba_demo_chart_products(product_id, product_name, product_description, list_price) values(4,'Dates','Dried dates',3.30);
    insert into eba_demo_chart_products(product_id, product_name, product_description, list_price) values(5,'Grapes','Punnet of Red Seedless Grapes',2.05);
/* Charts Orders Table */
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (1,1,42,'Store A',to_date('08-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (2,2,55,'Store A',to_date('09-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (3,3,36,'Store A',to_date('11-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (4,4,22,'Store A',to_date('12-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (5,5,42,'Store A',to_date('14-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (6,1,32,'Acme Store',to_date('03-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (7,2,39,'Acme Store',to_date('04-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (8,3,36,'Acme Store',to_date('07-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (9,4,27,'Acme Store',to_date('13-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (10,5,50,'Acme Store',to_date('14-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (11,1,34,'Shop C',to_date('08-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (12,2,30,'Shop C',to_date('09-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (13,3,50,'Shop C',to_date('11-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (14,4,46,'Shop C',to_date('12-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (15,5,36,'Shop C',to_date('14-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (16,1,74,'Deli',to_date('02-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (17,2,42,'Deli',to_date('04-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (18,3,70,'Deli',to_date('06-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (19,4,46,'Deli',to_date('08-04-16','DD-MM-RR'));
    insert into eba_demo_chart_orders(order_id,product_id, quantity,customer, sales_date) values (20,5,22,'Deli',to_date('10-04-16','DD-MM-RR'));
/* Charts Stats Table */
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('AU','Australia',0,0,0);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('BE','Belgium',3.5,3.7,7.8);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('CA','Canada',2.3,2,4.7);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('CZ','Czech Republic',1.8,6,8.3);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('DK','Denmark',0,0,0);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('FI','Finland',1.8,6.8,9);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('DE','Germany',2.8,3.2,6.9);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('GR','Greece',3.4,4.3,9.2);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('HU','Hungary',1.4,6.4,8.3);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('IT','Italy',2.2,6.8,9);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('JA','Japan',3.2,3.1,6.3);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('KO','Korea',1.2,0.9,2.1);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('LU','Luxembourg',2.8,2.4,5.9);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('MX','Mexico',0,0,0);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('NZ','New Zealand',0,0,0);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('PO','Poland',3,2.6,6.8);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('SK','Slovakia',0.9,2.5,4.3);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('ES','Spain',1.4,6.8,9.2);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('SE','Sweden',2.5,3.6,6.2);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('CH','Switzerland',2.7,2.7,5.9);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('TR','Turkey',1.1,1.3,2.4);
    insert into eba_demo_chart_stats (name,country,employee,employer,total) values ('US','United States',1.8,3,5.2);
/* Charts Stocks Table Data */
    l_open  := 200;
    l_close := dbms_random.value*5+200;
    insert into eba_demo_chart_stocks (ID, STOCK_CODE, STOCK_NAME, PRICING_DATE, PRICING_TIMESTAMP, PRICING_TIMESTAMP_TZ, PRICING_TIMESTAMP_LTZ,OPENING_VAL,HIGH,LOW,CLOSING_VAL,VOLUME) values (1,'METR','Metro Trading',SYSDATE - 500, SYSTIMESTAMP - 500,CURRENT_TIMESTAMP -500,LOCALTIMESTAMP -500,200,202,199,l_close,1000000);
    for i in 1..500 loop  
        l_open   := l_close;
        l_close  := l_open + dbms_random.value * 5 * power(-1, round(dbms_random.value));
        l_high   := greatest(l_open, l_close) + dbms_random.value * 2;
        l_low    := least(l_open, l_close) - dbms_random.value * 2;
        l_volume := 1000000 + dbms_random.value * 10000000;
        
        insert into eba_demo_chart_stocks (ID, STOCK_CODE, STOCK_NAME, PRICING_DATE, PRICING_TIMESTAMP, PRICING_TIMESTAMP_TZ, PRICING_TIMESTAMP_LTZ,OPENING_VAL,HIGH,LOW,CLOSING_VAL,VOLUME) values (i+1,'METR','Metro Trading', SYSDATE-500+i, SYSTIMESTAMP-500+i,CURRENT_TIMESTAMP-500+i,LOCALTIMESTAMP-500+i,l_open,l_high,l_low,l_close,l_volume);
    end loop;
    
/* Box Plot Grades Table Data */
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (1,'English',93,53,71);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (2,'Physics',61,55,65);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (3,'English',70,50,90);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (4,'Math',50,70,45);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (5,'English',30,67,90);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (6,'English',85,56,67);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (7,'Math',70,45,59);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (8,'Math',62,53,66);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (9,'English',77,50,60);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (10,'English',90,54,69);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (11,'Physics',60,40,64);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (12,'English',88,28,67);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (13,'Math',71,56,45);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (14,'Math',63,58,64);
    insert into eba_demo_chart_grades (ID,COURSE,SCHOOLA,SCHOOLB,SCHOOLC) values (15,'English',59,54,65);
    
/* Box Plot Samples Table Data */
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.64,6.48,9.36,6.48,9.36);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.47,9.81,16.31,9.81,16.31);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.03,8.95,4.02,8.95,4.02);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.44,12.79,8.4,12.79,8.4);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.07,16.17,16.42,16.17,16.42);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.11,16.54,15.81,16.54,15.81);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.23,12.93,3.76,12.93,3.76);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.55,9.23,7.17,9.23,7.17);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.17,18.93,12.78,18.93,12.78);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.84,14.94,13.57,14.94,13.57);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11,0.21,16.99,0.21,16.99);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.01,12.13,0.72,12.13,0.72);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.12,16.18,5.64,16.18,5.64);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.24,12.78,16.16,12.78,16.16);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.32,12.29,9.98,12.29,9.98);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.55,10.85,-1.45,10.85,-1.45);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.37,16.72,null,16.72,13.97);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.49,13.36,null,13.36,13.37);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.99,6.99,null,6.99,3.39);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.66,15.18,null,15.18,9.12);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.78,10.86,null,10.86,-2.9);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.31,13.78,null,13.78,10.52);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.71,8.31,null,8.31,15.04);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.86,6.82,null,6.82,7.24);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.42,6.75,null,6.75,13.87);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.57,10.13,null,10.13,11.42);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.92,17.08,null,17.08,12.79);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.8,14.56,null,14.56,17.91);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.31,18.52,null,18.52,12.5);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.64,11.66,null,11.66,7.41);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.06,18.01,null,18.01,21.19);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.65,13.39,null,13.39,9.69);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.5,14.9,null,14.9,6.79);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.3,20.97,null,20.97,15.16);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (7.87,11,null,11,3.19);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.5,3.85,null,3.85,15.05);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.54,4.18,null,4.18,13.83);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.24,15.34,null,15.34,7.2);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.96,12.6,null,12.6,7);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.5,18.48,null,18.48,8);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.51,17.22,null,17.22,9);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.29,15.53,null,15.53,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.63,10.44,null,10.44,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.09,10.31,null,10.31,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.36,5.24,null,5.24,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.21,18.02,null,18.02,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.46,6.82,null,6.82,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.09,9.07,null,9.07,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.68,12.86,null,12.86,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.51,10.73,null,10.73,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.78,17.69,null,17.69,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.27,12.12,null,12.12,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.61,12.21,null,12.21,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.59,5.66,null,5.66,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.61,9.3,null,9.3,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.6,13.49,null,13.49,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.2,13.67,null,13.67,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.31,9.06,null,9.06,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.47,16.6,null,16.6,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.71,14.83,null,14.83,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (7.98,12.6,null,12.6,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.25,15.25,null,15.25,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.19,9.22,null,9.22,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.97,12.11,null,12.11,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.86,7.43,null,7.43,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (12.07,12.19,null,12.19,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.09,16.49,null,16.49,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.53,9.41,null,9.41,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.74,10.49,null,10.49,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.92,18.6,null,18.6,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.65,16.65,null,16.65,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.31,11.17,null,11.17,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.2,14.49,null,14.49,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.6,16.34,null,16.34,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (12.55,10.31,null,10.31,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.95,11.37,null,11.37,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.9,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.97,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.26,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.32,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.74,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.06,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (8.99,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.74,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.59,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.55,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.95,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.8,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.69,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.75,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.14,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.06,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.69,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.11,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (11.15,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.73,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.6,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (10.33,null,null,null,null);
    insert into eba_demo_chart_samples (SAMPLE1,SAMPLE2,SAMPLE3,SAMPLE4,SAMPLE5) values (9.63,null,null,null,null);
    
/* Box Plot Sample Names Table Data */
    insert into eba_demo_chart_sample_names (ID,SAMPLE_NAME,SAMPLE_DATE) values (1,'Sample 1',to_date('20-07-17','DD-MM-RR'));
    insert into eba_demo_chart_sample_names (ID,SAMPLE_NAME,SAMPLE_DATE) values (2,'Sample 2',to_date('27-07-17','DD-MM-RR'));
    insert into eba_demo_chart_sample_names (ID,SAMPLE_NAME,SAMPLE_DATE) values (3,'Sample 3',to_date('30-07-17','DD-MM-RR'));
    insert into eba_demo_chart_sample_names (ID,SAMPLE_NAME,SAMPLE_DATE) values (4,'Sample 4',to_date('03-08-17','DD-MM-RR'));
    insert into eba_demo_chart_sample_names (ID,SAMPLE_NAME,SAMPLE_DATE) values (5,'Sample 5',to_date('10-08-17','DD-MM-RR'));
    
/* Box Plot Sample Data Table Data */
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (321,1,9.64);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (322,2,6.48);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (323,3,9.36);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (324,4,6.48);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (325,5,9.36);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (326,1,9.47);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (327,2,9.81);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (328,3,16.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (329,4,9.81);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (330,5,16.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (331,1,9.03);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (332,2,8.95);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (333,3,4.02);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (334,4,8.95);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (335,5,4.02);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (336,1,9.44);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (337,2,12.79);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (338,3,8.4);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (339,4,12.79);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (340,5,8.4);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (341,1,11.07);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (342,2,16.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (343,3,16.42);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (344,4,16.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (345,5,16.42);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (346,1,9.11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (347,2,16.54);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (348,3,15.81);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (349,4,16.54);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (350,5,15.81);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (351,1,9.23);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (352,2,12.93);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (353,3,3.76);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (354,4,12.93);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (355,5,3.76);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (356,1,9.55);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (357,2,9.23);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (358,3,7.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (359,4,9.23);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (360,5,7.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (361,1,11.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (362,2,18.93);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (363,3,12.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (364,4,18.93);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (365,5,12.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (366,1,9.84);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (367,2,14.94);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (368,3,13.57);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (369,4,14.94);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (370,5,13.57);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (371,1,11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (372,2,0.21);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (373,3,16.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (374,4,0.21);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (375,5,16.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (376,1,10.01);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (377,2,12.13);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (378,3,0.72);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (379,4,12.13);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (380,5,0.72);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (381,1,10.12);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (382,2,16.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (383,3,5.64);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (384,4,16.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (385,5,5.64);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (386,1,9.24);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (387,2,12.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (388,3,16.16);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (389,4,12.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (390,5,16.16);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (391,1,11.32);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (392,2,12.29);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (393,3,9.98);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (394,4,12.29);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (395,5,9.98);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (396,1,9.55);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (397,2,10.85);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (398,3,-1.45);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (399,4,10.85);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (400,5,-1.45);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (401,1,10.37);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (402,2,16.72);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (403,4,16.72);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (404,5,13.97);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (405,1,9.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (406,2,13.36);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (407,4,13.36);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (408,5,13.37);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (409,1,8.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (410,2,6.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (411,4,6.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (412,5,3.39);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (413,1,9.66);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (414,2,15.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (415,4,15.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (416,5,9.12);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (417,1,10.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (418,2,10.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (419,4,10.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (420,5,-2.9);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (421,1,11.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (422,2,13.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (423,4,13.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (424,5,10.52);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (425,1,9.71);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (426,2,8.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (427,4,8.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (428,5,15.04);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (429,1,9.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (430,2,6.82);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (431,4,6.82);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (432,5,7.24);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (433,1,10.42);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (434,2,6.75);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (435,4,6.75);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (436,5,13.87);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (437,1,9.57);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (438,2,10.13);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (439,4,10.13);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (440,5,11.42);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (441,1,8.92);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (442,2,17.08);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (443,4,17.08);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (444,5,12.79);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (445,1,10.8);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (446,2,14.56);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (447,4,14.56);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (448,5,17.91);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (449,1,10.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (450,2,18.52);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (451,4,18.52);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (452,5,12.5);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (453,1,8.64);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (454,2,11.66);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (455,4,11.66);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (456,5,7.41);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (457,1,11.06);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (458,2,18.01);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (459,4,18.01);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (460,5,21.19);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (461,1,8.65);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (462,2,13.39);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (463,4,13.39);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (464,5,9.69);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (465,1,10.5);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (466,2,14.9);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (467,4,14.9);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (468,5,6.79);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (469,1,8.3);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (470,2,20.97);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (471,4,20.97);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (472,5,15.16);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (473,1,7.87);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (474,2,11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (475,4,11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (476,5,3.19);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (477,1,9.5);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (478,2,3.85);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (479,4,3.85);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (480,5,15.05);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (481,1,9.54);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (482,2,4.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (483,4,4.18);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (484,5,13.83);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (485,1,11.24);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (486,2,15.34);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (487,4,15.34);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (488,5,7.2);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (489,1,8.96);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (490,2,12.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (491,4,12.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (492,5,7);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (493,1,9.5);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (494,2,18.48);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (495,4,18.48);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (496,5,8);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (497,1,9.51);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (498,2,17.22);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (499,4,17.22);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (500,5,9);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (501,1,9.29);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (502,2,15.53);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (503,4,15.53);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (504,1,9.63);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (505,2,10.44);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (506,4,10.44);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (507,1,9.09);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (508,2,10.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (509,4,10.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (510,1,10.36);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (511,2,5.24);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (512,4,5.24);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (513,1,9.21);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (514,2,18.02);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (515,4,18.02);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (516,1,10.46);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (517,2,6.82);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (518,4,6.82);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (519,1,9.09);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (520,2,9.07);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (521,4,9.07);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (522,1,9.68);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (523,2,12.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (524,4,12.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (525,1,10.51);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (526,2,10.73);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (527,4,10.73);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (528,1,10.78);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (529,2,17.69);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (530,4,17.69);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (531,1,10.27);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (532,2,12.12);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (533,4,12.12);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (534,1,10.61);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (535,2,12.21);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (536,4,12.21);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (537,1,9.59);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (538,2,5.66);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (539,4,5.66);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (540,1,9.61);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (541,2,9.3);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (542,4,9.3);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (543,1,10.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (544,2,13.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (545,4,13.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (546,1,10.2);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (547,2,13.67);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (548,4,13.67);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (549,1,9.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (550,2,9.06);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (551,4,9.06);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (552,1,8.47);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (553,2,16.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (554,4,16.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (555,1,10.71);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (556,2,14.83);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (557,4,14.83);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (558,1,7.98);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (559,2,12.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (560,4,12.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (561,1,11.25);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (562,2,15.25);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (563,4,15.25);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (564,1,8.19);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (565,2,9.22);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (566,4,9.22);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (567,1,9.97);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (568,2,12.11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (569,4,12.11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (570,1,9.86);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (571,2,7.43);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (572,4,7.43);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (573,1,12.07);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (574,2,12.19);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (575,4,12.19);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (576,1,11.09);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (577,2,16.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (578,4,16.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (579,1,10.53);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (580,2,9.41);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (581,4,9.41);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (582,1,9.74);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (583,2,10.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (584,4,10.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (585,1,10.92);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (586,2,18.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (587,4,18.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (588,1,8.65);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (589,2,16.65);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (590,4,16.65);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (591,1,9.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (592,2,11.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (593,4,11.17);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (594,1,11.2);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (595,2,14.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (596,4,14.49);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (597,1,8.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (598,2,16.34);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (599,4,16.34);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (600,1,12.55);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (601,2,10.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (602,4,10.31);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (603,1,11.95);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (604,2,11.37);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (605,4,11.37);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (606,1,10.9);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (607,1,10.97);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (608,1,9.26);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (609,1,10.32);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (610,1,8.74);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (611,1,11.06);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (612,1,8.99);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (613,1,9.74);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (614,1,9.59);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (615,1,10.55);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (616,1,10.95);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (617,1,10.8);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (618,1,9.69);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (619,1,11.75);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (620,1,10);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (621,1,9.14);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (622,1,10.06);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (623,1,9.69);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (624,1,10.11);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (625,1,11.15);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (626,1,10.73);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (627,1,10.6);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (628,1,10.33);
    insert into eba_demo_chart_sample_data (ID,SAMPLE_ID,RESPONSE) values (629,1,9.63);    
end;

/
--------------------------------------------------------
--  DDL for Procedure LOGGER_CONFIGURE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "CHARTER2_INV"."LOGGER_CONFIGURE" 
is
  -- Note: The license is defined in the package specification of the logger package
	--
	l_rac_lt_11_2 varchar2(50) := 'FALSE';  -- is this a RAC instance less than 11.2, no GAC support

  l_apex varchar2(50) := 'FALSE';
  tbl_not_exist exception;
  pls_pkg_not_exist exception;

  l_text_data_length user_tab_columns.data_length%type;
  l_large_text_column varchar2(50);

  l_sql varchar2(32767);
  l_variables varchar2(1000) := ' ';
  l_dummy number;
  l_flashback varchar2(50) := 'FALSE';
  l_utl_lms varchar2(5) := 'FALSE';

  pragma exception_init(tbl_not_exist, -942);
  pragma exception_init(pls_pkg_not_exist, -06550);

	l_version constant number  := dbms_db_version.version + (dbms_db_version.release / 10);
  l_pref_value logger_prefs.pref_Value%type;
  l_logger_debug boolean;

	l_pref_type_logger logger_prefs.pref_type%type;
begin

  -- Check to see if we are in a RAC Database, 11.1 or lower.
  --
  -- Tyler to check if this works
  if dbms_utility.is_cluster_database then
    l_rac_lt_11_2 := 'TRUE';
  else
    l_rac_lt_11_2 := 'FALSE';
  end if;

  if l_version >= 11.2 then
    l_rac_lt_11_2 := 'FALSE';
  end if;

  l_variables := 'RAC_LT_11_2:'||l_rac_lt_11_2||',';


  -- Check lenth of TEXT size (this is for future 12c 32767 integration
  -- In support of Issue #17 and future proofing for #30
  select data_length
  into l_text_data_length
  from user_tab_columns
  where 1=1
    and table_name = 'LOGGER_LOGS'
    and column_name = 'TEXT';

  if l_text_data_length > 4000 then
    l_large_text_column := 'TRUE';
  else
    l_large_text_column := 'FALSE';
  end if;
  l_variables := l_variables||'LARGE_TEXT_COLUMN:'||l_large_text_column||',';


  -- Is APEX installed ?
  --
  begin
    execute immediate 'select 1 from apex_application_items where rownum = 1' into l_dummy;

    l_apex := 'TRUE';
  exception
    when tbl_not_exist then
      l_apex := 'FALSE';
    when no_data_found then
      l_apex := 'TRUE';
  end;

  l_variables := l_variables||'APEX:'||l_apex||',';


  -- Can we call dbms_flashback to get the currect System Commit Number?
  --
  begin
    execute immediate 'begin :d := dbms_flashback.get_system_change_number; end; ' using out l_dummy;

    l_flashback := 'TRUE';
  exception when pls_pkg_not_exist then
    l_flashback := 'FALSE';
  end;

  l_variables := l_variables||'FLASHBACK_ENABLED:'||l_flashback||',';


  -- #64: Support to run Logger in debug mode

	-- #127
	-- Since this procedure will recompile Logger, if it directly references a variable in Logger
	-- It will lock itself while trying to recompile
	-- Work around is to pre-store the variable using execute immediate
	execute immediate 'begin :x := logger.g_pref_type_logger; end;' using out l_pref_type_logger;

  select lp.pref_value
  into l_pref_value
  from logger_prefs lp
  where 1=1
		and lp.pref_type = upper(l_pref_type_logger)
    and lp.pref_name = 'LOGGER_DEBUG';
  l_variables := l_variables || 'LOGGER_DEBUG:' || l_pref_value||',';

  l_logger_debug := false;
  if upper(l_pref_value) = 'TRUE' then
    l_logger_debug := true;
  end if;


  -- #46
  -- Handle plugin settings
-- Set for each plugin type
  for x in (
    select
      'LOGGER_' ||
      regexp_replace(lp.pref_name, '^PLUGIN_FN_', 'PLUGIN_') || ':' ||
      decode(nvl(upper(lp.pref_value), 'NONE'), 'NONE', 'FALSE', 'TRUE') ||
      ',' var
    from logger_prefs lp
    where 1=1
			and lp.pref_type = l_pref_type_logger
      and lp.pref_name like 'PLUGIN_FN%'
  ) loop
    l_variables := l_variables || x.var;
  end loop;


  l_variables := rtrim(l_variables,',');
  if l_logger_debug then
    dbms_output.put_line('l_variables: ' || l_variables);
  end if;


	-- Recompile Logger
 	l_sql := q'!alter package logger compile body PLSQL_CCFLAGS='%VARIABLES%' reuse settings!';
	l_sql := replace(l_sql, '%VARIABLES%', l_variables);
	execute immediate l_sql;

  -- #31: Dropped trigger
	-- l_sql := q'[alter trigger BI_LOGGER_LOGS compile PLSQL_CCFLAGS=']'||l_variables||q'[' reuse settings]';
	-- execute immediate l_sql;

  -- -- TODO mdsouza: 3.1.1 org l_sql := q'!alter trigger biu_logger_prefs compile PLSQL_CCFLAGS='CURRENTLY_INSTALLING:FALSE'!';
  l_sql := q'!alter trigger biu_logger_prefs compile!';
  execute immediate l_sql;

  -- just in case this is a re-install / upgrade, the global contexts will persist so reset them
  logger.null_global_contexts;

end logger_configure;

/
--------------------------------------------------------
--  DDL for Procedure SETUP_CHARTER_ACCTS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "CHARTER2_INV"."SETUP_CHARTER_ACCTS" (
 p_action   IN VARCHAR2 DEFAULT 'BOTH'
) as 
 mssql_id number;
 oracle_id number;
 l_person_id number;
 l_action varchar2(255) := p_action; -- CLEAN,INSERT, BOTH
Begin 

SELECT  max(role_id) into  oracle_id FROM v_app_role where   app_role = 'ORACLE_DBA';
SELECT  max(role_id) into  mssql_id FROM v_app_role where   app_role = 'MSSQL_DBA';

if l_action in ('CLEAN','BOTH') then

for c1 in (
select
   p.person_id,
    p.username,
    p.display_name
from
(
 SELECT
    id,
    contact display_name,
    trim(upper(nvl(l_twc_vid,l_chtr_pid))) username  ,
    replace(contact,' ','.')||'@charter.com' email ,
    oracle_id dba_role_id
FROM
    oracle_team_users
union   
SELECT
    id,
    contact display_name,
    trim(upper(nvl(l_chtr_pid,l_twc_vid))) username  ,
    replace(contact,' ','.')||'@charter.com' email ,
    oracle_id dba_role_id
FROM
    oracle_team_users
union     
    SELECT
    id,
    username display_name,
    trim(upper(user_id)) username,
    replace(username,' ','.')||'@charter.com' email,
    mssql_id dba_role_id
FROM
    mssql_team_users
) l
,v_app_person p
where
upper(p.username) = l.username
) loop

 dbms_output.put_line('Remove :'||c1.username||' - '||c1.display_name);
 delete from  v_app_person_roles r
 where 
  r.person_id = c1.person_id;

 delete from  v_app_person r
 where 
  r.person_id = c1.person_id;
  
  
end loop;

end if; -- CLEAN

if l_action in ('INSERT','BOTH') then

for c1 in (
SELECT
    id,
    contact display_name,
    upper(trim(nvl(l_chtr_pid,l_twc_vid))) username  ,
    replace(contact,' ','.')||'@charter.com' email ,
    replace(contact,' ','.')||'@charter.com' email2 ,
    oracle_id dba_role_id
FROM
    oracle_team_users
union all    
    SELECT
    id,
    username display_name,
    upper(trim(user_id)) username,
    email,
    replace(username,' ','.')||'@charter.com' email2,
    mssql_id dba_role_id
FROM
    mssql_team_users
) loop
 dbms_output.put_line('Creating :'||c1.username||' - '||c1.display_name);

INSERT INTO v_app_person (    
    app_id,
    username,
    app_role,
    app_admin,
    display_name,
    email_addr
) VALUES (
    '110',
    c1.username,
    'DBA',
    'N',
    c1.display_name,
    c1.email
) returning person_id into l_person_id;

--Add person to roles table    
INSERT INTO v_app_person_roles (
    person_id,
    role_id
) VALUES (
    l_person_id,
    c1.dba_role_id
);

end loop;
end if;

end;

/
--------------------------------------------------------
--  DDL for Package BATCH_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."BATCH_MGR" AS 

  /* TODO enter package declarations (types,exceptions,methods etc) here */
    PROCEDURE check_work_queue (
        p_queue    IN VARCHAR2 DEFAULT NULL,
        p_action   IN VARCHAR2 DEFAULT NULL
    );

    PROCEDURE process_files (
        p_interface   IN VARCHAR2 DEFAULT NULL,
        p_action      IN VARCHAR2 DEFAULT NULL
    );

    PROCEDURE process_host_inv_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    );

    PROCEDURE process_host_inv_json;

    PROCEDURE process_db_inv_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    );
    
    PROCEDURE process_db_inv_json;
    
    PROCEDURE process_db_chklst_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) ;

    PROCEDURE process_db_chklst_json;    
    
    PROCEDURE process_status_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    );    
    
    PROCEDURE process_status_json ;
END batch_mgr;

/
--------------------------------------------------------
--  DDL for Package CLUSTER_HOST_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."CLUSTER_HOST_REST_UTL" as
/*
    -- Purpose: Holding ORDS REST Call API supporting objects for cluster, host  application details.
    -- Created On: 12 FEB 2019     
*/

    -- cluster member tbl insert
    procedure cluster_member_ins  (
        p_id                           out number ,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null,
        p_host_code                    out varchar2 ,
        p_env_source                   in varchar2
    );
    
    -- cluster member tbl update
    procedure cluster_member_upd  (
        p_id                           in number,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null
    );
    
    -- host inventory update
    procedure host_inv_upd (
        p_id                           in number,
        p_host_name                    in varchar2 default null,
        p_network_type                 in varchar2 default null,
        p_core_count                   in number default null,
        p_processor_config_speed       in varchar2 default null,
        p_server_model                 in varchar2 default null,
        p_hardware_vendor              in varchar2 default null,
        p_os_type_version              in varchar2 default null,
        p_processor_bit                in varchar2 default null,
        p_server_creation_date         in varchar2 default null,
        p_phy_virt                     in varchar2 default null,
        p_dc_location                  in varchar2 default null,
        p_global_zone_solaris          in varchar2 default null,
        p_phy_memory                   in varchar2 default null,
        p_server_monitoring_tool       in varchar2 default null,
        p_clustered	                   in varchar2 default null,
        p_os_type	                   in varchar2 default null,
        p_decommisioned                in varchar2 default null,
        p_ip_address                   in varchar2 default null,
        p_scan_ip_address              in varchar2 default null,
        p_vip_ip_address               in varchar2 default null    
    );
    
    -- host inventory insert.
    procedure host_inv_ins (
      p_host_name in varchar2,
      p_network_type in varchar2,
      p_core_count in number,
      p_processor_config_speed in varchar2,
      p_server_model in varchar2,
      p_hardware_vendor in varchar2,
      p_os_type_version in varchar2,
      p_processor_bit in varchar2,
      p_server_creation_date in varchar2,
      p_phy_virt in varchar2,
      p_dc_location in varchar2,
      p_global_zone_solaris in varchar2,
      p_phy_memory in varchar2,
      p_server_monitoring_tool in varchar2,
      p_db_id in number,
      p_cluster_id in number,
      p_clustered in varchar2,
      p_cluster_name in varchar2,
      p_os_type in varchar2,
      p_env_source in varchar2,
      p_cluster_type in varchar2,
      p_gi_version in varchar2,
      p_gi_current_patchset in varchar2,
      p_id out number,
      p_host_code out VARCHAR2,
      p_decommisioned                in varchar2 default null,
      p_ip_address                   in varchar2 default null,
      p_scan_ip_address              in varchar2 default null,
      p_vip_ip_address               in varchar2 default null   
      ) ;
      
    procedure application_details_ins  (
        p_id                           out number ,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in  varchar2 default null
    );
    
    procedure application_details_upd  (
        p_id                           in number ,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in varchar2 default null
    );    
    
end;

/
--------------------------------------------------------
--  DDL for Package DB_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."DB_REST_UTL" AS 

/*
    -- Purpose: Holding ORDS REST Call API supporting objects for db patch history, db check list & db inventory.
    -- Created On: 18 FEB 2019     
*/


    PROCEDURE dbpatchhistory_upd (
        p_id             IN               VARCHAR2,
        p_db_home        IN               VARCHAR2,
        p_host_name      IN               VARCHAR2,
        p_psu_number     IN               VARCHAR2,
        p_psu_quarter    IN               VARCHAR2,
        p_psu_year       IN               VARCHAR2,
        p_patch_type     IN               VARCHAR2,
        p_host_code      IN               VARCHAR2,
        p_patch_status   IN               VARCHAR2
    );
    
    
    PROCEDURE dbpatchhistory_ins (
        p_id             OUT              NUMBER,
        p_db_home        IN               VARCHAR2 DEFAULT NULL,
        p_psu_number     IN               VARCHAR2 DEFAULT NULL,
        p_psu_quarter    IN               VARCHAR2 DEFAULT NULL,
        p_psu_year       IN               VARCHAR2 DEFAULT NULL,
        p_patch_type     IN               VARCHAR2 DEFAULT NULL,
        p_host_code      IN               VARCHAR2 DEFAULT NULL,
        p_host_name      IN               VARCHAR2 DEFAULT NULL,
        p_patch_status   IN               VARCHAR2 DEFAULT NULL
    );   
    
    PROCEDURE lsinventory_upd (
        p_id          IN            VARCHAR2,
        p_ls_invent   IN            BLOB DEFAULT NULL
    );    
    
    PROCEDURE dbpatchlog_upd (
        p_id          IN            VARCHAR2,
        p_patch_log   IN            BLOB DEFAULT NULL
    );    
    
    PROCEDURE dbchecklist_upd (
        p_id                      IN                        NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2,
        p_task_desc               IN                        VARCHAR2
    );
    
    PROCEDURE dbchecklist_upd2 (
        p_id                      IN                        NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2
    );    
    
    PROCEDURE dbchecklist_ins (
        p_id                      OUT                       NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2,
        p_task_desc               IN                        VARCHAR2,
        p_ticket_ref              IN                        VARCHAR2
    );    
    
    PROCEDURE dbchecklistlogs_ins (
        p_check_list_id   IN                VARCHAR2,
        p_log_file        IN                BLOB,
        p_file_type       IN                VARCHAR2,
        p_mime_type       IN                VARCHAR2,
        p_log_file_desc   IN                VARCHAR2
    );    
    
    procedure dbinventory_upd  (
        p_id                           in number,
        p_database_name                in varchar2 default null,
        p_application_name             in varchar2 default null,
        p_environment                  in varchar2 default null,
        p_oracle_version               in varchar2 default null,
        p_rac_type                     in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_appliance                    in varchar2 default null,
        p_database_role                in varchar2 default null,
        p_pci_required                 in varchar2 default null,
        p_sox_required                 in varchar2 default null,
        p_encryption_required          in varchar2 default null,
        p_dataguard                    in varchar2 default null,
        p_golden_gate                  in varchar2 default null,
        p_backup_enabled               in varchar2 default null,
        p_end_of_life                  in varchar2 default null,
        p_db_monitoring_tool           in varchar2 default null,
        p_monitoring                   in varchar2 default null,
        p_comments                     in varchar2 default null,
        p_instance_count               in number default null,
        p_db_source                    in varchar2 default null,
        p_dr_solution                  in varchar2 default null,
        p_dr_location                  in varchar2 default null,
        p_env_category                 in varchar2 default null,
        p_host_code                    in varchar2 default null,
        p_app_id	                   in number default null,
        p_storage_type	               in varchar2 default null,
        p_db_home                      in varchar2 default null,
        p_decommisioned                in varchar2 default null
    );    
    
    PROCEDURE dbinventory_ins (
        p_id                    OUT                     NUMBER,
        p_database_name         IN                      VARCHAR2,
        p_application_name      IN                      VARCHAR2,
        p_environment           IN                      VARCHAR2,
        p_oracle_version        IN                      VARCHAR2,
        p_rac_type              IN                      VARCHAR2,
        p_business_unit         IN                      VARCHAR2,
        p_appliance             IN                      VARCHAR2,
        p_database_role         IN                      VARCHAR2,
        p_pci_required          IN                      VARCHAR2,
        p_sox_required          IN                      VARCHAR2,
        p_encryption_required   IN                      VARCHAR2,
        p_dataguard             IN                      VARCHAR2,
        p_golden_gate           IN                      VARCHAR2,
        p_backup_enabled        IN                      VARCHAR2,
        p_end_of_life           IN                      VARCHAR2,
        p_db_monitoring_tool    IN                      VARCHAR2,
        p_monitoring            IN                      VARCHAR2,
        p_comments              IN                      VARCHAR2,
        p_instance_count        IN                      NUMBER,
        p_db_source             IN                      VARCHAR2,
        p_dr_solution           IN                      VARCHAR2,
        p_dr_location           IN                      VARCHAR2,
        p_env_category          IN                      VARCHAR2,
        p_app_id                IN                      NUMBER,
        p_storage_type          IN                      VARCHAR2,
        p_cluster_name          IN                      VARCHAR2,
        p_host_name             IN                      VARCHAR2,
        p_db_home               IN                      VARCHAR2,
        p_decommisioned         in varchar2 default null
    );    
    
    procedure dbschedule_upd  (
        p_id                           in number,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    );    
    
    procedure dbschedule_ins  (
        p_id                           out number  ,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    );    
END DB_REST_UTL;

/
--------------------------------------------------------
--  DDL for Package EBA_RESTDEMO_SAMPLE_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_PKG" is
function get_github_repos(
    p_max_rows in number default 10000 ) return eba_restdemo_github_repo_ct pipelined;
function test_url( p_url in varchar2, p_https_host in varchar2 ) return varchar2;
procedure test_all;
end eba_restdemo_sample_pkg;

/
--------------------------------------------------------
--  DDL for Package ITSM_UTILITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."ITSM_UTILITY" AS 

  g_content_type            varchar2(50)  :=  'application/json' ;
  g_endpoint_prefix         varchar2(255) ;
  g_wallet_path             varchar2(255) ;
  g_wallet_pass             varchar2(255)  ;
  p_username                varchar2(255)  ;
  p_password                varchar2(255)  ;
  g_itsm_domain            varchar2(255);
  g_itsm_url               varchar2(255);

procedure LOAD_ITSM_DATA(p_action in varchar2 default 'LOAD',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
) ;


PROCEDURE do_rest_call (
        p_url            IN VARCHAR2,
        p_http_method    IN VARCHAR2 DEFAULT 'GET',
        p_content_type   IN VARCHAR2 DEFAULT g_content_type,
        p_body           IN CLOB DEFAULT NULL,
        p_run_id         IN NUMBER,
        p_response       OUT CLOB
    );

procedure config(p_action in varchar2 default 'INIT_SNOW',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
) ;          




END ITSM_UTILITY;

/
--------------------------------------------------------
--  DDL for Package LICENSE_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."LICENSE_MGR" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
procedure Load_license_data(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);

procedure demo_data(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);


procedure load_json(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
procedure check_schedule(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);

END LICENSE_MGR;

/
--------------------------------------------------------
--  DDL for Package LOGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."LOGGER" 
  authid definer
as
  -- This project using the following MIT License:
  --
  -- The MIT License (MIT)
  --
  -- Copyright (c) 2015 OraOpenSource
  --
  -- Permission is hereby granted, free of charge, to any person obtaining a copy
  -- of this software and associated documentation files (the "Software"), to deal
  -- in the Software without restriction, including without limitation the rights
  -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  -- copies of the Software, and to permit persons to whom the Software is
  -- furnished to do so, subject to the following conditions:
  --
  -- The above copyright notice and this permission notice shall be included in all
  -- copies or substantial portions of the Software.
  --
  -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  -- SOFTWARE.


  -- TYPES
  type rec_param is record(
    name varchar2(255),
    val varchar2(4000));

  type tab_param is table of rec_param index by binary_integer;

  type rec_logger_log is record(
    id logger_logs.id%type,
    logger_level logger_logs.logger_level%type
  );


  -- VARIABLES
	g_logger_version constant varchar2(10) := '3.1.1'; -- Don't change this. Build script will replace with right version number
	g_context_name constant varchar2(35) := substr(sys_context('USERENV','CURRENT_SCHEMA'),1,23)||'_LOGCTX';

  g_off constant number := 0;
  g_permanent constant number := 1;
	g_error constant number := 2;
	g_warning constant number := 4;
	g_information constant number := 8;
  g_debug constant number := 16;
	g_timing constant number := 32;
  g_sys_context constant number := 64;
  g_apex constant number := 128;

  -- #44
  g_off_name constant varchar2(30) := 'OFF';
  g_permanent_name constant varchar2(30) := 'PERMANENT';
  g_error_name constant varchar2(30) := 'ERROR';
  g_warning_name constant varchar2(30) := 'WARNING';
  g_information_name constant varchar2(30) := 'INFORMATION';
  g_debug_name constant varchar2(30) := 'DEBUG';
  g_timing_name constant varchar2(30) := 'TIMING';
  g_sys_context_name constant varchar2(30) := 'SYS_CONTEXT';
  g_apex_name constant varchar2(30) := 'APEX';

  gc_empty_tab_param tab_param;

  -- #54: Types for log_apex_items
  g_apex_item_type_all constant varchar2(30) := 'ALL'; -- Application items and page items
  g_apex_item_type_app constant varchar2(30) := 'APP'; -- All application items
  g_apex_item_type_page constant varchar2(30) := 'PAGE'; -- All page items
  -- To log items on a particular page, just enter the page number

  -- #127
  -- Note to developers: This is only for internal Logger code. Do not use this as part of your code.
  g_pref_type_logger constant logger_prefs.pref_type%type := 'LOGGER'; -- If this changes need to modify logger_prefs.sql as it has a dependancy.

  -- Expose private functions only for testing during development
  $if $$logger_debug $then
    function is_number(p_str in varchar2)
      return boolean;

    procedure assert(
      p_condition in boolean,
      p_message in varchar2);

    function get_param_clob(p_params in logger.tab_param)
      return clob;

    procedure save_global_context(
      p_attribute in varchar2,
      p_value in varchar2,
      p_client_id in varchar2 default null);

    function set_extra_with_params(
      p_extra in logger_logs.extra%type,
      p_params in tab_param)
      return logger_logs.extra%type;

    function get_sys_context(
      p_detail_level in varchar2 default 'USER', -- ALL, NLS, USER, INSTANCE
      p_vertical in boolean default false,
      p_show_null in boolean default false)
      return clob;

    function admin_security_check
      return boolean;

    function get_level_number
      return number;

    function include_call_stack
      return boolean;

    function date_text_format_base (
      p_date_start in date,
      p_date_stop  in date)
      return varchar2;

    procedure log_internal(
      p_text in varchar2,
      p_log_level in number,
      p_scope in varchar2,
      p_extra in clob default null,
      p_callstack in varchar2 default null,
      p_params in tab_param default logger.gc_empty_tab_param);
  $end

  -- PROCEDURES and FUNCTIONS

  procedure null_global_contexts;

  function convert_level_char_to_num(
    p_level in varchar2)
    return number;

  function convert_level_num_to_char(
    p_level in number)
    return varchar2;

  function date_text_format (p_date in date)
    return varchar2;

	function get_character_codes(
		p_string 				in varchar2,
		p_show_common_codes 	in boolean default true)
    return varchar2;

  procedure log_error(
    p_text          in varchar2 default null,
    p_scope         in varchar2 default null,
    p_extra         in clob default null,
    p_params        in tab_param default logger.gc_empty_tab_param);

  procedure log_permanent(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_warning(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_warn(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param);

  procedure log_information(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_info(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param);

  procedure log(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  function get_cgi_env(
    p_show_null		in boolean default false)
  	return clob;

  procedure log_userenv(
    p_detail_level in varchar2 default 'USER',-- ALL, NLS, USER, INSTANCE,
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null);

  procedure log_cgi_env(
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null);

  procedure log_character_codes(
    p_text in varchar2,
    p_scope in logger_logs.scope%type default null,
    p_show_common_codes in boolean default true,
    p_level in logger_logs.logger_level%type default null);

    procedure log_apex_items(
      p_text in varchar2 default 'Log APEX Items',
      p_scope in logger_logs.scope%type default null,
      p_item_type in varchar2 default logger.g_apex_item_type_all,
      p_log_null_items in boolean default true,
      p_level in logger_logs.logger_level%type default null);

	procedure time_start(
		p_unit in varchar2,
    p_log_in_table in boolean default true);

	procedure time_stop(
		p_unit in varchar2,
    p_scope in varchar2 default null);

  function time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true)
    return varchar2;

  function time_stop_seconds(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true)
    return number;

  procedure time_reset;

  function get_pref(
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_type in logger_prefs.pref_type%type default logger.g_pref_type_logger)
    return varchar2
    $if not dbms_db_version.ver_le_10_2  $then
      result_cache
    $end;

  -- #103
  procedure set_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_value in logger_prefs.pref_value%type);

  -- #103
  procedure del_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type);

	procedure purge(
		p_purge_after_days in varchar2 default null,
		p_purge_min_level	in varchar2	default null);

  procedure purge(
    p_purge_after_days in number default null,
    p_purge_min_level in number);

	procedure purge_all;

	procedure status(
		p_output_format	in varchar2 default null); -- SQL-DEVELOPER | HTML | DBMS_OUPUT

  procedure sqlplus_format;

  procedure set_level(
    p_level in varchar2 default logger.g_debug_name,
    p_client_id in varchar2 default null,
    p_include_call_stack in varchar2 default null,
    p_client_id_expire_hours in number default null
  );

  procedure unset_client_level(p_client_id in varchar2);

  procedure unset_client_level;

  procedure unset_client_level_all;


  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in varchar2);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in number);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in date);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with time zone);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with local time zone);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in boolean);

  function ok_to_log(p_level in number)
    return boolean;

  function ok_to_log(p_level in varchar2)
    return boolean;

  function tochar(
    p_val in number)
    return varchar2;

  function tochar(
    p_val in date)
    return varchar2;

  function tochar(
    p_val in timestamp)
    return varchar2;

  function tochar(
    p_val in timestamp with time zone)
    return varchar2;

  function tochar(
    p_val in timestamp with local time zone)
    return varchar2;

  function tochar(
    p_val in boolean)
    return varchar2;

  procedure ins_logger_logs(
    p_logger_level in logger_logs.logger_level%type,
    p_text in varchar2 default null, -- Not using type since want to be able to pass in 32767 characters
    p_scope in logger_logs.scope%type default null,
    p_call_stack in logger_logs.call_stack%type default null,
    p_unit_name in logger_logs.unit_name%type default null,
    p_line_no in logger_logs.line_no%type default null,
    p_extra in logger_logs.extra%type default null,
    po_id out nocopy logger_logs.id%type
  );


  function sprintf(
    p_str in varchar2,
    p_s1 in varchar2 default null,
    p_s2 in varchar2 default null,
    p_s3 in varchar2 default null,
    p_s4 in varchar2 default null,
    p_s5 in varchar2 default null,
    p_s6 in varchar2 default null,
    p_s7 in varchar2 default null,
    p_s8 in varchar2 default null,
    p_s9 in varchar2 default null,
    p_s10 in varchar2 default null)
    return varchar2;

  function get_plugin_rec(
    p_logger_level in logger_logs.logger_level%type)
    return logger.rec_logger_log;
end logger;

/
--------------------------------------------------------
--  DDL for Package OAC$ANSIBLE_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" AS 

/**
-----------------------------------------------------------------------------------------------------------------------------
  This package contains the utility functions and procedure to call the Ansible Tower web service.
  Author: Jaydipsinh Raulji
  www.oracleapexconsultant.com
-----------------------------------------------------------------------------------------------------------------------------
*/

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 

  g_workflow_template       varchar2(100) := 'workflow_job_templates/' ;
  g_playbook_template       varchar2(100) := 'job_templates/' ;
  g_host_template           varchar2(100) := 'hosts/' ;


  g_inventory_template      varchar2(100) := 'inventories/';  
  g_group_template          varchar2(100) := 'groups/';  



  g_flag                    varchar2(1)   :=  'W' ;  -- W : workflow , P : Playbook
  g_workflow                varchar2(1)   :=  'W';
  g_playbook                varchar2(1)   :=  'P';
  g_inventory               varchar2(1)   :=  'I';  
  g_group                   varchar2(1)   :=  'G';
  g_host                    varchar2(100) :=  'H';
  g_content_type            varchar2(50)  :=  'application/json' ;

 /* g_endpoint_prefix         varchar2(100) := 'https://tower.techlab.com/api/v2/' ;
  g_wallet_path             varchar2(100) := 'file:/home/oracle/app/oracle/product/12.2.0/dbhome_1/user';
  g_wallet_pass             varchar2(50)  := 'oracle123';
  p_username                varchar2(50)  :=  'apex' ;
  p_password                varchar2(50)  :=  'apex1234';--'0rac!3' ;
  g_default_inventory       varchar2(50) := 'charter-oracle-inventory';
  g_default_inventory_id    number  := 24;
  g_tower_domain            varchar2(100):= '.techlab.com';
  */

  g_endpoint_prefix         varchar2(100) ;
  g_wallet_path             varchar2(100) ;
  g_wallet_pass             varchar2(50)  ;
  p_username                varchar2(50)  ;
  p_password                varchar2(50)  ;
  g_default_inventory       varchar2(50) ;
  g_default_inventory_id    number  ;
  g_tower_domain            varchar2(100);
  g_tower_url               varchar2(100);

--   function make_rest_call();
-- this procedure intakes the required parameters and make request call to tower api and return back with valid response.
 procedure make_rest_call   (p_flag in varchar2 default g_flag
                            ,p_id in number
                            ,p_param_json in varchar2
                            --,p_job_id out number
                            ,p_response out clob);

    /*
    author: Jaydipsinh Raulji
    */
    PROCEDURE do_rest_call (
        p_url            IN VARCHAR2,
        p_http_method    IN VARCHAR2 DEFAULT 'GET',
        p_content_type   IN VARCHAR2 DEFAULT g_content_type,
        p_body           IN CLOB DEFAULT NULL,
        p_response       OUT CLOB
    );
-- this procedure intake the returned response from above call & other required parameter, then do parsing & log the response to the table.
procedure parse_and_store_resp (p_request_type in varchar2, -- e.g. provisioning
                                p_job_name in varchar2,     -- e.g. oracleprechecks
                                p_ticket_ref in varchar2,   -- e.g. 
                                p_target_name in varchar2,  -- e.g. this can be cluster name when cluster type or host name when host/standalone req. made
                                p_resp_clob in clob,
                                p_id out number,
                                p_request_id out number) ;

-- this the procedure we need to call from the cluster workflow page process.                                
procedure do_cluster_workflow_rest (  p_job_name in varchar2,
                                      p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number                                      
                                    );   

procedure do_standalone_workflow_rest(p_job_name in varchar2,
                                      p_host_name in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_network_type in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_phy_vert in varchar2,
									  p_database_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- this the procedure we need to call from the cluster workflow page process.                                
procedure do_cluster_workflow_rest (  p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number                                      
                                    );   

procedure do_standalone_workflow_rest(p_host_name in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_network_type in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_phy_vert in varchar2,
									  p_database_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- this procedure add host to the given inventory.
procedure add_host (p_inventory_id in number default g_default_inventory_id, p_host_name in varchar2,p_response out clob);

procedure add_group (p_inventory_id in number default g_default_inventory_id, p_group_name in varchar2,p_response out clob);

procedure delete_group (p_group_id in number, p_response out clob);

/**
author: Jaydipsinh Raulji
Purpose: Delete the given host from the tower inventory.
*/
procedure delete_host (p_host_id in number, p_response out clob) ;

/**
--author: Jaydipsinh Raulji
Purpose: Addding/Association of the existing hosts to the given group.
*/
PROCEDURE add_host_to_group (
    p_group_id   IN NUMBER,
    p_host_id    IN NUMBER,
    p_response   OUT CLOB
);

/**
--author: Jaydipsinh Raulji
Purpose: creating new host and adding to the given group.
*/
PROCEDURE create_host_to_group (
    p_inventory_id       IN NUMBER,
    p_group_id           IN NUMBER,
    p_host_name          IN VARCHAR2,
    p_host_description   IN VARCHAR2 DEFAULT '',
    p_enabled            IN VARCHAR2 DEFAULT 'True',--True/False
    p_instance_id        IN NUMBER DEFAULT '',
    p_variables          IN VARCHAR2 DEFAULT '',
    p_response           OUT CLOB
);

-- This function intake url and get the id for the playbook/workflows.
function get_id ( p_url VARCHAR2 ) RETURN NUMBER ; 

-- this function intake type - workflow or playbook & name of the same and return ID.
FUNCTION get_id ( p_workflow_playbook in varchar2 default g_workflow , p_name in VARCHAR2 ) RETURN NUMBER ;

FUNCTION get_playbook_id ( p_name IN VARCHAR2 ) RETURN NUMBER;

FUNCTION get_workflow_id ( p_name IN VARCHAR2 ) RETURN NUMBER;

FUNCTION get_workflow_id_old ( p_name IN VARCHAR2 ) RETURN NUMBER;


FUNCTION get_inventory_id ( p_name IN VARCHAR2 DEFAULT g_default_inventory ) RETURN NUMBER;

FUNCTION get_host_id ( p_name IN VARCHAR2 ) RETURN NUMBER;

FUNCTION get_group_id ( p_name IN VARCHAR2 ) RETURN NUMBER;


-- **********  Procedure for Oracle Precheck  **********

procedure do_oracle_precheck_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- **********  Procedure Oracle - Run Cluster Verify  **********

procedure do_oracle_run_cluster_verify_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- **********  Procedure for Oracle - Install 12c Grid Standalone  **********  

procedure do_oracle_install_12c_grid_standalone_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- **********  Procedure for Oracle - Install 12c Database  **********

procedure do_oracle_install_12c_database_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
									  p_rac_install in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );


-- **********  Procedure for Oracle upgrade from 11g  to 12c database  **********

procedure do_oracle_upgrade_from_11g_to_12c_database_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_oracle_db_home in varchar2,
									  p_oracle_db_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );        


-- **********  Procedure for Oracle - Create DB Instance  **********

procedure do_oracle_create_db_instance_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_oracle_db_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );                


-- **********  Procedure for Oracle - Install 12c Grid Cluster  **********

procedure do_oracle_install_12c_grid_cluster_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_cluster_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );           


-- **********  Procedure for Grid-PSU-apply  **********

procedure do_grid_psu_apply_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_patch_type in varchar2,
									  p_patch_file in varchar2,
									  p_oracle_db_home in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    );        


-- **********  Procedure for RDBMS-PSU-apply  **********

procedure do_psu_apply_rest (       P_PATCH_REQUEST_ID in number,
                                    p_host_name in varchar2,
                                     p_cluster in varchar2,
                                    p_target_type in varchar2,
                                    p_patch_type in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
									  p_patch_file in varchar2,
									  p_oracle_db_home in varchar2,
                                      p_job_id out number,
                                      p_request_id out number,
                                      p_extra_vars out clob
                                    );        


-- **********  Procedure for Get Playbook  call when press REFRESH Button  **********

procedure get_playbook (  p_endpoint in varchar2,

                                      p_job_id out number,
									  p_url out varchar2,
									  p_job_status out varchar2,
									  p_stdout out varchar2,
									  p_response out varchar2
                                    );    


-- **********  Procedure for inserting data in REQUEST_QUEUE table (cluster and standalone detail) *************

/*
procedure insert_request_queue(  
                                      p_request_id in number,
                                      p_template_name in varchar2,
                                      p_job_id in varchar2,
                                      p_job_name in varchar2,
                                      p_job_url in varchar2,
                                      p_status in varchar2,
                                      p_db_option in varchar2,
                                      p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                    --  p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2
                                 );*/
                                 -- **********  Config **********                                 
-- p_action INIT - Set the  package globals from the table                                 
procedure config(p_action in varchar2 default 'INIT',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
) ;          

function setup_oracle_patch_vars(
 p_patch_file in varchar2
) return varchar2;

-- This function intake url and get the name for the playbook/workflows template.
FUNCTION get_name ( p_url VARCHAR2 ) RETURN VARCHAR2;

-- This function intake url and get the name for the playbook/workflows template.
FUNCTION get_name (
    p_template_type   IN VARCHAR2 DEFAULT g_workflow,
    p_id              IN VARCHAR2
) RETURN VARCHAR2;

-- This procedure set the ask variable value.
PROCEDURE set_ask_variable (
    p_url    VARCHAR2,
    p_name   IN VARCHAR2,
    p_flag   IN VARCHAR DEFAULT 'true'
);

END OAC$ANSIBLE_REST_UTL;

/

  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" TO "CHARTER2_SQL";
  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package OAC$ANSIBLE_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."OAC$ANSIBLE_UTL" AS 

  /* TODO enter package declarations (types,exceptions,methods etc) here */
    FUNCTION GET_TEMPLATE_ID (
        P_TEMPLATE_TYP   IN VARCHAR2,
        P_APP_ID         IN NUMBER,
        P_PAGE_ID        IN NUMBER,
        P_APEX_FEATURE   IN VARCHAR2
    ) RETURN NUMBER;

    FUNCTION GET_TEMPLATE_ID ( P_TEMPLATE_NAME IN VARCHAR2 ) RETURN NUMBER;

    FUNCTION GET_TEMPLATE_NAME (
        P_TEMPLATE_TYP   IN VARCHAR2,
        P_APP_ID         IN NUMBER,
        P_PAGE_ID        IN NUMBER,
        P_APEX_FEATURE   IN VARCHAR2
    ) RETURN VARCHAR2;

    PROCEDURE GET_TEMPLATE_INFO (
        P_TEMPLATE_TYP    IN VARCHAR2,
        P_APP_ID          IN NUMBER,
        P_PAGE_ID         IN NUMBER,
        P_APEX_FEATURE    IN VARCHAR2,
        P_TEMPLATE_ID     OUT NUMBER,
        P_TEMPLATE_NAME   OUT VARCHAR2
    );

    FUNCTION GET_TOWER_DOMAIN RETURN VARCHAR2;

    FUNCTION GET_INVENTORY_ID RETURN NUMBER;

    PROCEDURE EXEC_WORKFLOW ( P_REQ_ID IN NUMBER );
    
    FUNCTION exec_workflow ( p_req_id IN NUMBER ) RETURN NUMBER;
    
    FUNCTION exec_playbook_c ( p_req_id IN NUMBER ) RETURN NUMBER;
    
    FUNCTION ENCRYPT ( P_PLAINTEXT VARCHAR2 ) RETURN RAW
        DETERMINISTIC;

    FUNCTION DECRYPT ( P_ENCRYPTEDTEXT RAW ) RETURN VARCHAR2
        DETERMINISTIC;

    PROCEDURE REMOVE_GROUP ( P_REQ_ID IN NUMBER );
    
    /**
    author: Jaydipsinh Raulji
    Purpose: Delete hosts associated with given job request.
    */    
    PROCEDURE remove_hosts ( p_req_id IN NUMBER );     

    PROCEDURE refresh_job ( p_self_srvc_id IN NUMBER ) ;
    
    /**
    author: Jaydipsinh Raulji
    Purpose: This procedure will be used as a part of job which do check not completed jobs & refresh the same.
    */
    PROCEDURE refresh_jobs;    
    
    /**
    author: Jaydipsinh Raulji
    Purpose: This procedure will be used as a part of job which do check completed jobs & remove associated groups.
    */
    PROCEDURE remove_job_groups;    

    procedure LOAD_TOWER_SETUP(p_action in varchar2 default 'LOAD',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
) ;

 procedure setup_batch_job(
  p_search in varchar2 default null,
p_what in varchar2 default null,
p_start in date default null,
p_interval in varchar2 default null
);

 procedure remove_batch_job(
  p_search in varchar2 default null,
p_what in varchar2 default null,
p_start in date default null,
p_interval in varchar2 default null
);
  procedure setup_batch_jobs(
  p_action in varchar2 default 'DAILY',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
);
END OAC$ANSIBLE_UTL;

/

  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_UTL" TO "CHARTER2_SQL";
  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_UTL" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package OAC$AUTH_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."OAC$AUTH_UTL" as

  /*
  Purpose: Package hold utility function and procedure for authentication, authorization and reset password etc.
  author : Jaydipsinh Raulji  
  Remarks:      

  Who                   Date            Description
  -----------------     ----------      --------------------------------
  Jaydipsinh Raulji                     Created

 ==================================================================================================    

  */
 function is_internal_admin return boolean; 



end;

/
--------------------------------------------------------
--  DDL for Package OAC$FILE_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."OAC$FILE_UTL" AUTHID current_user AS 

  /* TODO enter package declarations (types,exceptions,methods etc) here */
    g_default_dir VARCHAR2(100) := 'JSON_DATA';
    g_dir_name_pref VARCHAR2(100) := 'ODIR';
    g_db_check_list_file VARCHAR2(100) := 'db_check_list_dir.txt';
    g_db_check_list_tbl VARCHAR2(100) := 'DB_CHECK_LIST';
    g_host_inv_file VARCHAR2(100) := 'testdir.txt';
    g_host_inv_tbl VARCHAR2(100) := 'host_inv_tbl';
    
    g_db_inv_file VARCHAR2(100) := 'v_db_inventory.txt';
    g_db_inv_tbl VARCHAR2(100) := 'v_db_inventory';    
    
    g_process_status_file VARCHAR2(100) := 'v_process_status.txt';
    g_process_status_tbl VARCHAR2(100) := 'v_process_status';      
    
    FUNCTION get_path ( p_dir IN VARCHAR2 ) RETURN VARCHAR2;

    FUNCTION get_ora_dirname ( p_path IN VARCHAR2 ) RETURN VARCHAR2;

    FUNCTION create_ora_dir (
        p_dir_name   IN VARCHAR2,
        p_dir_path   IN VARCHAR2
    ) RETURN VARCHAR2;

    FUNCTION create_ora_dir ( p_dir_path IN VARCHAR2 ) RETURN VARCHAR2;

    PROCEDURE drop_ora_dir ( p_dir_name IN VARCHAR2 );

    FUNCTION get_clob_from_file (
        p_directory_name   IN VARCHAR2,
        p_file_name        IN VARCHAR2
    ) RETURN CLOB;

    FUNCTION read_file_to_clob (
        p_dir_name    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) RETURN CLOB;

    FUNCTION read_file_to_clob2 (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) RETURN CLOB;

    PROCEDURE get_file_attr (
        p_dir_name      IN VARCHAR2,
        p_file_name     IN VARCHAR2,
        p_exists        OUT BOOLEAN,
        p_file_length   OUT NUMBER,
        p_blocksize     OUT NUMBER
    );

    FUNCTION list_files ( p_directory_file IN VARCHAR2 ) RETURN file_listing_ntt
        PIPELINED;

    PROCEDURE get_path (
        p_file   IN VARCHAR2,
        p_path   OUT VARCHAR2
    );

    PROCEDURE populate_rest_logs_tbl (
        p_directory_file   IN VARCHAR2,
        p_ref_tbl_name     IN VARCHAR2
    );

    PROCEDURE fetch_host_inv_files;

    PROCEDURE fetch_dbchecklist_files;
    
    PROCEDURE fetch_db_inv_files;
    
    PROCEDURE fetch_process_status_files;
    
END oac$file_utl;

/
--------------------------------------------------------
--  DDL for Package SETUP_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."SETUP_MGR" is 
    -------------------------------------------------------------------------
    -- Generates a unique Identifier
    -------------------------------------------------------------------------
    function gen_id return number;
    -------------------------------------------------------------------------
    -- Gets the current user's authorization level. Can depend on the following:
    --  * If access control is currently disabled, returns highest level of 2.
    --  * If access control is enabled, but user is not in list, returns 1
    --  * If access control is enabled and user is in list, returns their
    --    access level.
    -------------------------------------------------------------------------
    function get_authorization_level (
        p_username             varchar2)
        return number;
        
    function is_internal_admin return boolean;
    
end SETUP_MGR ;


/
--------------------------------------------------------
--  DDL for Package SIMPLE_CRYPTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."SIMPLE_CRYPTO" 

AS

   FUNCTION encrypt (p_plainText VARCHAR2) RETURN RAW DETERMINISTIC;

   FUNCTION decrypt (p_encryptedText RAW) RETURN VARCHAR2 DETERMINISTIC;

END;


/
--------------------------------------------------------
--  DDL for Package STANDARD_TASK_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."STANDARD_TASK_MGR" AS 

procedure task_queue(
        p_action   IN VARCHAR2 DEFAULT 'CHECK_SCHEDULE',
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);

 
procedure save_task(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);

procedure set_globals(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
);
 procedure     run_tower_task (   p_schedule_id in number
                                   /* , p_job_id out number,
                                      p_self_service_id out number                                      
                                 */
                                    );
--Globals
/*
G_PROJECT_ID varchar2(255);
G_APP_ID varchar2(255);
G_DC_LOCATION varchar2(255);
G_ENVIRONMENT varchar2(255);
G_DOMAIN varchar2(255); 
G_DATABASE_NAME varchar2(255);
G_CLUSTER varchar2(255);
G_DB_VERSION varchar2(255);
G_DB_HOME varchar2(255);
*/
G_HOST_LIST clob;
G_PARM_LIST clob;
G_EXTRA_VAR clob;
--G_TASK_ID number;
G_TASK_ID varchar2(255);
G_TASK_KEY varchar2(255);
G_EXECUTE_ON varchar2(255);
G_TICKET_REF varchar2(255);
g_unique_grp varchar2(255); 


/*
TASK_PARM1 varchar2(1000);
TASK_PARM2 varchar2(1000);
TASK_PARM3 varchar2(1000);
TASK_PARM4 varchar2(1000);
TASK_PARM5 varchar2(1000);
TASK_PARM6 varchar2(1000);
TASK_PARM7 varchar2(1000);
TASK_PARM8 varchar2(1000);
TASK_PARM9 varchar2(1000);
TASK_NAME_PARM1 varchar2(1000);
TASK_NAME_PARM2 varchar2(1000);
TASK_NAME_PARM3 varchar2(1000);
TASK_NAME_PARM4 varchar2(1000);
TASK_NAME_PARM5 varchar2(1000);
TASK_NAME_PARM6 varchar2(1000);
TASK_NAME_PARM7 varchar2(1000);
TASK_NAME_PARM8 varchar2(1000);
TASK_NAME_PARM9 varchar2(1000);
*/
/* TODO enter package declarations (types, exceptions, methods etc) here */ 

  g_workflow_template       varchar2(100) := 'workflow_job_templates/' ;
  g_playbook_template       varchar2(100) := 'job_templates/' ;
  g_host_template           varchar2(100) := 'hosts/' ;


  g_inventory_template      varchar2(100) := 'inventories/';  
  g_group_template          varchar2(100) := 'groups/';  



  g_flag                    varchar2(1)   :=  'W' ;  -- W : workflow , P : Playbook
  g_workflow                varchar2(1)   :=  'W';
  g_playbook                varchar2(1)   :=  'P';
  g_inventory               varchar2(1)   :=  'I';  
  g_group                   varchar2(1)   :=  'G';
  g_host                    varchar2(100) :=  'H';
  g_content_type            varchar2(50)  :=  'application/json' ;


 -- oac$ansible_rest_utl
  g_endpoint_prefix         varchar2(100) ;
  g_wallet_path             varchar2(100) ;
  g_wallet_pass             varchar2(50)  ;
  p_username                varchar2(50)  ;
  p_password                varchar2(50)  ;
  g_default_inventory       varchar2(50) ;
  g_default_inventory_id    number  ;
  g_tower_domain            varchar2(100);
  g_tower_url               varchar2(100);
 

END STANDARD_TASK_MGR;

/

  GRANT EXECUTE ON "CHARTER2_INV"."STANDARD_TASK_MGR" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package STATUS_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."STATUS_REST_UTL" AS 

/*
    -- Purpose: Holding ORDS REST Call API supporting objects for checklist status & process status.
    -- Created On: 18 FEB 2019     
*/
    PROCEDURE checkliststatus_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_task_body          IN                   BLOB,--v_checklist_status.task_body%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );
    
    PROCEDURE checkliststatus_file_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_file_upload        IN                   v_checklist_status.file_upload%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_file_mimetype      IN                   v_checklist_status.file_mimetype%TYPE,
        p_file_name          IN                   v_checklist_status.file_name%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );
    
    PROCEDURE process_status_ins (
        p_task_id            IN                   v_process_status.task_id%TYPE,
        p_task_key           IN                   v_process_status.task_key%TYPE,
        p_task_area          IN                   v_process_status.task_area%TYPE,
        p_task_status        IN                   v_process_status.task_status%TYPE,
        p_task_message       IN                   v_process_status.task_message%TYPE,
        p_task_body          IN                   BLOB,--v_process_status.task_body%TYPE,
        p_record_type        IN                   v_process_status.record_type%TYPE,
        p_standard_task_id   IN                   v_process_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );    
    
    PROCEDURE process_status_file_ins (
        p_task_id            IN                   v_process_status.task_id%TYPE,
        p_task_key           IN                   v_process_status.task_key%TYPE,
        p_task_area          IN                   v_process_status.task_area%TYPE,
        p_task_status        IN                   v_process_status.task_status%TYPE,
        p_task_message       IN                   v_process_status.task_message%TYPE,
        p_file_upload        IN                   v_process_status.file_upload%TYPE,
        p_record_type        IN                   v_process_status.record_type%TYPE,
        p_file_mimetype      IN                   v_process_status.file_mimetype%TYPE,
        p_file_name          IN                   v_process_status.file_name%TYPE,
        p_standard_task_id   IN                   v_process_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );  
    
     PROCEDURE checkliststatus_sql_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_task_body          IN                   BLOB,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );

    PROCEDURE checkliststatus_sql_file_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_file_upload        IN                   v_checklist_status.file_upload%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_file_mimetype      IN                   v_checklist_status.file_mimetype%TYPE,
        p_file_name          IN                   v_checklist_status.file_name%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    );
    
END STATUS_REST_UTL;

/
--------------------------------------------------------
--  DDL for Package V_APPLICATION_DETAILS_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_API" 
is

    

    procedure get_row (
        p_id                           in number,
        P_application_name             out varchar2,
        P_business_unit                out varchar2,
        P_technical_contact            out varchar2,
        P_tech_contact_email           out varchar2,
        P_app_desc                     out varchar2,
        P_app_owner                    out varchar2,
        P_app_owner_email              out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_ref_app_id                   out varchar2
        
    );



    procedure insert_row  (
        p_id                           out number,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in varchar2 default null
    );
    procedure update_row  (
        p_id                           in number default null,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in varchar2 default null
    );
    procedure delete_row (
        p_id                           in number
    );
end ;

/
--------------------------------------------------------
--  DDL for Package V_CLUSTER_MEMBER_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_API" 
is
    /* example:
        declare
            l_cluster_name                  varchar2(60);
            l_cluster_type                  varchar2(20);
            l_gi_version                    varchar2(20);
            l_gi_current_patchset           varchar2(20);
            l_host_code                     varchar2(10);
            l_created                       date;
            l_created_by                    varchar2(255);
            l_updated                       date;
            l_updated_by                    varchar2(255);
        begin
        v_cluster_member_tbl_api.get_row (
            p_id                            => 1,
            p_cluster_name                  => l_cluster_name,
            p_cluster_type                  => l_cluster_type,
            p_gi_version                    => l_gi_version,
            p_gi_current_patchset           => l_gi_current_patchset,
            p_host_code                     => l_host_code,
            p_created                       => l_created,
            p_created_by                    => l_created_by,
            p_updated                       => l_updated,
            p_updated_by                    => l_updated_by
            );
        end;
    */
    procedure get_row (
        p_id                           in number,
        P_cluster_name                 out varchar2,
        P_cluster_type                 out varchar2,
        P_gi_version                   out varchar2,
        P_gi_current_patchset          out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_env_source                   out varchar2
    );
    /* example:
        begin
        v_cluster_member_tbl_api.insert_row (
            p_id                          => null,
            p_cluster_name                => null,
            p_cluster_type                => null,
            p_gi_version                  => null,
            p_gi_current_patchset         => null,
            p_host_code                   => null
            );
        end;
    */
    procedure insert_row  (
        p_id                           out number ,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null,
        p_host_code                    out varchar2 ,
        p_env_source                   in varchar2
    );
    procedure update_row  (
        p_id                           in number default null,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null
        --p_host_code                    in varchar2 default null
                           
    );
    procedure delete_row (
        p_id                           in number
    );
end v_cluster_member_tbl_api;

/
--------------------------------------------------------
--  DDL for Package V_DB_CHECK_LIST_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_DB_CHECK_LIST_API" 
is
  
    procedure get_row (
        p_id                           in number,        
        P_checklist_type               out VARCHAR2,
        P_post_build_status            out varchar2,
        P_cluster_verify               out varchar2,
        P_gi_install_status            out varchar2,
        P_db_install_status            out varchar2,
        P_db_upgrade_status            out varchar2,
        P_gi_upgrade_status            out varchar2,
        P_migration_status             out varchar2,
        P_post_migration_status        out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_cluster_id                   out number,
        p_checklist_category           out varchar2,
        p_db_name                      out varchar2,
        p_cluster_name                 out varchar2,
        p_host_name                    out varchar2,
        p_task_desc                    out varchar2 
    );
   
    procedure insert_row  (
       p_id                           out number,
        p_checklist_type               in varchar2 default null,
        p_post_build_status            in varchar2 default null,
        p_cluster_verify               in varchar2 default null,
        p_gi_install_status            in varchar2 default null,
        p_db_install_status            in varchar2 default null,
        p_db_upgrade_status            in varchar2 default null,
        p_gi_upgrade_status            in varchar2 default null,
        p_migration_status             in varchar2 default null,
        p_post_migration_status        in varchar2 default null,
        p_cluster_id                   in number default null,
        p_checklist_category           in varchar2 default null,
        p_db_name                      in varchar2 default null,
        p_cluster_name                 in varchar2 default null,
        p_host_name                    in varchar2 default null,
        p_task_desc                    in varchar2 default null,
          P_ticket_ref  in varchar2 default null
    );
    procedure update_row  (
        p_id                           in number default null,
        p_checklist_type               in varchar2 default null,
        p_post_build_status            in varchar2 default null,
        p_cluster_verify               in varchar2 default null,
        p_gi_install_status            in varchar2 default null,
        p_db_install_status            in varchar2 default null,
        p_db_upgrade_status            in varchar2 default null,
        p_gi_upgrade_status            in varchar2 default null,
        p_migration_status             in varchar2 default null,
        p_post_migration_status        in varchar2 default null,
        p_checklist_category           in varchar2 default null,
        p_db_name                      in varchar2 default null,
        p_cluster_name                 in varchar2 default null,
        p_host_name                    in varchar2 default null,
        p_task_desc                    in varchar2 default null    
    );
    procedure delete_row (
        p_id                           in number
    );
end v_db_check_list_api;

/
--------------------------------------------------------
--  DDL for Package V_DB_INVENTORY_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_DB_INVENTORY_API" 
is
    
    procedure get_row (
        p_id                           in number,
        P_database_name                out varchar2,
        P_application_name             out varchar2,
        P_environment                  out varchar2,
        P_host_name                    out varchar2,
        P_oracle_version               out varchar2,
        P_rac_enabled                  out varchar2,
        P_rac_type                     out varchar2,
        P_business_unit                out varchar2,
        P_cluster_name                 out varchar2,
        P_clustered                    out number,
        P_appliance                    out varchar2,
        P_database_role                out varchar2,
        P_pci_required                 out varchar2,
        P_sox_required                 out varchar2,
        P_encryption_required          out varchar2,
        P_dataguard                    out varchar2,
        P_golden_gate                  out varchar2,
        P_backup_enabled               out varchar2,
        P_end_of_life                  out varchar2,
        P_db_monitoring_tool           out varchar2,
        P_monitoring                   out varchar2,
        P_comments                     out varchar2,
        P_instance_count               out number,
        P_db_source                    out varchar2,
        P_db_id                        out number,
        P_dr_solution                  out varchar2,
        P_dr_location                  out varchar2,
        P_env_category                 out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        P_app_id	                   out number,
        P_storage_type	               out varchar2,
        p_db_home                      out varchar2
    );

    procedure insert_row  (
        p_id                           out number  ,
        p_database_name                in varchar2 default null,
        p_application_name             in varchar2 default null,
        p_environment                  in varchar2 default null,
       -- p_host_name                    in varchar2 default null,
        p_oracle_version               in varchar2 default null,
       -- p_rac_enabled                  in varchar2 default null,
        p_rac_type                     in varchar2 default null,
        p_business_unit                in varchar2 default null,
        --p_cluster_name                 in varchar2 default null,
        --p_clustered                    in number default null,
        p_appliance                    in varchar2 default null,
        p_database_role                in varchar2 default null,
        p_pci_required                 in varchar2 default null,
        p_sox_required                 in varchar2 default null,
        p_encryption_required          in varchar2 default null,
        p_dataguard                    in varchar2 default null,
        p_golden_gate                  in varchar2 default null,
        p_backup_enabled               in varchar2 default null,
        p_end_of_life                  in varchar2 default null,
        p_db_monitoring_tool           in varchar2 default null,
        p_monitoring                   in varchar2 default null,
        p_comments                     in varchar2 default null,
        p_instance_count               in number default null,
        p_db_source                    in varchar2 default null,
        --p_db_id                        in number default null,
        p_dr_solution                  in varchar2 default null,
        p_dr_location                  in varchar2 default null,
        p_env_category                 in varchar2 default null,
        p_host_code                    in varchar2 default null,
        p_app_id	                   in number default null,
        p_storage_type	               in varchar2 default null ,
        p_db_home                      in varchar2 default null
    );
    procedure update_row  (
        p_id                           in number default null,
        p_database_name                in varchar2 default null,
        p_application_name             in varchar2 default null,
        p_environment                  in varchar2 default null,
        --p_host_name                    in varchar2 default null,
        p_oracle_version               in varchar2 default null,
        --p_rac_enabled                  in varchar2 default null,
        p_rac_type                     in varchar2 default null,
        p_business_unit                in varchar2 default null,
        --p_cluster_name                 in varchar2 default null,
        --p_clustered                    in number default null,
        p_appliance                    in varchar2 default null,
        p_database_role                in varchar2 default null,
        p_pci_required                 in varchar2 default null,
        p_sox_required                 in varchar2 default null,
        p_encryption_required          in varchar2 default null,
        p_dataguard                    in varchar2 default null,
        p_golden_gate                  in varchar2 default null,
        p_backup_enabled               in varchar2 default null,
        p_end_of_life                  in varchar2 default null,
        p_db_monitoring_tool           in varchar2 default null,
        p_monitoring                   in varchar2 default null,
        p_comments                     in varchar2 default null,
        p_instance_count               in number default null,
        p_db_source                    in varchar2 default null,
        --p_db_id                        in number default null,
        p_dr_solution                  in varchar2 default null,
        p_dr_location                  in varchar2 default null,
        p_env_category                 in varchar2 default null,
        p_host_code                    in varchar2 default null,
        p_app_id	                   in number default null,
        p_storage_type	               in varchar2 default null,
        p_db_home                      in varchar2 default null
    );
    procedure delete_row (
        p_id                           in number
    );
end v_db_inventory_api;

/
--------------------------------------------------------
--  DDL for Package V_DB_PATCH_HISTORY_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_DB_PATCH_HISTORY_API" 
is
procedure get_row (
p_id              in number,
p_db_home           out VARCHAR2,
p_PSU_NUMBER       out VARCHAR2,
p_PSU_QUARTER      out varchar2,
p_PSU_YEAR         out VARCHAR2,
p_patch_type       out VARCHAR2,
p_host_code        out VARCHAR2,
p_host_name         out varchar2,
p_patch_status      out VARCHAR2
);
procedure insert_row (
p_id              out number,
p_db_home           in VARCHAR2 default null,
p_PSU_NUMBER       in varchar2 default null,
p_PSU_QUARTER      in varchar2 default null,
p_PSU_YEAR         in varchar2 default null,
p_patch_type        in varchar2 default null,
p_host_code           in VARCHAR2 default null,
p_host_name         in VARCHAR2 default null,
p_patch_status      in VARCHAR2 default null
);

procedure update_row (
p_id              in number default null,
p_db_home           in VARCHAR2 default null,
p_PSU_NUMBER       in varchar2 default null,
p_PSU_QUARTER      in varchar2 default null,
p_PSU_YEAR         in varchar2 default null,
p_patch_type        in varchar2 default null,
p_host_code          in VARCHAR2 default null,
p_host_name         in VARCHAR2 default null,
p_patch_status      in VARCHAR2 default null
);

procedure delete_row (
p_id              in number
);

end v_db_patch_history_api;

/
--------------------------------------------------------
--  DDL for Package V_DB_SCHEDULE_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_DB_SCHEDULE_TBL_API" 
is
    /* example:
        declare
            l_db_id                         number;
            l_upgrade_start_date            date;
            l_upgrade_end_date              date;
            l_migration_start_date          date;
            l_migration_end_date            date;
            l_upgrade_completion_time_times varchar2(4000);
            l_migration_completion_time_tim varchar2(4000);
            l_migration_method              varchar2(20);
            l_outage_window                 number;
            l_comments                      varchar2(2000);
            l_created                       date;
            l_created_by                    varchar2(255);
            l_updated                       date;
            l_updated_by                    varchar2(255);
        begin
        v_db_schedule_tbl_api.get_row (
            p_id                            => 1,
            p_db_id                         => l_db_id,
            p_upgrade_start_date            => l_upgrade_start_date,
            p_upgrade_end_date              => l_upgrade_end_date,
            p_migration_start_date          => l_migration_start_date,
            p_migration_end_date            => l_migration_end_date,
            p_upgrade_completion_time_times => l_upgrade_completion_time_timest,
            p_migration_completion_time_tim => l_migration_completion_time_time,
            p_migration_method              => l_migration_method,
            p_outage_window                 => l_outage_window,
            p_comments                      => l_comments,
            p_created                       => l_created,
            p_created_by                    => l_created_by,
            p_updated                       => l_updated,
            p_updated_by                    => l_updated_by
            );
        end;
    */
 procedure get_row (
        p_id                           in number,
        P_db_id                        out number,
        P_upgrade_start_date           out date,
        P_upgrade_end_date             out date,
        P_migration_start_date         out date,
        P_migration_end_date           out date,
        P_UPGR_COMPLETN_TIMES          out varchar2,
        P_MIGR_COMPLETN_TIMES          out varchar2,
        P_migration_method             out varchar2,
        P_outage_window                out number,
        P_comments                     out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2
    );
    /* example:
        begin
        v_db_schedule_tbl_api.insert_row (
            p_id                          => null,
            p_db_id                       => null,
            p_upgrade_start_date          => null,
            p_upgrade_end_date            => null,
            p_migration_start_date        => null,
            p_migration_end_date          => null,
            p_upgrade_completion_time_time=> null,
            p_migration_completion_time_ti=> null,
            p_migration_method            => null,
            p_outage_window               => null,
            p_comments                    => null
            );
        end;
    */
    procedure insert_row  (
        p_id                           out number  ,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    );
    
    procedure update_row  (
        p_id                           in number default null,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    );
    procedure delete_row (
        p_id                           in number
    );
end v_db_schedule_tbl_api;

/
--------------------------------------------------------
--  DDL for Package V_HOST_INV_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_HOST_INV_TBL_API" 
is
    /* example:
        declare
            l_host_name                     varchar2(200);
            l_network_type                  varchar2(40);
            l_core_count                    number;
            l_processor_config_speed        varchar2(30);
            l_server_model                  varchar2(100);
            l_hardware_vendor               varchar2(20);
            l_os_type_version               varchar2(20);
            l_processor_bit                 varchar2(20);
            l_server_creation_date          varchar2(20);
            l_phy_virt                      varchar2(20);
            l_dc_location                   varchar2(20);
            l_global_zone_solaris           varchar2(20);
            l_phy_memory                    varchar2(10);
            l_server_monitoring_tool        varchar2(100);
            l_host_code                     varchar2(20);
            l_created                       date;
            l_created_by                    varchar2(255);
            l_updated                       date;
            l_updated_by                    varchar2(255);
        begin
        v_host_inv_tbl_api.get_row (
            p_id                            => 1,
            p_host_name                     => l_host_name,
            p_network_type                  => l_network_type,
            p_core_count                    => l_core_count,
            p_processor_config_speed        => l_processor_config_speed,
            p_server_model                  => l_server_model,
            p_hardware_vendor               => l_hardware_vendor,
            p_os_type_version               => l_os_type_version,
            p_processor_bit                 => l_processor_bit,
            p_server_creation_date          => l_server_creation_date,
            p_phy_virt                      => l_phy_virt,
            p_dc_location                   => l_dc_location,
            p_global_zone_solaris           => l_global_zone_solaris,
            p_phy_memory                    => l_phy_memory,
            p_server_monitoring_tool        => l_server_monitoring_tool,
            p_host_code                     => l_host_code,
            p_created                       => l_created,
            p_created_by                    => l_created_by,
            p_updated                       => l_updated,
            p_updated_by                    => l_updated_by
            );
        end;
    */
    procedure get_row (
        p_id                           in number,
        P_host_name                    out varchar2,
        P_network_type                 out varchar2,
        P_core_count                   out number,
        P_processor_config_speed       out varchar2,
        P_server_model                 out varchar2,
        P_hardware_vendor              out varchar2,
        P_os_type_version              out varchar2,
        P_processor_bit                out varchar2,
        P_server_creation_date         out varchar2,
        P_phy_virt                     out varchar2,
        P_dc_location                  out varchar2,
        P_global_zone_solaris          out varchar2,
        P_phy_memory                   out varchar2,
        P_server_monitoring_tool       out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        --p_db_id	                       out number,
        --p_cluster_id	               out number,
        p_clustered	                   out varchar2,
        p_os_type	                   out varchar2,
        p_env_source	               out varchar2        
    );
    /* example:
        begin
        v_host_inv_tbl_api.insert_row (
            p_id                          => null,
            p_host_name                   => null,
            p_network_type                => null,
            p_core_count                  => null,
            p_processor_config_speed      => null,
            p_server_model                => null,
            p_hardware_vendor             => null,
            p_os_type_version             => null,
            p_processor_bit               => null,
            p_server_creation_date        => null,
            p_phy_virt                    => null,
            p_dc_location                 => null,
            p_global_zone_solaris         => null,
            p_phy_memory                  => null,
            p_server_monitoring_tool      => null,
            p_host_code                   => null
            );
        end;
    */
    procedure insert_row  (
        p_id                           out number ,
        p_host_name                    in varchar2 default null,
        p_network_type                 in varchar2 default null,
        p_core_count                   in number default null,
        p_processor_config_speed       in varchar2 default null,
        p_server_model                 in varchar2 default null,
        p_hardware_vendor              in varchar2 default null,
        p_os_type_version              in varchar2 default null,
        p_processor_bit                in varchar2 default null,
        p_server_creation_date         in varchar2 default null,
        p_phy_virt                     in varchar2 default null,
        p_dc_location                  in varchar2 default null,
        p_global_zone_solaris          in varchar2 default null,
        p_phy_memory                   in varchar2 default null,
        p_server_monitoring_tool       in varchar2 default null,
        p_host_code                    out varchar2  ,
        --p_db_id	                       in number default null,
        --p_cluster_id	               in number default null,
        p_clustered	                   in varchar2 default null,
        p_os_type	                   in varchar2 default null,
        p_env_source	               in varchar2            
    );
    procedure update_row  (
        p_id                           in number default null,
        p_host_name                    in varchar2 default null,
        p_network_type                 in varchar2 default null,
        p_core_count                   in number default null,
        p_processor_config_speed       in varchar2 default null,
        p_server_model                 in varchar2 default null,
        p_hardware_vendor              in varchar2 default null,
        p_os_type_version              in varchar2 default null,
        p_processor_bit                in varchar2 default null,
        p_server_creation_date         in varchar2 default null,
        p_phy_virt                     in varchar2 default null,
        p_dc_location                  in varchar2 default null,
        p_global_zone_solaris          in varchar2 default null,
        p_phy_memory                   in varchar2 default null,
        p_server_monitoring_tool       in varchar2 default null,
        --p_host_code                    in varchar2 default null,
        --p_db_id	                       in number default null,
        --p_cluster_id	               in number default null,
        p_clustered	                   in varchar2 default null,
        p_os_type	                   in varchar2 default null
        --p_env_source	               in varchar2 default null          
    );
    procedure delete_row (
        p_id                           in number
    );
end v_host_inv_tbl_api;

/
--------------------------------------------------------
--  DDL for Package V_REQUEST_QUEUE_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_REQUEST_QUEUE_API" is
--------------------------------------------------------------
-- create procedure for table "V_REQUEST_QUEUE"
   procedure "INS_V_REQUEST_QUEUE" (
      "P_ID"                     in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null
   );
--------------------------------------------------------------
-- update procedure for table "V_REQUEST_QUEUE"
   procedure "UPD_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null,
      "P_MD5"                    in varchar2                        default null
   );
--------------------------------------------------------------
-- delete procedure for table "V_REQUEST_QUEUE"
   procedure "DEL_V_REQUEST_QUEUE" (
      "P_ID" in number
   );
--------------------------------------------------------------
-- get procedure for table "V_REQUEST_QUEUE"
   procedure "GET_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          out varchar2,
      "P_TEMPLATE_NAME"          out varchar2,
      "P_JOB_NAME"               out varchar2,
      "P_REQUEST_TYPE"           out varchar2,
      "P_DB_OPTION"              out varchar2,
      "P_HOST_NAME"              out clob,
      "P_CLUSTER_NAME"           out varchar2,
      "P_CLUSTER_TYPE"           out varchar2,
      "P_GI_VERSION"             out varchar2,
      "P_ENV_SOURCE"             out varchar2,
      "P_TICKET_REF"             out varchar2,
      "P_APPLICATION_NAME"       out varchar2,
      "P_BUSINESS_UNIT"          out varchar2,
      "P_NETWORK_TYPE"           out varchar2,
      "P_ORACLE_VERSION"         out varchar2,
      "P_OS_TYPE"                out varchar2,
      "P_OS_TYPE_VERSION"        out varchar2,
      "P_PHY_VERT"               out varchar2,
      "P_CLUSTERED"              out varchar2,
      "P_DC_LOCATION"            out varchar2,
      "P_SERVER_MONITORING_TOOL" out varchar2,
      "P_ORACLE_DB_NAME"         out varchar2,
      "P_DB_ENVIRONMENT"         out varchar2,
      "P_RAC_TYPE"               out varchar2,
      "P_DATABASE_ROLE"          out varchar2,
      "P_ENV_CATEGORY"           out varchar2,
      "P_STORAGE_TYPE"           out varchar2,
      "P_DB_MONITORING_TOOL"     out varchar2,
      "P_APPLIANCE"              out varchar2,
      "P_PCI_REQUIRED"           out varchar2,
      "P_SOX_REQUIRED"           out varchar2,
      "P_ENCRYPTION_REQUIRED"    out varchar2,
      "P_BACKUP_ENABLED"         out varchar2,
      "P_MONITORING"             out varchar2,
      "P_STATUS"                 out varchar2,
      "P_CREATED"                out date,
      "P_CREATED_BY"             out varchar2,
      "P_UPDATED"                out date,
      "P_UPDATED_BY"             out varchar2
   );
--------------------------------------------------------------
-- get procedure for table "V_REQUEST_QUEUE"
   procedure "GET_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          out varchar2,
      "P_TEMPLATE_NAME"          out varchar2,
      "P_JOB_NAME"               out varchar2,
      "P_REQUEST_TYPE"           out varchar2,
      "P_DB_OPTION"              out varchar2,
      "P_HOST_NAME"              out clob,
      "P_CLUSTER_NAME"           out varchar2,
      "P_CLUSTER_TYPE"           out varchar2,
      "P_GI_VERSION"             out varchar2,
      "P_ENV_SOURCE"             out varchar2,
      "P_TICKET_REF"             out varchar2,
      "P_APPLICATION_NAME"       out varchar2,
      "P_BUSINESS_UNIT"          out varchar2,
      "P_NETWORK_TYPE"           out varchar2,
      "P_ORACLE_VERSION"         out varchar2,
      "P_OS_TYPE"                out varchar2,
      "P_OS_TYPE_VERSION"        out varchar2,
      "P_PHY_VERT"               out varchar2,
      "P_CLUSTERED"              out varchar2,
      "P_DC_LOCATION"            out varchar2,
      "P_SERVER_MONITORING_TOOL" out varchar2,
      "P_ORACLE_DB_NAME"         out varchar2,
      "P_DB_ENVIRONMENT"         out varchar2,
      "P_RAC_TYPE"               out varchar2,
      "P_DATABASE_ROLE"          out varchar2,
      "P_ENV_CATEGORY"           out varchar2,
      "P_STORAGE_TYPE"           out varchar2,
      "P_DB_MONITORING_TOOL"     out varchar2,
      "P_APPLIANCE"              out varchar2,
      "P_PCI_REQUIRED"           out varchar2,
      "P_SOX_REQUIRED"           out varchar2,
      "P_ENCRYPTION_REQUIRED"    out varchar2,
      "P_BACKUP_ENABLED"         out varchar2,
      "P_MONITORING"             out varchar2,
      "P_STATUS"                 out varchar2,
      "P_CREATED"                out date,
      "P_CREATED_BY"             out varchar2,
      "P_UPDATED"                out date,
      "P_UPDATED_BY"             out varchar2,
      "P_MD5"                    out varchar2
   );
--------------------------------------------------------------
-- build MD5 function for table "V_REQUEST_QUEUE"
   function "BUILD_V_REQUEST_QUEUE_MD5" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null
   ) return varchar2;
   
    procedure insert_row (
      "P_ID"                     out number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default 'PROVISIONING',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default 'P',
      "P_EXTRA_VARS"             in clob                            default null        
   );
   
   procedure insert_row (
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default 'PROVISIONING',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default 'P',
      "P_EXTRA_VARS"             in clob                            default null        
   );
   
   -- insert row for Oracle-Create DB Instance
  /* procedure insert_row_ocd(
       "TICKET_REF"                in varchar2                        default null, 
       "ORACLE_DB_NAME"            in varchar2                        default null, 
       "ENV_CATEGORY"              in varchar2                        default null, 
       "DC_LOCATION"               in varchar2                        default null, 
       "HOST_NAME"                 in varchar2                        default null, 
       "EXTRA_VARS"                in clob                            default null
   );*/
 
end "V_REQUEST_QUEUE_API";

/
--------------------------------------------------------
--  DDL for Package V_REST_DEFINITIONS_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "CHARTER2_INV"."V_REST_DEFINITIONS_API" 
is
    /* example:
        declare
            l_schema_enable                 varchar2(4000);
            l_schema_enable_flag            varchar2(1);
            l_module_name                   varchar2(4000);
            l_uri_prefix                    varchar2(4000);
            l_uri_template                  varchar2(4000);
            l_method                        varchar2(4000);
            l_rest_action                   varchar2(4000);
            l_rest_code                     clob;
            l_created                       date;
            l_created_by                    varchar2(255);
            l_updated                       date;
            l_updated_by                    varchar2(255);
        begin
        v_rest_definitions_api.get_row (
            p_id                            => 1,
            p_schema_enable                 => l_schema_enable,
            p_schema_enable_flag            => l_schema_enable_flag,
            p_module_name                   => l_module_name,
            p_uri_prefix                    => l_uri_prefix,
            p_uri_template                  => l_uri_template,
            p_method                        => l_method,
            p_rest_action                   => l_rest_action,
            p_rest_code                     => l_rest_code,
            p_created                       => l_created,
            p_created_by                    => l_created_by,
            p_updated                       => l_updated,
            p_updated_by                    => l_updated_by
            );
        end;
    */
    procedure get_row (
        p_id                           in number,
        P_schema_enable                out varchar2,
        P_schema_enable_flag           out varchar2,
        P_module_name                  out varchar2,
        P_uri_prefix                   out varchar2,
        P_uri_template                 out varchar2,
        P_method                       out varchar2,
        P_rest_action                  out varchar2,
        P_rest_code                    out clob,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2
    );
    /* example:
        begin
        v_rest_definitions_api.insert_row (
            p_id                          => null,
            p_schema_enable               => null,
            p_schema_enable_flag          => null,
            p_module_name                 => null,
            p_uri_prefix                  => null,
            p_uri_template                => null,
            p_method                      => null,
            p_rest_action                 => null,
            p_rest_code                   => null
            );
        end;
    */
    procedure insert_row  (
        p_id                           out number  ,
        p_schema_enable                in varchar2 default null,
        p_schema_enable_flag           in varchar2 default null,
        p_module_name                  in varchar2 default null,
        p_uri_prefix                   in varchar2 default null,
        p_uri_template                 in varchar2 default null,
        p_method                       in varchar2 default null,
        p_rest_action                  in varchar2 default null,
        p_rest_code                    in clob default null
    );
    procedure update_row  (
        p_id                           in number default null,
        p_schema_enable                in varchar2 default null,
        p_schema_enable_flag           in varchar2 default null,
        p_module_name                  in varchar2 default null,
        p_uri_prefix                   in varchar2 default null,
        p_uri_template                 in varchar2 default null,
        p_method                       in varchar2 default null,
        p_rest_action                  in varchar2 default null,
        p_rest_code                    in clob default null
    );
    procedure delete_row (
        p_id                           in number
    );
end v_rest_definitions_api;

/
--------------------------------------------------------
--  DDL for Package Body BATCH_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."BATCH_MGR" AS

    PROCEDURE check_work_queue (
        p_queue    IN VARCHAR2 DEFAULT NULL,
        p_action   IN VARCHAR2 DEFAULT NULL
    )
        AS
    BEGIN
    -- TODO: Implementation required for PROCEDURE BATCH_MGR.check_work_queue
        NULL;
    END check_work_queue;

    PROCEDURE process_files (
        p_interface   IN VARCHAR2 DEFAULT NULL,
        p_action      IN VARCHAR2 DEFAULT NULL
    )
        AS
    BEGIN
        NULL;
        IF
            upper(p_interface) IN (
                'ALL','DB_CHECK_LIST'
            )
        THEN
            NULL;
    -- Read list files
    -- For each file in the interacfe
    -- read in json data stream as blob
    -- convert to insertable table
    --insert into application table
    -- Add record to processed file queue so that we dont reprocessfile
        ELSIF
            upper(p_interface) IN (
                'ALL','ORACLE_LIC'
            )
        THEN
            NULL;
        ELSIF
            upper(p_interface) IN (
                'ALL','V_HOST_INV_TBL'
            )
        THEN
            process_host_inv_json;
        END IF;

    END;

    PROCEDURE process_host_inv_json (
        p_dir_path    IN VARCHAR2,--p_dir_name
        p_file_name   IN VARCHAR2
    ) IS

        CURSOR c_json IS
            WITH json_test AS (
                SELECT
                    oac$file_utl.read_file_to_clob2(p_dir_path,p_file_name) AS json_data  --oac$file_utl.read_file_to_clob('JSON_DATA','host_inv.json') AS json_data
                FROM dual
            ) SELECT
                jt.*
            FROM json_test,
                     JSON_TABLE ( json_data,'$.host_inv[*]'
                        COLUMNS (
                            row_number FOR ORDINALITY,
                            --v_id NUMBER PATH '$.ID',
                            host_name VARCHAR2 ( 30 ) PATH '$.host_name',
                            network_type VARCHAR2 ( 50 ) PATH '$.network_type',
                            core_count VARCHAR2 ( 50 ) PATH '$.core_count',
                            processor_config_speed VARCHAR2 ( 50 ) PATH '$.processor_config_speed',
                            server_model VARCHAR2 ( 50 ) PATH '$.server_model',
                            hardware_vendor VARCHAR2 ( 50 ) PATH '$.hardware_vendor',
                            os_type_version VARCHAR2 ( 50 ) PATH '$.os_type_version',
                            processor_bit VARCHAR2 ( 50 ) PATH '$.processor_bit',
                            server_creation_date VARCHAR2 ( 50 ) PATH '$.server_creation_date',
                            phy_virt VARCHAR2 ( 50 ) PATH '$.phy_virt',
                            dc_location VARCHAR2 ( 80 ) PATH '$.dc_location',
                            global_zone_solaris VARCHAR2 ( 50 ) PATH '$.global_zone_solaris',
                            phy_memory VARCHAR2 ( 50 ) PATH '$.phy_memory',
                            server_monitoring_tool VARCHAR2 ( 50 ) PATH '$.server_monitoring_tool',
                            cluster_name VARCHAR2 ( 50 ) PATH '$.cluster_name',
                            clustered VARCHAR2 ( 50 ) PATH '$.clustered',
                            os_type VARCHAR2 ( 50 ) PATH '$.os_type',
                            env_source VARCHAR2 ( 50 ) PATH '$.env_source',
                            cluster_type VARCHAR2 ( 50 ) PATH '$.cluster_type',
                            gi_version VARCHAR2 ( 50 ) PATH '$.gi_version',
                            gi_current_patchset VARCHAR2 ( 50 ) PATH '$.gi_current_patchset'
                        )
                    )
                AS jt;

        p_host_code   VARCHAR2(200);
        p_exists      NUMBER;
    BEGIN
    -- insert statement
    -- update the record statement
    
    --insert into host_inv_tbl () 
        FOR i IN c_json LOOP
   -- Consolidate for both Standalone and cluster,the gaol is this page manegers both v_host_inv_tbl and v_cluster_member
   --  If p_cluster_name is not null then lookup it up on cluster table
            IF
                i.cluster_name IS NOT NULL
            THEN
                SELECT
                    MAX(v_host_code)
                INTO
                    p_host_code
                FROM v_cluster_member_tbl
                WHERE
                    cluster_name = i.cluster_name;

                IF
                    p_host_code IS NULL
                THEN
                    p_host_code   := get_host_code('CHR');
                    INSERT INTO charter2_inv.v_cluster_member_tbl (
                        cluster_name,
                        cluster_type,
                        gi_version,
                        gi_current_patchset,
                        v_host_code
                    ) VALUES (
                        i.cluster_name,
                        i.cluster_type,
                        i.gi_version,
                        i.gi_current_patchset,
                        p_host_code
                    );

                END IF;

            ELSE
                p_host_code   := get_host_code;
            END IF;
   --    if we find a record in v_cluster_member table then grab this host code
   --    if we dont find a record in v_cluster_member then we need to insert a host records get the host code 
   --    finally do then insert a member into the cluster member table if its clustered
      -- Does the record Exist

            SELECT
                COUNT(*)
            INTO
                p_exists
            FROM charter2_inv.v_host_inv_tbl
            WHERE
                    host_name = p_host_code
                AND dc_location = i.dc_location;

            IF
                nvl(p_exists,0) <= 0
            THEN
                INSERT INTO charter2_inv.v_host_inv_tbl (
                    host_name,
                    network_type,
                    core_count,
                    processor_config_speed,
                    server_model,
                    hardware_vendor,
                    os_type_version,
                    processor_bit,
                    server_creation_date,
                    phy_virt,
                    dc_location,
                    global_zone_solaris,
                    phy_memory,
                    server_monitoring_tool,
                    host_code,
                    clustered,
                    os_type,
                    env_source
                ) VALUES (
                    i.host_name,
                    i.network_type,
                    i.core_count,
                    i.processor_config_speed,
                    i.server_model,
                    i.hardware_vendor,
                    i.os_type_version,
                    i.processor_bit,
                    i.server_creation_date,
                    i.phy_virt,
                    i.dc_location,
                    i.global_zone_solaris,
                    i.phy_memory,
                    i.server_monitoring_tool,
                    p_host_code,
                    i.clustered,
                    i.os_type,
                    i.env_source
                );-- returning id into p_id;

                UPDATE v_ansible_rest_logs
                    SET
                        status = 'P'
                WHERE
                        file_path = p_dir_path
                    AND file_name = p_file_name
                    AND ref_tbl_name = 'host_inv_tbl';

                COMMIT;
            END IF;

        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            dbms_output.put_line(sqlerrm);
    END process_host_inv_json;

    PROCEDURE process_host_inv_json IS
        CURSOR cur_host_inv IS
            SELECT
                file_path,
                file_name
            FROM v_ansible_rest_logs
            WHERE
                    ref_tbl_name = oac$file_utl.g_host_inv_tbl
                AND status = 'I';

    BEGIN
        NULL;
        FOR i IN cur_host_inv LOOP
            process_host_inv_json(
                i.file_path,
                i.file_name
            );
        END LOOP;

    END process_host_inv_json;

    PROCEDURE process_db_inv_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) IS

        CURSOR c_json IS
            WITH json_test AS (
                SELECT
                    oac$file_utl.read_file_to_clob2(p_dir_path,p_file_name) AS json_data  --oac$file_utl.read_file_to_clob('JSON_DATA','host_inv.json') AS json_data
                FROM dual
            ) SELECT
                jt.*
            FROM json_test,
                     JSON_TABLE ( json_data,'$.db_inv[*]'
                        COLUMNS (
                            row_number FOR ORDINALITY,
                            --v_id NUMBER PATH '$.ID',
                            database_name VARCHAR2 ( 30 ) PATH '$.database_name',
                            application_name VARCHAR2 ( 50 ) PATH '$.application_name',
                            environment VARCHAR2 ( 50 ) PATH '$.environment',
                            oracle_version VARCHAR2 ( 50 ) PATH '$.oracle_version',
                            rac_type VARCHAR2 ( 50 ) PATH '$.rac_type',
                            business_unit VARCHAR2 ( 50 ) PATH '$.business_unit',
                            appliance VARCHAR2 ( 50 ) PATH '$.appliance',
                            database_role VARCHAR2 ( 50 ) PATH '$.database_role',
                            pci_required VARCHAR2 ( 50 ) PATH '$.pci_required',
                            sox_required VARCHAR2 ( 50 ) PATH '$.sox_required',
                            encryption_required VARCHAR2 ( 80 ) PATH '$.encryption_required',
                            dataguard VARCHAR2 ( 50 ) PATH '$.dataguard',
                            golden_gate VARCHAR2 ( 50 ) PATH '$.golden_gate',
                            backup_enabled VARCHAR2 ( 50 ) PATH '$.backup_enabled',
                            end_of_life VARCHAR2 ( 50 ) PATH '$.end_of_life',
                            db_monitoring_tool VARCHAR2 ( 50 ) PATH '$.db_monitoring_tool',
                            monitoring VARCHAR2 ( 50 ) PATH '$.monitoring',
                            comments VARCHAR2 ( 50 ) PATH '$.comments',
                            instance_count VARCHAR2 ( 50 ) PATH '$.instance_count',
                            db_source VARCHAR2 ( 50 ) PATH '$.db_source',
                            dr_solution VARCHAR2 ( 50 ) PATH '$.dr_solution',
                            dr_location VARCHAR2 ( 50 ) PATH '$.dr_location',
                            env_category VARCHAR2 ( 50 ) PATH '$.env_category',
                            host_code VARCHAR2 ( 50 ) PATH '$.host_code',
                            app_id VARCHAR2 ( 50 ) PATH '$.app_id',
                            storage_type VARCHAR2 ( 50 ) PATH '$.storage_type',
                            cluster_name VARCHAR2 ( 50 ) PATH '$.cluster_name',
                            host_name VARCHAR2 ( 50 ) PATH '$.host_name',
                            db_home VARCHAR2 ( 50 ) PATH '$.db_home'
                        )
                    )
                AS jt;

        p_host_code   VARCHAR2(200);
        p_exists      NUMBER;
    BEGIN
    -- insert statement
    -- update the record statement
    
    --insert into host_inv_tbl () 
        FOR i IN c_json LOOP
            IF
                i.cluster_name IS NOT NULL
            THEN
                SELECT
                    MAX(v_host_code)
                INTO
                    p_host_code
                FROM v_cluster_member_tbl
                WHERE
                    cluster_name = i.cluster_name;

            ELSE
                SELECT
                    MAX(host_code)
                INTO
                    p_host_code
                FROM v_host_inv_tbl
                WHERE
                    host_name = i.host_name;

            END IF;

            SELECT
                COUNT(*)
            INTO
                p_exists
            FROM charter2_inv.v_db_inventory
            WHERE
                    database_name = i.database_name
                AND v_host_code = p_host_code;

            IF
                nvl(p_exists,0) <= 0
            THEN
                INSERT INTO charter2_inv.v_db_inventory (
                    database_name,
                    application_name,
                    environment,
                    oracle_version,
                    rac_type,
                    business_unit,
                    appliance,
                    database_role,
                    pci_required,
                    sox_required,
                    encryption_required,
                    dataguard,
                    golden_gate,
                    backup_enabled,
                    end_of_life,
                    db_monitoring_tool,
                    monitoring,
                    comments,
                    instance_count,
                    db_source,
                    dr_solution,
                    dr_location,
                    env_category,
                    v_host_code,
                    app_id,
                    storage_type,
                    db_home
                ) VALUES (
                    i.database_name,
                    i.application_name,
                    i.environment,
                    i.oracle_version,
                    i.rac_type,
                    i.business_unit,
                    i.appliance,
                    i.database_role,
                    i.pci_required,
                    i.sox_required,
                    i.encryption_required,
                    i.dataguard,
                    i.golden_gate,
                    i.backup_enabled,
                    i.end_of_life,
                    i.db_monitoring_tool,
                    i.monitoring,
                    i.comments,
                    i.instance_count,
                    i.db_source,
                    i.dr_solution,
                    i.dr_location,
                    i.env_category,
                    p_host_code,
                    i.app_id,
                    i.storage_type,
                    i.db_home
                );--returning id into p_id ;

                UPDATE v_ansible_rest_logs
                    SET
                        status = 'P'
                WHERE
                        file_path = p_dir_path
                    AND file_name = p_file_name
                    AND ref_tbl_name = 'v_db_inventory';

                COMMIT;
            END IF;

        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            dbms_output.put_line(sqlerrm);
    END process_db_inv_json;

    PROCEDURE process_db_inv_json IS
        CURSOR cur_db_inv IS
            SELECT
                file_path,
                file_name
            FROM v_ansible_rest_logs
            WHERE
                    ref_tbl_name = oac$file_utl.g_db_inv_tbl
                AND status = 'I';

    BEGIN
        FOR i IN cur_db_inv LOOP
            process_db_inv_json(
                i.file_path,
                i.file_name
            );
        END LOOP;
    END process_db_inv_json;

    PROCEDURE process_db_chklst_json (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) IS

        CURSOR c_json IS
            WITH json_test AS (
                SELECT
                    oac$file_utl.read_file_to_clob2(p_dir_path,p_file_name) AS json_data  
                FROM dual
            ) SELECT
                jt.*
            FROM json_test,
                     JSON_TABLE ( json_data,'$.db_chklst[*]'
                        COLUMNS (
                            row_number FOR ORDINALITY,
                            checklist_type VARCHAR2 ( 30 ) PATH '$.checklist_type',
                            post_build_status VARCHAR2 ( 50 ) PATH '$.post_build_status',
                            cluster_verify VARCHAR2 ( 50 ) PATH '$.cluster_verify',
                            gi_install_status VARCHAR2 ( 50 ) PATH '$.gi_install_status',
                            db_install_status VARCHAR2 ( 50 ) PATH '$.db_install_status',
                            db_upgrade_status VARCHAR2 ( 50 ) PATH '$.db_upgrade_status',
                            gi_upgrade_status VARCHAR2 ( 50 ) PATH '$.gi_upgrade_status',
                            migration_status VARCHAR2 ( 50 ) PATH '$.migration_status',
                            post_migration_status VARCHAR2 ( 50 ) PATH '$.post_migration_status',
                            checklist_category VARCHAR2 ( 50 ) PATH '$.checklist_category',
                            db_name VARCHAR2 ( 80 ) PATH '$.db_name',
                            cluster_name VARCHAR2 ( 50 ) PATH '$.cluster_name',
                            host_name VARCHAR2 ( 50 ) PATH '$.host_name',
                            task_desc VARCHAR2 ( 255 ) PATH '$.task_desc',
                            ticket_ref VARCHAR2 ( 100 ) PATH '$.ticket_ref'
                        )
                    )
                AS jt;

        p_host_code   VARCHAR2(200);
        p_exists      NUMBER;
    BEGIN
    -- insert statement
    -- update the record statement
    
    --insert into host_inv_tbl () 
        FOR i IN c_json LOOP
        insert into charter2_inv.v_db_check_list (
            checklist_type,
            post_build_status,
            cluster_verify,
            gi_install_status,
            db_install_status,
            db_upgrade_status,
            gi_upgrade_status,
            migration_status,
            post_migration_status,
            checklist_category,
            db_name,
            host_name,
            cluster_name,
            task_desc,
            ticket_ref
        ) values (
            i.checklist_type,
            i.post_build_status,
            i.cluster_verify,
            i.gi_install_status,
            i.db_install_status,
            i.db_upgrade_status,
            i.gi_upgrade_status,
            i.migration_status,
            i.post_migration_status,
            i.checklist_category,
            i.db_name,
            i.host_name,
            i.cluster_name,
            i.task_desc,
            i.ticket_ref
        ); 
                UPDATE v_ansible_rest_logs
                    SET
                        status = 'P'
                WHERE
                        file_path = p_dir_path
                    AND file_name = p_file_name
                    AND ref_tbl_name = oac$file_utl.g_db_check_list_tbl;

                COMMIT;

        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            dbms_output.put_line(sqlerrm);
    END process_db_chklst_json;

    PROCEDURE process_db_chklst_json IS
        CURSOR cur_db_chklst IS
            SELECT
                file_path,
                file_name
            FROM v_ansible_rest_logs
            WHERE
                    ref_tbl_name = oac$file_utl.g_db_check_list_tbl
                AND status = 'I';

    BEGIN
        FOR i IN cur_db_chklst LOOP
            process_db_chklst_json(
                i.file_path,
                i.file_name
            );
        END LOOP;
    END process_db_chklst_json;
    
PROCEDURE process_status_json (
    p_dir_path    IN VARCHAR2,
    p_file_name   IN VARCHAR2
) IS

    CURSOR c_json IS
        WITH json_test AS (
            SELECT
                oac$file_utl.read_file_to_clob2(p_dir_path,p_file_name) AS json_data
            FROM dual
        ) SELECT
            jt.*
        FROM json_test,
                 JSON_TABLE ( json_data,'$.process_status[*]'
                    COLUMNS (
                        row_number FOR ORDINALITY,
                        task_id VARCHAR2 ( 255 ) PATH '$.task_id',
                        task_key VARCHAR2 ( 1000 ) PATH '$.task_key',
                        task_area VARCHAR2 ( 1000 ) PATH '$.task_area',
                        task_status VARCHAR2 ( 255 ) PATH '$.task_status',
                        task_message VARCHAR2 ( 4000 ) PATH '$.task_message',
                        body VARCHAR2(32767) PATH '$.body',
                        record_type VARCHAR2 ( 255 ) PATH '$.record_type'
                    )
                )
            AS jt;

    p_host_code   VARCHAR2(200);
    p_exists      NUMBER;
BEGIN
    -- insert statement
    -- update the record statement
    
    --insert into host_inv_tbl () 
    FOR i IN c_json LOOP
        INSERT INTO v_process_status (
            task_id,
            task_key,
            task_area,
            task_status,
            task_message,
            task_body,
            record_type
        ) VALUES (
            i.task_id,
            i.task_key,
            i.task_area,
            i.task_status,
            i.task_message,
            i.body,
            i.record_type
        ) ;

        UPDATE v_ansible_rest_logs
            SET
                status = 'P'
        WHERE
                file_path = p_dir_path
            AND file_name = p_file_name
            AND ref_tbl_name = oac$file_utl.g_process_status_tbl;

        COMMIT;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        dbms_output.put_line(sqlerrm);
END process_status_json;

PROCEDURE process_status_json IS
    CURSOR cur_process_status IS
        SELECT
            file_path,
            file_name
        FROM v_ansible_rest_logs
        WHERE
                ref_tbl_name = oac$file_utl.g_process_status_tbl
            AND status = 'I';

BEGIN
    FOR i IN cur_process_status LOOP
        process_status_json(
            i.file_path,
            i.file_name
        );
    END LOOP;
END process_status_json;    
    
END batch_mgr;

/
--------------------------------------------------------
--  DDL for Package Body CLUSTER_HOST_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."CLUSTER_HOST_REST_UTL" IS

    PROCEDURE cluster_member_ins (
        p_id                    OUT                     NUMBER,
        p_cluster_name          IN                      VARCHAR2 DEFAULT NULL,
        p_cluster_type          IN                      VARCHAR2 DEFAULT NULL,
        p_gi_version            IN                      VARCHAR2 DEFAULT NULL,
        p_gi_current_patchset   IN                      VARCHAR2 DEFAULT NULL,
        p_host_code             OUT                     VARCHAR2,
        p_env_source            IN                      VARCHAR2
    ) IS
    BEGIN
        INSERT INTO charter2_inv.v_cluster_member_tbl (
            cluster_name,
            cluster_type,
            gi_version,
            gi_current_patchset,
            env_source
        ) VALUES (
            p_cluster_name,
            p_cluster_type,
            p_gi_version,
            p_gi_current_patchset,
            p_env_source
        ) RETURNING id,
                    v_host_code INTO p_id, p_host_code;

    END cluster_member_ins;

    PROCEDURE cluster_member_upd (
        p_id                    IN                      NUMBER,
        p_cluster_name          IN                      VARCHAR2 DEFAULT NULL,
        p_cluster_type          IN                      VARCHAR2 DEFAULT NULL,
        p_gi_version            IN                      VARCHAR2 DEFAULT NULL,
        p_gi_current_patchset   IN                      VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        UPDATE charter2_inv.v_cluster_member_tbl
        SET
            cluster_name = nvl(p_cluster_name, cluster_name),
            cluster_type = nvl(p_cluster_type, cluster_type),
            gi_version = nvl(p_gi_version, gi_version),
            gi_current_patchset = nvl(p_gi_current_patchset, gi_current_patchset)
        WHERE
            id = p_id;

    END cluster_member_upd;

    PROCEDURE host_inv_upd (
        p_id                       IN                         NUMBER,
        p_host_name                IN                         VARCHAR2 DEFAULT NULL,
        p_network_type             IN                         VARCHAR2 DEFAULT NULL,
        p_core_count               IN                         NUMBER DEFAULT NULL,
        p_processor_config_speed   IN                         VARCHAR2 DEFAULT NULL,
        p_server_model             IN                         VARCHAR2 DEFAULT NULL,
        p_hardware_vendor          IN                         VARCHAR2 DEFAULT NULL,
        p_os_type_version          IN                         VARCHAR2 DEFAULT NULL,
        p_processor_bit            IN                         VARCHAR2 DEFAULT NULL,
        p_server_creation_date     IN                         VARCHAR2 DEFAULT NULL,
        p_phy_virt                 IN                         VARCHAR2 DEFAULT NULL,
        p_dc_location              IN                         VARCHAR2 DEFAULT NULL,
        p_global_zone_solaris      IN                         VARCHAR2 DEFAULT NULL,
        p_phy_memory               IN                         VARCHAR2 DEFAULT NULL,
        p_server_monitoring_tool   IN                         VARCHAR2 DEFAULT NULL,
        p_clustered                IN                         VARCHAR2 DEFAULT NULL,
        p_os_type                  IN                         VARCHAR2 DEFAULT NULL,
        p_decommisioned            IN                         VARCHAR2 DEFAULT NULL,
        p_ip_address               IN                         VARCHAR2 DEFAULT NULL,
        p_scan_ip_address          IN                         VARCHAR2 DEFAULT NULL,
        p_vip_ip_address           IN                         VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        UPDATE charter2_inv.v_host_inv_tbl
        SET
            --id = p_id,
            host_name = nvl(p_host_name, host_name),
            network_type = nvl(p_network_type, network_type),
            core_count = nvl(p_core_count, core_count),
            processor_config_speed = nvl(p_processor_config_speed, processor_config_speed),
            server_model = nvl(p_server_model, server_model),
            hardware_vendor = nvl(p_hardware_vendor, hardware_vendor),
            os_type_version = nvl(p_os_type_version, os_type_version),
            processor_bit = nvl(p_processor_bit, processor_bit),
            server_creation_date = nvl(p_server_creation_date, server_creation_date),
            phy_virt = nvl(p_phy_virt, phy_virt),
            dc_location = nvl(p_dc_location, dc_location),
            global_zone_solaris = nvl(p_global_zone_solaris, global_zone_solaris),
            phy_memory = nvl(p_phy_memory, phy_memory),
            server_monitoring_tool = nvl(p_server_monitoring_tool, server_monitoring_tool),
            clustered = nvl(p_clustered, clustered),
            os_type = nvl(p_os_type, os_type),
            decommisioned = nvl(p_decommisioned, decommisioned),
            ip_address = nvl(p_ip_address, ip_address),
            scan_ip_address = nvl(p_scan_ip_address, scan_ip_address),
            vip_ip_address = nvl(p_vip_ip_address, vip_ip_address)
        WHERE
            id = p_id;

    END host_inv_upd;

    PROCEDURE host_inv_ins (
        p_host_name                IN                         VARCHAR2,
        p_network_type             IN                         VARCHAR2,
        p_core_count               IN                         NUMBER,
        p_processor_config_speed   IN                         VARCHAR2,
        p_server_model             IN                         VARCHAR2,
        p_hardware_vendor          IN                         VARCHAR2,
        p_os_type_version          IN                         VARCHAR2,
        p_processor_bit            IN                         VARCHAR2,
        p_server_creation_date     IN                         VARCHAR2,
        p_phy_virt                 IN                         VARCHAR2,
        p_dc_location              IN                         VARCHAR2,
        p_global_zone_solaris      IN                         VARCHAR2,
        p_phy_memory               IN                         VARCHAR2,
        p_server_monitoring_tool   IN                         VARCHAR2,
        p_db_id                    IN                         NUMBER,
        p_cluster_id               IN                         NUMBER,
        p_clustered                IN                         VARCHAR2,
        p_cluster_name             IN                         VARCHAR2,
        p_os_type                  IN                         VARCHAR2,
        p_env_source               IN                         VARCHAR2,
        p_cluster_type             IN                         VARCHAR2,
        p_gi_version               IN                         VARCHAR2,
        p_gi_current_patchset      IN                         VARCHAR2,
        p_id                       OUT                        NUMBER,
        p_host_code                OUT                        VARCHAR2,
        p_decommisioned                in varchar2 default null,
        p_ip_address                   in varchar2 default null,
        p_scan_ip_address              in varchar2 default null,
        p_vip_ip_address               in varchar2 default null   
    ) IS
        p_exists   NUMBER;
    BEGIN
      -- Not Used 
      --p_host_code := :host_code;
      --p_db_id := :db_id;
      --p_cluster_id := :cluster_id;
       -- Consolidate for both Standalone and cluster,  the gaol is this page manegers both v_host_inv_tbl and v_cluster_member
       --  If p_cluster_name is not null then lookup it up on cluster table
        IF p_cluster_name IS NOT NULL THEN
            SELECT
                MAX(v_host_code)
            INTO p_host_code
            FROM
                v_cluster_member_tbl
            WHERE
                cluster_name = p_cluster_name;

            IF p_host_code IS NULL THEN
                p_host_code := get_host_code('CHR');
                INSERT INTO charter2_inv.v_cluster_member_tbl (
                    cluster_name,
                    cluster_type,
                    gi_version,
                    gi_current_patchset,
                    v_host_code
                ) VALUES (
                    p_cluster_name,
                    p_cluster_type,
                    p_gi_version,
                    p_gi_current_patchset,
                    p_host_code
                );

            END IF;

        ELSE
            p_host_code := get_host_code('CHR');
        END IF;
       --    if we find a record in v_cluster_member table then grab this host code
       --    if we dont find a record in v_cluster_member then we need to insert a host records get the host code 
       --    finally do then insert a member into the cluster member table if its clustered
          -- Does the record Exist

        SELECT
            COUNT(*),
            MAX(id)
        INTO
            p_exists,
            p_id
        FROM
            charter2_inv.v_host_inv_tbl
        WHERE
            host_name = p_host_name
            AND dc_location = p_dc_location;

        IF nvl(p_exists, 0) <= 0 THEN
            INSERT INTO charter2_inv.v_host_inv_tbl (
                host_name,
                network_type,
                core_count,
                processor_config_speed,
                server_model,
                hardware_vendor,
                os_type_version,
                processor_bit,
                server_creation_date,
                phy_virt,
                dc_location,
                global_zone_solaris,
                phy_memory,
                server_monitoring_tool,
                host_code,
                clustered,
                os_type,
                env_source,
                decommisioned,
                ip_address,
                scan_ip_address,
                vip_ip_address
            ) VALUES (
                p_host_name,
                p_network_type,
                p_core_count,
                p_processor_config_speed,
                p_server_model,
                p_hardware_vendor,
                p_os_type_version,
                p_processor_bit,
                p_server_creation_date,
                p_phy_virt,
                p_dc_location,
                p_global_zone_solaris,
                p_phy_memory,
                p_server_monitoring_tool,
                p_host_code,
                p_clustered,
                p_os_type,
                p_env_source,
                p_decommisioned,
                p_ip_address,
                p_scan_ip_address,
                p_vip_ip_address                
            ) RETURNING id INTO p_id;

        END IF;

    END;

    PROCEDURE application_details_ins (
        p_id                   OUT                    NUMBER,
        p_application_name     IN                     VARCHAR2 DEFAULT NULL,
        p_business_unit        IN                     VARCHAR2 DEFAULT NULL,
        p_technical_contact    IN                     VARCHAR2 DEFAULT NULL,
        p_tech_contact_email   IN                     VARCHAR2 DEFAULT NULL,
        p_app_desc             IN                     VARCHAR2 DEFAULT NULL,
        p_app_owner            IN                     VARCHAR2 DEFAULT NULL,
        p_app_owner_email      IN                     VARCHAR2 DEFAULT NULL,
        p_ref_app_id           IN                     VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO charter2_inv.v_application_details_tbl (
           -- id,                   -- We need to populate it using trigger.
            application_name,
            business_unit,
            technical_contact,
            tech_contact_email,
            app_desc,
            app_owner,
            app_owner_email,
            ref_app_id
        ) VALUES (
          --  p_id,                 -- We need to populate it using trigger.
            p_application_name,
            p_business_unit,
            p_technical_contact,
            p_tech_contact_email,
            p_app_desc,
            p_app_owner,
            p_app_owner_email,
            p_ref_app_id
        ) RETURNING id INTO p_id;

    END application_details_ins;

    PROCEDURE application_details_upd (
        p_id                   IN                     NUMBER,
        p_application_name     IN                     VARCHAR2 DEFAULT NULL,
        p_business_unit        IN                     VARCHAR2 DEFAULT NULL,
        p_technical_contact    IN                     VARCHAR2 DEFAULT NULL,
        p_tech_contact_email   IN                     VARCHAR2 DEFAULT NULL,
        p_app_desc             IN                     VARCHAR2 DEFAULT NULL,
        p_app_owner            IN                     VARCHAR2 DEFAULT NULL,
        p_app_owner_email      IN                     VARCHAR2 DEFAULT NULL,
        p_ref_app_id           IN                     VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        UPDATE charter2_inv.v_application_details_tbl
        SET
            application_name = nvl(p_application_name, application_name),
            business_unit = nvl(p_business_unit, business_unit),
            technical_contact = nvl(p_technical_contact, technical_contact),
            tech_contact_email = nvl(p_tech_contact_email, tech_contact_email),
            app_desc = nvl(p_app_desc, app_desc),
            app_owner = nvl(p_app_owner, app_owner),
            app_owner_email = nvl(p_app_owner_email, app_owner_email),
            ref_app_id = nvl(p_ref_app_id, ref_app_id)
        WHERE
            id = p_id;

    END application_details_upd;

END "CLUSTER_HOST_REST_UTL";

/
--------------------------------------------------------
--  DDL for Package Body DB_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."DB_REST_UTL" AS

    PROCEDURE dbpatchhistory_upd (
        p_id             IN               VARCHAR2,
        p_db_home        IN               VARCHAR2,
        p_host_name      IN               VARCHAR2,
        p_psu_number     IN               VARCHAR2,
        p_psu_quarter    IN               VARCHAR2,
        p_psu_year       IN               VARCHAR2,
        p_patch_type     IN               VARCHAR2,
        p_host_code      IN               VARCHAR2,
        p_patch_status   IN               VARCHAR2
    ) IS
    BEGIN
        UPDATE charter2_inv.v_db_patch_history
        SET
            db_home = nvl(p_db_home, db_home),
            psu_number = nvl(p_psu_number, psu_number),
            psu_quarter = nvl(p_psu_quarter, psu_quarter),
            psu_year = nvl(p_psu_year, psu_year),
            patch_type = nvl(p_patch_type, patch_type),
            host_code = nvl(p_host_code, host_code),
            host_name = nvl(p_host_name, host_name),
            patch_status = nvl(p_patch_status, patch_status)
        WHERE
            id = p_id;

    END dbpatchhistory_upd;

    PROCEDURE dbpatchhistory_ins (
        p_id             OUT              NUMBER,
        p_db_home        IN               VARCHAR2 DEFAULT NULL,
        p_psu_number     IN               VARCHAR2 DEFAULT NULL,
        p_psu_quarter    IN               VARCHAR2 DEFAULT NULL,
        p_psu_year       IN               VARCHAR2 DEFAULT NULL,
        p_patch_type     IN               VARCHAR2 DEFAULT NULL,
        p_host_code      IN               VARCHAR2 DEFAULT NULL,
        p_host_name      IN               VARCHAR2 DEFAULT NULL,
        p_patch_status   IN               VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO charter2_inv.v_db_patch_history (
            db_home,
            psu_number,
            psu_quarter,
            psu_year,
            patch_type,
            host_code,
            host_name,
            patch_status
        ) VALUES (
            p_db_home,
            p_psu_number,
            p_psu_quarter,
            p_psu_year,
            p_patch_type,
            p_host_code,
            p_host_name,
            p_patch_status
        ) RETURNING id INTO p_id;

    END dbpatchhistory_ins;

    PROCEDURE lsinventory_upd (
        p_id          IN            VARCHAR2,
        p_ls_invent   IN            BLOB DEFAULT NULL
    ) IS
    BEGIN
        UPDATE v_db_patch_history
        SET
            ls_invent = p_ls_invent
        WHERE
            id = p_id;

    END;

    PROCEDURE dbpatchlog_upd (
        p_id          IN            VARCHAR2,
        p_patch_log   IN            BLOB DEFAULT NULL
    ) IS
    BEGIN
        UPDATE v_db_patch_history
        SET
            patch_log = patch_log
        WHERE
            id = p_id;

    END;

    PROCEDURE dbchecklist_upd (
        p_id                      IN                        NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2,
        p_task_desc               IN                        VARCHAR2
    ) IS
    BEGIN
        UPDATE charter2_inv.v_db_check_list
        SET
            checklist_type = nvl(p_checklist_type, checklist_type),
            post_build_status = nvl(p_post_build_status, post_build_status),
            cluster_verify = nvl(p_cluster_verify, cluster_verify),
            gi_install_status = nvl(p_gi_install_status, gi_install_status),
            db_install_status = nvl(p_db_install_status, db_install_status),
            db_upgrade_status = nvl(p_db_upgrade_status, db_upgrade_status),
            gi_upgrade_status = nvl(p_gi_upgrade_status, gi_upgrade_status),
            migration_status = nvl(p_migration_status, migration_status),
            post_migration_status = nvl(p_post_migration_status, post_migration_status),
            checklist_category = nvl(p_checklist_category, checklist_category),
            db_name = nvl(p_db_name, db_name),
            host_name = nvl(p_host_name, host_name),
            cluster_name = nvl(p_cluster_name, cluster_name),
            task_desc = nvl(p_task_desc, task_desc)
        WHERE
            check_list_id = p_id;

    END;

    PROCEDURE dbchecklist_upd2 (
        p_id                      IN                        NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2
    ) IS
    BEGIN
        UPDATE charter2_inv.v_db_check_list
        SET
            checklist_type = nvl(p_checklist_type, checklist_type),
            post_build_status = nvl(p_post_build_status, post_build_status),
            cluster_verify = nvl(p_cluster_verify, cluster_verify),
            gi_install_status = nvl(p_gi_install_status, gi_install_status),
            db_install_status = nvl(p_db_install_status, db_install_status),
            db_upgrade_status = nvl(p_db_upgrade_status, db_upgrade_status),
            gi_upgrade_status = nvl(p_gi_upgrade_status, gi_upgrade_status),
            migration_status = nvl(p_migration_status, migration_status),
            post_migration_status = nvl(p_post_migration_status, post_migration_status),
            checklist_category = nvl(p_checklist_category, checklist_category),
            db_name = nvl(p_db_name, db_name),
            host_name = nvl(p_host_name, host_name),
            cluster_name = nvl(p_cluster_name, cluster_name)
        WHERE
            check_list_id = p_id;

    END;
    
    PROCEDURE dbchecklist_ins (
        p_id                      OUT                       NUMBER,
        p_checklist_type          IN                        VARCHAR2,
        p_post_build_status       IN                        VARCHAR2,
        p_cluster_verify          IN                        VARCHAR2,
        p_gi_install_status       IN                        VARCHAR2,
        p_db_install_status       IN                        VARCHAR2,
        p_db_upgrade_status       IN                        VARCHAR2,
        p_gi_upgrade_status       IN                        VARCHAR2,
        p_migration_status        IN                        VARCHAR2,
        p_post_migration_status   IN                        VARCHAR2,
        p_checklist_category      IN                        VARCHAR2,
        p_db_name                 IN                        VARCHAR2,
        p_cluster_name            IN                        VARCHAR2,
        p_host_name               IN                        VARCHAR2,
        p_task_desc               IN                        VARCHAR2,
        p_ticket_ref              IN                        VARCHAR2
    ) IS
    BEGIN
        INSERT INTO charter2_inv.v_db_check_list (
            checklist_type,
            post_build_status,
            cluster_verify,
            gi_install_status,
            db_install_status,
            db_upgrade_status,
            gi_upgrade_status,
            migration_status,
            post_migration_status,
            checklist_category,
            db_name,
            host_name,
            cluster_name,
            task_desc,
            ticket_ref
        ) VALUES (
            p_checklist_type,
            p_post_build_status,
            p_cluster_verify,
            p_gi_install_status,
            p_db_install_status,
            p_db_upgrade_status,
            p_gi_upgrade_status,
            p_migration_status,
            p_post_migration_status,
            p_checklist_category,
            p_db_name,
            p_host_name,
            p_cluster_name,
            p_task_desc,
            p_ticket_ref
        ) RETURNING check_list_id INTO p_id;

    END;

    PROCEDURE dbchecklistlogs_ins (
        p_check_list_id   IN                VARCHAR2,
        p_log_file        IN                BLOB,
        p_file_type       IN                VARCHAR2,
        p_mime_type       IN                VARCHAR2,
        p_log_file_desc   IN                VARCHAR2
    ) IS
    BEGIN
        INSERT INTO v_check_list_logs (
            check_list_id,
            log_file,
            file_type,
            mime_type,
            log_file_desc
        ) VALUES (
            p_check_list_id,
            p_log_file,
            p_file_type,
            p_mime_type,
            p_log_file_desc
        );

    END;

    PROCEDURE dbinventory_upd (
        p_id                    IN                      NUMBER,
        p_database_name         IN                      VARCHAR2 DEFAULT NULL,
        p_application_name      IN                      VARCHAR2 DEFAULT NULL,
        p_environment           IN                      VARCHAR2 DEFAULT NULL,
        --p_host_name                    in varchar2 default null,
        p_oracle_version        IN                      VARCHAR2 DEFAULT NULL,
        --p_rac_enabled                  in varchar2 default null,
        p_rac_type              IN                      VARCHAR2 DEFAULT NULL,
        p_business_unit         IN                      VARCHAR2 DEFAULT NULL,
        --p_cluster_name                 in varchar2 default null,
        --p_clustered                    in number default null,
        p_appliance             IN                      VARCHAR2 DEFAULT NULL,
        p_database_role         IN                      VARCHAR2 DEFAULT NULL,
        p_pci_required          IN                      VARCHAR2 DEFAULT NULL,
        p_sox_required          IN                      VARCHAR2 DEFAULT NULL,
        p_encryption_required   IN                      VARCHAR2 DEFAULT NULL,
        p_dataguard             IN                      VARCHAR2 DEFAULT NULL,
        p_golden_gate           IN                      VARCHAR2 DEFAULT NULL,
        p_backup_enabled        IN                      VARCHAR2 DEFAULT NULL,
        p_end_of_life           IN                      VARCHAR2 DEFAULT NULL,
        p_db_monitoring_tool    IN                      VARCHAR2 DEFAULT NULL,
        p_monitoring            IN                      VARCHAR2 DEFAULT NULL,
        p_comments              IN                      VARCHAR2 DEFAULT NULL,
        p_instance_count        IN                      NUMBER DEFAULT NULL,
        p_db_source             IN                      VARCHAR2 DEFAULT NULL,
        --p_db_id                        in number default null,
        p_dr_solution           IN                      VARCHAR2 DEFAULT NULL,
        p_dr_location           IN                      VARCHAR2 DEFAULT NULL,
        p_env_category          IN                      VARCHAR2 DEFAULT NULL,
        p_host_code             IN                      VARCHAR2 DEFAULT NULL,
        p_app_id                IN                      NUMBER DEFAULT NULL,
        p_storage_type          IN                      VARCHAR2 DEFAULT NULL,
        p_db_home               IN                      VARCHAR2 DEFAULT NULL,
        p_decommisioned                in varchar2 default null
    ) IS
    BEGIN
        UPDATE charter2_inv.v_db_inventory
        SET
            --id = p_id,
            database_name = nvl(p_database_name, database_name),
            application_name = nvl(p_application_name, application_name),
            environment = nvl(p_environment, environment),
            --host_name = p_host_name,
            oracle_version = nvl(p_oracle_version, oracle_version),
            --rac_enabled = p_rac_enabled,
            rac_type = nvl(p_rac_type, rac_type),
            business_unit = nvl(p_business_unit, business_unit),
            --cluster_name = p_cluster_name,
            --clustered = p_clustered,
            appliance = nvl(p_appliance, appliance),
            database_role = nvl(p_database_role, database_role),
            pci_required = nvl(p_pci_required, pci_required),
            sox_required = nvl(p_sox_required, sox_required),
            encryption_required = nvl(p_encryption_required, encryption_required),
            dataguard = nvl(p_dataguard, dataguard),
            golden_gate = nvl(p_golden_gate, golden_gate),
            backup_enabled = nvl(p_backup_enabled, backup_enabled),
            end_of_life = nvl(p_end_of_life, end_of_life),
            db_monitoring_tool = nvl(p_db_monitoring_tool, db_monitoring_tool),
            monitoring = nvl(p_monitoring, monitoring),
            comments = nvl(p_comments, comments),
            instance_count = nvl(p_instance_count, instance_count),
            db_source = nvl(p_db_source, db_source),
            --db_id = p_db_id,
            dr_solution = nvl(p_dr_solution, dr_solution),
            dr_location = nvl(p_dr_location, dr_location),
            env_category = nvl(p_env_category, env_category),
            v_host_code = nvl(p_host_code, v_host_code),
            app_id = nvl(p_app_id, app_id),
            storage_type = nvl(p_storage_type, storage_type),
            db_home = nvl(p_db_home, db_home),
            decommisioned = nvl(p_decommisioned, decommisioned)
        WHERE
            id = p_id;

    END dbinventory_upd;

    PROCEDURE dbinventory_ins (
        p_id                    OUT                     NUMBER,
        p_database_name         IN                      VARCHAR2,
        p_application_name      IN                      VARCHAR2,
        p_environment           IN                      VARCHAR2,
        p_oracle_version        IN                      VARCHAR2,
        p_rac_type              IN                      VARCHAR2,
        p_business_unit         IN                      VARCHAR2,
        p_appliance             IN                      VARCHAR2,
        p_database_role         IN                      VARCHAR2,
        p_pci_required          IN                      VARCHAR2,
        p_sox_required          IN                      VARCHAR2,
        p_encryption_required   IN                      VARCHAR2,
        p_dataguard             IN                      VARCHAR2,
        p_golden_gate           IN                      VARCHAR2,
        p_backup_enabled        IN                      VARCHAR2,
        p_end_of_life           IN                      VARCHAR2,
        p_db_monitoring_tool    IN                      VARCHAR2,
        p_monitoring            IN                      VARCHAR2,
        p_comments              IN                      VARCHAR2,
        p_instance_count        IN                      NUMBER,
        p_db_source             IN                      VARCHAR2,
        p_dr_solution           IN                      VARCHAR2,
        p_dr_location           IN                      VARCHAR2,
        p_env_category          IN                      VARCHAR2,
        p_app_id                IN                      NUMBER,
        p_storage_type          IN                      VARCHAR2,
        p_cluster_name          IN                      VARCHAR2,
        p_host_name             IN                      VARCHAR2,
        p_db_home               IN                      VARCHAR2,
        p_decommisioned         in varchar2 default null
    ) IS
        p_exists      NUMBER;
        p_host_code   VARCHAR2(100);
    BEGIN
        IF p_cluster_name IS NOT NULL THEN
            SELECT
                MAX(v_host_code)
            INTO p_host_code
            FROM
                v_cluster_member_tbl
            WHERE
                cluster_name = p_cluster_name;

        ELSE
            SELECT
                MAX(host_code)
            INTO p_host_code
            FROM
                v_host_inv_tbl
            WHERE
                host_name = p_host_name;

        END IF;

        SELECT
            COUNT(*),
            MAX(id)
        INTO
            p_exists,
            p_id
        FROM
            charter2_inv.v_db_inventory
        WHERE
            database_name = p_database_name
            AND v_host_code = p_host_code;

        IF nvl(p_exists, 0) <= 0 THEN
            INSERT INTO charter2_inv.v_db_inventory (
                database_name,
                application_name,
                environment,
                oracle_version,
                rac_type,
                business_unit,
                appliance,
                database_role,
                pci_required,
                sox_required,
                encryption_required,
                dataguard,
                golden_gate,
                backup_enabled,
                end_of_life,
                db_monitoring_tool,
                monitoring,
                comments,
                instance_count,
                db_source,
                dr_solution,
                dr_location,
                env_category,
                v_host_code,
                app_id,
                storage_type,
                db_home,
                decommisioned
            ) VALUES (
                p_database_name,
                p_application_name,
                p_environment,
                p_oracle_version,
                p_rac_type,
                p_business_unit,
                p_appliance,
                p_database_role,
                p_pci_required,
                p_sox_required,
                p_encryption_required,
                p_dataguard,
                p_golden_gate,
                p_backup_enabled,
                p_end_of_life,
                p_db_monitoring_tool,
                p_monitoring,
                p_comments,
                p_instance_count,
                p_db_source,
                p_dr_solution,
                p_dr_location,
                p_env_category,
                p_host_code,
                p_app_id,
                p_storage_type,
                p_db_home,
                p_decommisioned
            ) RETURNING id INTO p_id;

        END IF;

    END dbinventory_ins;


    procedure dbschedule_upd  (
        p_id                           in number,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    )
    is
    begin
        update  charter2_inv.v_db_schedule_tbl set
            db_id = nvl(p_db_id,db_id),
            upgrade_start_date = nvl(p_upgrade_start_date,upgrade_start_date),
            upgrade_end_date = nvl(p_upgrade_end_date,upgrade_end_date),
            migration_start_date = nvl(p_migration_start_date,migration_start_date),
            migration_end_date = nvl(p_migration_end_date,migration_end_date),
            upgrade_completion_time = nvl(p_upgrade_completion_time ,upgrade_completion_time),
            migration_completion_time =  nvl(p_migration_completion_time, migration_completion_time),
            migration_method = nvl(p_migration_method,migration_method),
            outage_window = nvl(p_outage_window,outage_window),
            comments = nvl(p_comments,comments)
        where id = p_id;
    end dbschedule_upd;

    procedure dbschedule_ins  (
        p_id                           out number  ,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    )
    is
    begin
        insert into charter2_inv.v_db_schedule_tbl (
            db_id,
            upgrade_start_date,
            upgrade_end_date,
            migration_start_date,
            migration_end_date,
            upgrade_completion_time,
            migration_completion_time,
            migration_method,
            outage_window,
            comments
        ) values (
            p_db_id,
            p_upgrade_start_date,
            p_upgrade_end_date,
            p_migration_start_date,
            p_migration_end_date,
            p_upgrade_completion_time  ,
            p_migration_completion_time ,
            p_migration_method,
            p_outage_window,
            p_comments
        ) RETURNING id into p_id ;
    end dbschedule_ins;    
    
END db_rest_utl;

/
--------------------------------------------------------
--  DDL for Package Body EBA_RESTDEMO_SAMPLE_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_PKG" is
function get_github_repos(
    p_max_rows in number default 10000 ) return eba_restdemo_github_repo_ct pipelined
is
    l_context     apex_exec.t_context;
    l_filters     apex_exec.t_filters;
    l_columns     apex_exec.t_columns;
     
    l_row         pls_integer := 1;
    l_name_idx    pls_integer;
    l_lang_idx    pls_integer;
    l_desc_idx    pls_integer;
    l_upd_idx     pls_integer;
    l_cr_idx      pls_integer;
    l_issues_idx  pls_integer;
begin
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'NAME'        );
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'LANGUAGE'    );
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'DESCRIPTION' );
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'UPDATED_AT'  );
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'CREATED_AT'  );
    apex_exec.add_column(
        p_columns        => l_columns,
        p_column_name    => 'OPEN_ISSUES_COUNT'  );
    l_context := apex_exec.open_web_source_query(
        p_module_static_id  => 'Sample_Application_Github_Repositories',
        p_columns           => l_columns,
        p_max_rows          => p_max_rows );
    l_name_idx   := apex_exec.get_column_position( l_context, 'NAME'        );
    l_lang_idx   := apex_exec.get_column_position( l_context, 'LANGUAGE'    );
    l_desc_idx   := apex_exec.get_column_position( l_context, 'DESCRIPTION' );
    l_upd_idx    := apex_exec.get_column_position( l_context, 'UPDATED_AT'  );
    l_cr_idx     := apex_exec.get_column_position( l_context, 'CREATED_AT'  );
    l_issues_idx := apex_exec.get_column_position( l_context, 'OPEN_ISSUES_COUNT'  );
    while apex_exec.next_row( l_context ) loop
        pipe row( eba_restdemo_github_repo_t( 
            apex_exec.get_varchar2    ( l_context, l_name_idx ), 
            apex_exec.get_varchar2    ( l_context, l_lang_idx ), 
            apex_exec.get_varchar2    ( l_context, l_desc_idx ), 
            apex_exec.get_timestamp_tz( l_context, l_upd_idx ), 
            apex_exec.get_timestamp_tz( l_context, l_cr_idx ), 
            apex_exec.get_number      ( l_context, l_issues_idx )));
        l_row := l_row + 1;
    end loop;
    
    apex_exec.close( l_context );
    return;
exception
    when others then
    apex_exec.close( l_context );
    raise;    
end get_github_repos;
procedure test_all is
begin
   for i in (select name, url, https_host from eba_restdemo_sample_urls ) loop
       update eba_restdemo_sample_urls 
          set last_status = test_url( i.url, i.https_host )
        where name = i.name;
   end loop;
end test_all;
function test_url( p_url in varchar2, p_https_host in varchar2 ) return varchar2 is
    l_clob clob;
    l_result varchar2(255);
begin
    begin
        sys.utl_http.set_detailed_excp_support(true);
        apex_web_service.g_request_headers.delete;
        apex_web_service.g_request_headers( 1 ).name  := 'User-Agent';
        apex_web_service.g_request_headers( 1 ).value := 'Oracle Application Express';
    
        l_clob := apex_web_service.make_rest_request( p_url, 'GET', p_https_host => p_https_host, p_transfer_timeout => 15 );
        if apex_web_service.g_status_code between 200 and 399 then
            l_result := 'OK';
        else
            l_result := 'ERROR_HTTP-' || apex_web_service.g_status_code;
        end if;
    exception
        when others then
            if sqlcode = -24247 then l_result := 'ERROR_ACL';
            elsif sqlcode = -29024 then l_result := 'ERROR_CERT';
            elsif sqlcode = -12535 then l_result := 'ERROR_NETWORK';
            else l_result := 'ERROR_OTHER_' || sqlerrm;
            end if;
    end;
    return l_result;
end test_url;
end eba_restdemo_sample_pkg;

/
--------------------------------------------------------
--  DDL for Package Body ITSM_UTILITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."ITSM_UTILITY" AS


  procedure LOAD_ITSM_DATA(p_action in varchar2 default 'LOAD',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
)  AS

    l_clob           CLOB;
    v_id             NUMBER;
    v_url            VARCHAR2(1000) ;
    v_status         VARCHAR2(1000);
   /* p_username       VARCHAR2(255) ;
    p_password       VARCHAR2(255) ;
    g_endpoint_prefix  VARCHAR2(1000);
    g_wallet_path    VARCHAR2(255) := 'file:/home/oracle/app/oracle/product/12.2.0/dbhome_1/user';
    g_wallet_pass    VARCHAR2(255) := 'oracle123';
    g_content_type   VARCHAR2(255) := 'application/json';
    g_itsm_url  VARCHAR2(1000); */
     l_finish       boolean          := false;
     next_url varchar2(1000);
     l_run_id number := to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
     l_table_interface varchar2(255) := nvl(upper(p_parm1),'ALL');
    BEGIN
    -- Purpose:
    -- Load ITSM into Data tables so that we can use them to create LOVs and update appliction info
    -- The Procedure make Rest calls to extract and import data
    --  It takes the results and loads them into tables, Only add records that are missing, 
    -- So  it can be called reptable in case we need to refresh Could add deletes to the tables..    
     --  https://onepointdemo.service-now.com/api/now/table/cmdb_ci_appl
     --  https://onepointdemo.service-now.com/api/now/table/sys_user
     --  https://onepointdemo.service-now.com/api/now/table/sys_user_group

     -- Get the config for the Service now install     
     config ('INIT_SNOW');
 /*    p_username :=ITSM_UTILITY.p_username;
     p_password := ITSM_UTILITY.p_password;
     g_wallet_path   := ITSM_UTILITY.g_wallet_path ;
     g_wallet_pass  := ITSM_UTILITY.g_wallet_pass;
     g_endpoint_prefix  := ITSM_UTILITY.g_endpoint_prefix;
     g_itsm_url := ITSM_UTILITY.g_itsm_url;
     --If the URl ends in / then remove it as the next URLs begin with the /
 */
     if  substr(g_itsm_url,-1) = '/' then
        g_itsm_url := substr(g_itsm_url,1,length(g_itsm_url) -1 );
     end if;   
    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type; --'application/json'; 


if p_action = 'LOAD' then

 if l_table_interface in ('ALL','CI_APPL') then
   delete from v_itsm_ci_appl; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'cmdb_ci_appl';
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

INSERT INTO v_itsm_ci_appl (
    name,
    sys_id,
    owned_by_sys_id,
    managed_by_sys_id,
    u_application_id,
    company,
    used_for,
    unverified,
    install_directory,
    install_date,
    asset_tag,
    operational_status,
    change_control_group,
    delivery_date,
    install_status,
    subcategory,
    assignment_group,
    edition,
    po_number,
    department,
    comments,
    gl_account,
    invoice_number,
    warranty_expiration,
    cost_cc,
    order_date,
    schedule,
    due,
    location,
    category,
    lease_id,
    u_vrr_rating,
    u_sciencelogic_correlation,
    u_sciencelogic_id,
    u_data_category,
    u_sciencelogic_status,
    u_data_classification,
    u_ip_netmask,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
)
select
    name,
    sys_id,
    owned_by_sys_id,
    managed_by_sys_id,
    u_application_id,
    company,
    used_for,
    unverified,
    install_directory,
    install_date,
    asset_tag,
    operational_status,
    change_control_group,
    delivery_date,
    install_status,
    subcategory,
    assignment_group,
    edition,
    po_number,
    department,
    comments,
    gl_account,
    invoice_number,
    warranty_expiration,
    cost_cc,
    order_date,
    schedule,
    due,
    location,
    category,
    lease_id,
    u_vrr_rating,
    u_sciencelogic_correlation,
    u_sciencelogic_id,
    u_data_category,
    u_sciencelogic_status,
    u_data_classification,
    u_ip_netmask,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%appl%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
     name VARCHAR2(1000) PATH 'name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , owned_by_sys_id VARCHAR2(255) PATH 'owned_by/value'
    , managed_by_sys_id VARCHAR2(255) PATH 'managed_by/value'    
    , u_application_id VARCHAR2(255) PATH 'u_application_id'
    , company VARCHAR2(255) PATH 'company'
    , used_for VARCHAR2(255) PATH 'used_for'
    , unverified VARCHAR2(255) PATH 'unverified'
    , install_directory VARCHAR2(255) PATH 'install_directory'
    , install_date VARCHAR2(255) PATH 'install_date'
    , asset_tag VARCHAR2(255) PATH 'asset_tag'
    , operational_status VARCHAR2(255) PATH 'operational_status'
    , change_control_group VARCHAR2(255) PATH 'change_control/value'
    , delivery_date VARCHAR2(255) PATH 'delivery_date'
    , install_status VARCHAR2(255) PATH 'install_status'
    , subcategory VARCHAR2(255) PATH 'subcategory'
    , assignment_group VARCHAR2(255) PATH 'assignment_group'
    , edition VARCHAR2(255) PATH 'edition'
    , po_number VARCHAR2(255) PATH 'po_number'
    , department VARCHAR2(255) PATH 'department'
    , comments VARCHAR2(255) PATH 'comments'
    , gl_account VARCHAR2(255) PATH 'gl_account'
    , invoice_number VARCHAR2(255) PATH 'invoice_number'
    , warranty_expiration VARCHAR2(255) PATH 'warranty_expiration'
    , cost_cc VARCHAR2(255) PATH 'cost_cc'
    , order_date VARCHAR2(255) PATH 'order_date'
    , schedule VARCHAR2(255) PATH 'schedule'
    , due VARCHAR2(255) PATH 'due'
    , location VARCHAR2(255) PATH 'location'
    , category VARCHAR2(255) PATH 'category'
    , lease_id VARCHAR2(255) PATH 'lease_id'
    , u_vrr_rating VARCHAR2(255) PATH 'u_vrr_rating'
    , u_sciencelogic_correlation VARCHAR2(255) PATH 'u_sciencelogic_correlation'
    , u_sciencelogic_id VARCHAR2(255) PATH 'u_sciencelogic_id'
    , u_data_category VARCHAR2(255) PATH 'u_data_category'
    , u_sciencelogic_status VARCHAR2(255) PATH 'u_sciencelogic_status'
    , u_data_classification VARCHAR2(255) PATH 'u_data_classification'
    , u_ip_netmask VARCHAR2(255) PATH 'u_ip_netmask'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    ) x
;

end if; 


 if l_table_interface in ('ALL','USER','SYS_USER_GROUP') then
  delete from v_itsm_sys_user_group; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'sys_user_group';
--https://onepointdemo.service-now.com/api/now/table/sys_user_group
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

INSERT INTO v_itsm_sys_user_group (
    sys_id,
    name,
    active,
    manager,
    company,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
) 
select
x.sys_id,
    x.name,
    x.active,
    x.manager,
    x.company,
    x.sys_created_by,
    x.sys_created_on,
    x.sys_updated_by,
    x.sys_updated_on
from
(SELECT
    request_id,
    request_type,
    call_url,
    response,
    created,
    created_by,
    updated,
    updated_by,
    body
FROM
    v_itsm_api_result
 where
 call_url like '%sys_user_group%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
    sys_id VARCHAR2(255) PATH 'sys_id'
    , name VARCHAR2(1000) PATH 'name'
    , active VARCHAR2(255) PATH 'active'
    , manager VARCHAR2(255) PATH 'manager'
    , company VARCHAR2(255) PATH 'company'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    ) x;
 end if; 
 
 
 if l_table_interface in ('ALL','USER','SYS_USER') then
  delete from v_itsm_sys_user; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'sys_user';
--https://onepointdemo.service-now.com/api/now/table/sys_user_group
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

 INSERT INTO v_itsm_sys_user (
    name,
    first_name,
    last_name,
    sys_id,
    vip,
    street,
    city,
    state,
    zip,
    active,
    mobile_phone,
    phone,
    home_phone,
    title,
    cost_center,
    employee_number,
    email,
    gender,
    user_name,
    company,
    department,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
)
select
    name,
    first_name,
    last_name,
    sys_id,
    vip,
    street,
    city,
    state,
    zip,
    active,
    mobile_phone,
    phone,
    home_phone,
    title,
    cost_center,
    employee_number,
    email,
    gender,
    user_name,
    company,
    department,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%sys_user'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
     name VARCHAR2(255) PATH 'name'
    , first_name VARCHAR2(255) PATH 'first_name'
    , last_name VARCHAR2(255) PATH 'last_name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , vip VARCHAR2(255) PATH 'vip'
    , street VARCHAR2(1000) PATH 'street'
    , city VARCHAR2(255) PATH 'city'
    , state VARCHAR2(255) PATH 'state'
    , zip VARCHAR2(255) PATH 'zip'
    , active VARCHAR2(255) PATH 'active'
    , mobile_phone VARCHAR2(255) PATH 'mobile_phone'
    , phone VARCHAR2(255) PATH 'home'
    , home_phone VARCHAR2(255) PATH 'home_phone'
    , title VARCHAR2(255) PATH 'title'
    , cost_center VARCHAR2(255) PATH 'cost_center'
    , employee_number VARCHAR2(255) PATH 'employee_number'
    , email VARCHAR2(255) PATH 'email'
    , gender VARCHAR2(255) PATH 'gender'
    , user_name VARCHAR2(255) PATH 'user_name'
    , company VARCHAR2(255) PATH 'company'
    , department VARCHAR2(255) PATH 'department'    
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    ) x
;

 end if;
 if l_table_interface in ('ALL','USER','SYS_USER_GRMEMBER') then

  delete from v_itsm_sys_user_grmember; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'sys_user_grmember';
--https://onepointdemo.service-now.com/api/now/table/sys_user_group
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

 INSERT INTO v_itsm_sys_user_grmember (
   user_sys_id
    ,group_sys_id 
    , sys_created_by
    , sys_created_on
    , sys_updated_by
    , sys_updated_on
)
select
   user_sys_id
    ,group_sys_id 
    , sys_created_by
    , sys_created_on
    , sys_updated_by
    , sys_updated_on
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%sys_user_grmember%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
    user_sys_id VARCHAR2(255) PATH 'user/value'
    ,group_sys_id VARCHAR2(255) PATH 'group/value'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    ) x
;

end if;

 if l_table_interface in ('ALL','REQUEST','SC_REQUEST') then

  delete from v_itsm_sc_request; 

  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'sc_request';
--https://onepointdemo.service-now.com/api/now/table/sc_request?sysparm_query=assignment_group=db520ed1db9763408ccd89584b961950
--  while not l_finish loop
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;
   
   INSERT INTO v_itsm_sc_request (
    name,
    sys_id,
    ticket_id,
    description,
    assignment_group,
    state,
    closed_at,
    active,
    priority,
    business_service,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    short_description,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    assigned_to,
    comments,
    approval,
    sla_due,
    comments_and_work_notes,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
) 
select
    name,
    sys_id,
    ticket_id,
    description,
    assignment_group,
    state,
    closed_at,
    active,
    priority,
    business_service,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    short_description,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    assigned_to,
    comments,
    approval,
    sla_due,
    comments_and_work_notes,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%sc_request%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
      name VARCHAR2(1000) PATH 'name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , ticket_id VARCHAR2(255) PATH 'number'
    , description clob PATH 'description'
    , assignment_group VARCHAR2(255) PATH 'assignment_group/value'
    , state VARCHAR2(255) PATH 'state'
    , closed_at VARCHAR2(255) PATH 'closed_at'
    , active VARCHAR2(255) PATH 'active'
    , priority VARCHAR2(255) PATH 'priority'
    , business_service VARCHAR2(255) PATH 'business_service'
    , opened_at VARCHAR2(255) PATH 'opened_at'
    , parent VARCHAR2(255) PATH 'parent'
    , special_instructions VARCHAR2(4000) PATH 'special_instructions'
    , work_notes clob PATH 'work_notes'
    , short_description VARCHAR2(4000) PATH 'short_description'
    , work_start VARCHAR2(255) PATH 'work_start'
    , work_notes_list VARCHAR2(255) PATH 'work_notes_list'
    , company VARCHAR2(255) PATH 'company'
    , requested_date VARCHAR2(255) PATH 'requested_date'
    , urgency VARCHAR2(255) PATH 'urgency'
    , contact_type VARCHAR2(255) PATH 'contact_type'
    , closed_by VARCHAR2(255) PATH 'closed_by'
    , close_notes VARCHAR2(255) PATH 'close_notes'
    , assigned_to VARCHAR2(255) PATH 'assigned_to'
    , comments clob PATH 'comments'
    , approval VARCHAR2(255) PATH 'approval'
    , sla_due VARCHAR2(255) PATH 'sla_due'
    , comments_and_work_notes clob PATH 'comments_and_work_notes'
    , due_date VARCHAR2(255) PATH 'due_date'
    , request_state VARCHAR2(255) PATH 'request_state'
    , stage VARCHAR2(255) PATH 'stage'
    , escalation VARCHAR2(255) PATH 'escalation'
    , upon_approval VARCHAR2(255) PATH 'upon_approval'
    , opened_by VARCHAR2(255) PATH 'opened_by/value'
    , skills VARCHAR2(255) PATH 'skills'
    , requested_for VARCHAR2(255) PATH 'requested_for/value'
    , made_sla VARCHAR2(255) PATH 'made_sla'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    , owned_by_sys_id VARCHAR2(255) PATH 'owned_by/value'
    , managed_by_sys_id VARCHAR2(255) PATH 'managed_by/value'    
    ) x;

end if;

 if l_table_interface in ('ALL','REQUEST','SC_REQ_ITEM') then

 delete from v_itsm_sc_req_item; 

  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'sc_req_item';
--https://onepointdemo.service-now.com/api/now/table/sc_request?sysparm_query=assignment_group=db520ed1db9763408ccd89584b961950
--  while not l_finish loop
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

INSERT INTO v_itsm_sc_req_item (
    name,
    sys_id,
    ticket_id,
    request_sys_id,
    short_description,
    description,
    assignment_group,
    state,
    closed_at,
    active,
    priority,
    business_service,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    assigned_to,
    comments,
    approval,
    sla_due,
    comments_and_work_notes,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
)
select
     name,
    sys_id,
    ticket_id,
    request_sys_id,
    short_description,
    description,
    assignment_group,
    state,
    closed_at,
    active,
    priority,
    business_service,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    assigned_to,
    comments,
    approval,
    sla_due,
    comments_and_work_notes,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
 from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%sc_req_item%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
      name VARCHAR2(1000) PATH 'name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , ticket_id VARCHAR2(255) PATH 'number'
    , request_sys_id VARCHAR2(255) PATH 'request/value'
    , short_description VARCHAR2(4000) PATH 'short_description'
    , description clob PATH 'description'
    , assignment_group VARCHAR2(255) PATH 'assignment_group/value'
    , state VARCHAR2(255) PATH 'state'
    , closed_at VARCHAR2(255) PATH 'closed_at'
    , active VARCHAR2(255) PATH 'active'
    , priority VARCHAR2(255) PATH 'priority'
    , business_service VARCHAR2(255) PATH 'business_service'
    , opened_at VARCHAR2(255) PATH 'opened_at'
    , parent VARCHAR2(255) PATH 'parent'
    , special_instructions VARCHAR2(4000) PATH 'special_instructions'
    , work_notes clob PATH 'work_notes'
    , work_start VARCHAR2(255) PATH 'work_start'
    , work_notes_list VARCHAR2(255) PATH 'work_notes_list'
    , company VARCHAR2(255) PATH 'company'
    , requested_date VARCHAR2(255) PATH 'requested_date'
    , urgency VARCHAR2(255) PATH 'urgency'
    , contact_type VARCHAR2(255) PATH 'contact_type'
    , closed_by VARCHAR2(255) PATH 'closed_by'
    , close_notes VARCHAR2(255) PATH 'close_notes'
    , assigned_to VARCHAR2(255) PATH 'assigned_to'
    , comments clob PATH 'comments'
    , approval VARCHAR2(255) PATH 'approval'
    , sla_due VARCHAR2(255) PATH 'sla_due'
    , comments_and_work_notes clob PATH 'comments_and_work_notes'
    , due_date VARCHAR2(255) PATH 'due_date'
    , request_state VARCHAR2(255) PATH 'request_state'
    , stage VARCHAR2(255) PATH 'stage'
    , escalation VARCHAR2(255) PATH 'escalation'
    , upon_approval VARCHAR2(255) PATH 'upon_approval'
    , opened_by VARCHAR2(255) PATH 'opened_by/value'
    , skills VARCHAR2(255) PATH 'skills'
    , requested_for VARCHAR2(255) PATH 'requested_for/value'
    , made_sla VARCHAR2(255) PATH 'made_sla'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    , owned_by_sys_id VARCHAR2(255) PATH 'owned_by/value'
    , managed_by_sys_id VARCHAR2(255) PATH 'managed_by/value'    

    ) x;

  end if;

 if l_table_interface in ('ALL','CHANGE_REQUEST') then

 delete from v_itsm_change_request; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'change_request';
--https://onepointdemo.service-now.com/api/now/table/change_request
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

INSERT INTO v_itsm_change_request (
    name,
    sys_id,
    change_id,
    description,
    test_plan,
    implementation_plan,
    change_plan,
    backout_plan,
    assignment_group,
    state,
    phase,
    impact,
    cmdb_ci_sys_id,
    closed_at,
    active,
    priority,
    production_system,
    requested_by,
    assigned_to,
    business_service,
    review_date,
    start_date,
    end_date,
    conflict_status,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    short_description,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    comments_and_work_notes,
    approval,
    sla_due,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
) select
    name,
    sys_id,
    change_id,
    description,
    test_plan,
    implementation_plan,
    change_plan,
    backout_plan,
    assignment_group,
    state,
    phase,
    impact,
    cmdb_ci_sys_id,
    closed_at,
    active,
    priority,
    production_system,
    requested_by,
    assigned_to,
    business_service,
    review_date,
    start_date,
    end_date,
    conflict_status,
    opened_at,
    parent,
    special_instructions,
    work_notes,
    short_description,
    work_start,
    work_notes_list,
    company,
    requested_date,
    urgency,
    contact_type,
    closed_by,
    close_notes,
    comments_and_work_notes,
    approval,
    sla_due,
    due_date,
    request_state,
    stage,
    escalation,
    upon_approval,
    opened_by,
    skills,
    requested_for,
    made_sla,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on,
    owned_by_sys_id,
    managed_by_sys_id
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%change_request%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
     name VARCHAR2(1000) PATH 'name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , change_id VARCHAR2(255) PATH 'number'
    , description VARCHAR2(255) PATH 'description'
    , test_plan VARCHAR2(1000) PATH 'test_plan'
    , implementation_plan VARCHAR2(1000) PATH 'implementation_plan'
    , change_plan VARCHAR2(1000) PATH 'change_plan'
    , backout_plan VARCHAR2(1000) PATH 'backout_plan'
    , assignment_group VARCHAR2(255) PATH 'assignment_group/value'
    , state VARCHAR2(255) PATH 'state'
    , phase VARCHAR2(255) PATH 'phase'
    , impact VARCHAR2(255) PATH 'impact'
    , cmdb_ci_sys_id VARCHAR2(255) PATH 'cmdb_ci/value'
    , closed_at VARCHAR2(255) PATH 'closed_at'
    , active VARCHAR2(255) PATH 'active'
    , priority VARCHAR2(255) PATH 'priority'
    , production_system VARCHAR2(255) PATH 'production_system'
    , requested_by VARCHAR2(255) PATH 'requested_by/value'
    , assigned_to VARCHAR2(255) PATH 'assigned_to/value'
    , business_service VARCHAR2(255) PATH 'business_service'
    , review_date VARCHAR2(255) PATH 'review_date'
    , start_date VARCHAR2(255) PATH 'start_date'
    , end_date VARCHAR2(255) PATH 'end_date'
    , conflict_status VARCHAR2(255) PATH 'conflict_status'
    , opened_at VARCHAR2(255) PATH 'opened_at'
    , parent VARCHAR2(255) PATH 'parent'
    , special_instructions VARCHAR2(255) PATH 'special_instructions'
    , work_notes VARCHAR2(255) PATH 'work_notes'
    , short_description VARCHAR2(255) PATH 'short_description'
    , work_start VARCHAR2(255) PATH 'work_start'
    , work_notes_list VARCHAR2(255) PATH 'work_notes_list'
    , company VARCHAR2(255) PATH 'company'
    , requested_date VARCHAR2(255) PATH 'requested_date'
    , urgency VARCHAR2(255) PATH 'urgency'
    , contact_type VARCHAR2(255) PATH 'contact_type'
    , closed_by VARCHAR2(255) PATH 'closed_by'
    , close_notes VARCHAR2(255) PATH 'close_notes'
    , comments_and_work_notes VARCHAR2(255) PATH 'comments_and_work_notes'
    , approval VARCHAR2(255) PATH 'approval'
    , sla_due VARCHAR2(255) PATH 'sla_due'
    , due_date VARCHAR2(255) PATH 'due_date'
    , request_state VARCHAR2(255) PATH 'request_state'
    , stage VARCHAR2(255) PATH 'stage'
    , escalation VARCHAR2(255) PATH 'escalation'
    , upon_approval VARCHAR2(255) PATH 'upon_approval'
    , opened_by VARCHAR2(255) PATH 'opened_by/value'
    , skills VARCHAR2(255) PATH 'skills'
    , requested_for VARCHAR2(255) PATH 'requested_for/value'
    , made_sla VARCHAR2(255) PATH 'made_sla'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    , owned_by_sys_id VARCHAR2(255) PATH 'owned_by/value'
    , managed_by_sys_id VARCHAR2(255) PATH 'managed_by/value'    
    ) x;

 end if;
 
  if l_table_interface in ('ALL','CMDB_CI') then

   delete from v_itsm_cmdb_ci; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'cmdb_ci';
--https://onepointdemo.service-now.com/api/now/table/change_request
--  while not l_finish loop
  
      do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RUN_ID => l_run_id,
       P_RESPONSE => l_clob) ; 

   -- 
   --Added a commit for tracing
   --
   commit;

INSERT INTO v_itsm_cmdb_ci (
    name,
    sys_id,
    owned_by_sys_id,
    managed_by_sys_id,
    u_application_id,
    company,
    used_for,
    unverified,
    install_directory,
    install_date,
    asset_tag,
    operational_status,
    change_control_group,
    delivery_date,
    install_status,
    subcategory,
    assignment_group,
    edition,
    po_number,
    department,
    comments,
    gl_account,
    invoice_number,
    warranty_expiration,
    cost_cc,
    order_date,
    schedule,
    due,
    location,
    category,
    lease_id,
    ip_address,
    u_vrr_rating,
    u_sciencelogic_correlation,
    u_sciencelogic_id,
    u_data_category,
    u_sciencelogic_status,
    u_data_classification,
    u_ip_netmask,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
)
select
    name,
    sys_id,
    owned_by_sys_id,
    managed_by_sys_id,
    u_application_id,
    company,
    used_for,
    unverified,
    install_directory,
    install_date,
    asset_tag,
    operational_status,
    change_control_group,
    delivery_date,
    install_status,
    subcategory,
    assignment_group,
    edition,
    po_number,
    department,
    comments,
    gl_account,
    invoice_number,
    warranty_expiration,
    cost_cc,
    order_date,
    schedule,
    due,
    location,
    category,
    lease_id,
    ip_address,
    u_vrr_rating,
    u_sciencelogic_correlation,
    u_sciencelogic_id,
    u_data_category,
    u_sciencelogic_status,
    u_data_classification,
    u_ip_netmask,
    sys_created_by,
    sys_created_on,
    sys_updated_by,
    sys_updated_on
from
(SELECT
    response
FROM
    v_itsm_api_result
 where
 call_url like '%cmdb_ci%'
 and run_id = l_run_id
 )tp
 , XMLTABLE(
    '/json/result/row' PASSING apex_json.to_xmltype(tp.response) 
    COLUMNS 
     name VARCHAR2(1000) PATH 'name'
    ,sys_id VARCHAR2(255) PATH 'sys_id'
    , owned_by_sys_id VARCHAR2(255) PATH 'owned_by/value'
    , managed_by_sys_id VARCHAR2(255) PATH 'managed_by/value'    
    , u_application_id VARCHAR2(255) PATH 'u_application_id'
    , company VARCHAR2(255) PATH 'company'
    , used_for VARCHAR2(255) PATH 'used_for'
    , unverified VARCHAR2(255) PATH 'unverified'
    , install_directory VARCHAR2(255) PATH 'install_directory'
    , install_date VARCHAR2(255) PATH 'install_date'
    , asset_tag VARCHAR2(255) PATH 'asset_tag'
    , operational_status VARCHAR2(255) PATH 'operational_status'
    , change_control_group VARCHAR2(255) PATH 'change_control/value'
    , delivery_date VARCHAR2(255) PATH 'delivery_date'
    , install_status VARCHAR2(255) PATH 'install_status'
    , subcategory VARCHAR2(255) PATH 'subcategory'
    , assignment_group VARCHAR2(255) PATH 'assignment_group'
    , edition VARCHAR2(255) PATH 'edition'
    , po_number VARCHAR2(255) PATH 'po_number'
    , department VARCHAR2(255) PATH 'department'
    , comments VARCHAR2(255) PATH 'comments'
    , gl_account VARCHAR2(255) PATH 'gl_account'
    , invoice_number VARCHAR2(255) PATH 'invoice_number'
    , warranty_expiration VARCHAR2(255) PATH 'warranty_expiration'
    , cost_cc VARCHAR2(255) PATH 'cost_cc'
    , order_date VARCHAR2(255) PATH 'order_date'
    , schedule VARCHAR2(255) PATH 'schedule'
    , due VARCHAR2(255) PATH 'due'
    , location VARCHAR2(255) PATH 'location'
    , category VARCHAR2(255) PATH 'category'
    , lease_id VARCHAR2(255) PATH 'lease_id'
    , ip_address VARCHAR2(255) PATH 'ip_address'
    , u_vrr_rating VARCHAR2(255) PATH 'u_vrr_rating'
    , u_sciencelogic_correlation VARCHAR2(255) PATH 'u_sciencelogic_correlation'
    , u_sciencelogic_id VARCHAR2(255) PATH 'u_sciencelogic_id'
    , u_data_category VARCHAR2(255) PATH 'u_data_category'
    , u_sciencelogic_status VARCHAR2(255) PATH 'u_sciencelogic_status'
    , u_data_classification VARCHAR2(255) PATH 'u_data_classification'
    , u_ip_netmask VARCHAR2(255) PATH 'u_ip_netmask'
    , sys_created_by VARCHAR2(255) PATH 'sys_created_by'
    , sys_created_on VARCHAR2(255) PATH 'sys_created_on'
    , sys_updated_by VARCHAR2(255) PATH 'sys_updated_by'
    , sys_updated_on VARCHAR2(255) PATH 'sys_updated_on'
    ) x
;
 end if;


end if; -- p_action = 'LOAD'    


 
    end;



 
PROCEDURE do_rest_call (
    p_url            IN VARCHAR2,
    p_http_method    IN VARCHAR2 DEFAULT 'GET',
    p_content_type   IN VARCHAR2 DEFAULT g_content_type,
    p_body           IN CLOB DEFAULT NULL,
    p_run_id         IN NUMBER,
    p_response       OUT CLOB
)
    AS
BEGIN
    apex_web_service.g_request_headers(1).name    := 'Content-Type';
    apex_web_service.g_request_headers(1).value   := p_content_type;
    
    /*
    dbms_output.put_line('inside p_content_type: ' ||p_content_type);
    dbms_output.put_line('inside p_url: ' ||p_url);
    dbms_output.put_line('inside p_http_method: ' ||p_http_method);
    dbms_output.put_line('inside p_username: ' ||p_username);
    dbms_output.put_line('inside p_password: ' ||p_password);
    dbms_output.put_line('inside g_wallet_path: ' ||g_wallet_path);
    dbms_output.put_line('inside g_wallet_pass: ' ||g_wallet_pass);
    dbms_output.put_line('inside p_body: ' ||p_body);
    */

    IF
        p_body IS NOT NULL
    THEN
        dbms_output.put_line('with p_body: ');

        p_response   := apex_web_service.make_rest_request(
            p_url           => p_url,
            p_http_method   => p_http_method,
            p_username      => p_username,
            p_password      => p_password,
            p_wallet_path   => g_wallet_path,
            p_wallet_pwd    => g_wallet_pass,
            p_body          => p_body
        );
    ELSE
        dbms_output.put_line('without p_body: ');

        p_response   := apex_web_service.make_rest_request(
            p_url           => p_url,
            p_http_method   => p_http_method,
            p_username      => p_username,
            p_password      => p_password,
            p_wallet_path   => g_wallet_path,
            p_wallet_pwd    => g_wallet_pass
        );
    END IF;
--dbms_output.put_line('inside do_rest_call: ' ||p_response);

  INSERT INTO v_itsm_api_result (
     request_type,
     call_url,
     response,
     body,
     run_id
    ) values (
    p_http_method,
    p_url,
     p_response,
     p_body,
     p_run_id
    );
    
--EXCEPTION
--    WHEN OTHERS THEN
--        dbms_output.put_line('Error inside do_rest_call: ' ||p_url ||'' ||sqlerrm);
--        p_response   := sqlerrm;
END do_rest_call;
  

  procedure config(p_action in varchar2 default 'INIT_SNOW',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
)  AS
  BEGIN
   null;
   -- Set the standard globals for this Oracle install 
   if p_action = 'INIT_SNOW' then
   for c1 in (
   select
   setting_value
   ,setting_category 
   ,setting_name
   from V_APP_SETTINGS
   where
   setting_category in (
   'SERVICENOW.AUTH.BASIC','SERVICENOW.URL','SERVICENOW.ENDPOINT','ORACLE_WALLET_PATH','WALLET_PASSWORD'
     )  
   ) loop
     null;
     if  upper(c1.setting_name) like    '%USERNAME%' then
       p_username := c1.setting_value;
     end if;
     if c1.setting_category = 'SERVICENOW.AUTH.BASIC' and   upper(c1.setting_name) like    '%PASSWORD%' then
     -- dbms_output.put_line( 'p_password: '||  c1.setting_value);
       p_password := oac$ansible_utl.decrypt(c1.setting_value);
--       p_password := c1.setting_value;
     end if;     
     if  c1.setting_category =    'SERVICENOW.URL' then
       g_itsm_url:= c1.setting_value;
     end if;
     if  c1.setting_category =    'SERVICENOW.ENDPOINT' then
       g_endpoint_prefix := c1.setting_value;
     end if;
     if  c1.setting_category =    'ORACLE_WALLET_PATH' then
       g_wallet_path := c1.setting_value;
     end if;
 --    if  c1.setting_category =    'TOWER DOMAIN' then
 --      g_itsm_domain := c1.setting_value;
--     end if;
     if  c1.setting_category =    'WALLET_PASSWORD' then
       g_wallet_pass := oac$ansible_utl.decrypt(c1.setting_value);
     end if;

   end loop;
 
  elsif p_action = 'PRINT' then
     dbms_output.put_line( rpad('## V_APP_SETTINGS #',70,'#'));
     dbms_output.put_line( 'p_username: '||   p_username);
     dbms_output.put_line( 'p_password: '||   p_password);
     dbms_output.put_line( 'g_endpoint_prefix: '||   g_endpoint_prefix);
 --    dbms_output.put_line( 'g_itsm_domain: '||   g_itsm_domain);
     dbms_output.put_line( 'g_wallet_path: '||   g_wallet_path);
  --   dbms_output.put_line( 'g_wallet_pass: '||   g_wallet_pass);
     dbms_output.put_line( 'g_itsm_url: '||   g_itsm_url);     
     dbms_output.put_line( rpad('#',70,'#'));

/*       p_password := c1.setting_value;
       g_endpoint_prefix := c1.setting_value;
       g_default_inventory := c1.setting_value;
       g_default_inventory_id := c1.setting_value;
       g_tower_domain := c1.setting_value;
       g_wallet_path := c1.setting_value;
       g_wallet_pass := c1.setting_value;

   dbms_output.put_line( );*/
  end if ; -- Init Action


  END config;


END ITSM_UTILITY;

/
--------------------------------------------------------
--  DDL for Package Body LICENSE_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."LICENSE_MGR" AS

  procedure Load_license_data(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) AS
   l_baseline number;
  BEGIN
   --grab the active basline
   select max(baseline_id) into l_baseline from v_lic_baseline where status = 'Active';
  
  if p_action = 'DEMODATA' then
   --  select max(baseline_id) into l_baseline from v_lic_baseline where baseline_name = 'Demo License Pool';
   --
   -- 2 Baselines are setup with compare_key of COMP1 and COMP2, We load 2 sets of Lic Data so we can Compare
   -- Populate the temp_list_map the Dbs in temp_list_map_comp1
   -- load the demo data
   -- Populate the temp_list_map the Dbs in temp_list_map_comp1
    --if 1 = 2 then
    --Load COMP1 Demo Data
    select max(baseline_id) into l_baseline from v_lic_baseline where compare_key = 'COMP1';
    delete from temp_list_map ;
    insert into temp_list_map select * from temp_list_map_comp1;
    demo_data(p_baseline => l_baseline );
    --end if;
    --Load COMP2 Demo Data
    select max(baseline_id) into l_baseline from v_lic_baseline where compare_key = 'COMP2';
    delete from temp_list_map ;
    insert into temp_list_map select * from temp_list_map_comp2;
    demo_data(p_baseline => l_baseline );
    commit;
  elsif p_action = 'LOAD_JSON' then   
    -- Called from APex 
    load_json(
        p_action  => p_action ,
        p_baseline => p_baseline,
        p_host => p_host,
        p_parm1 => p_parm1,
        p_parm2 => p_parm2,
        p_debug  => p_debug);
        
        
  end if;
 


  
  END Load_license_data;
  
  procedure demo_data(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,      
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) as

begin
 null;
 delete from v_lic_db_inventory where baseline_id = p_baseline;
 delete from v_lic_host_inv where baseline_id = p_baseline;
 delete from v_lic_feature_usage where baseline_id = p_baseline;
 delete from v_lic_product_usage where baseline_id = p_baseline;
 --
 --Map data from demo hosts to charter hosts
 --
for c1 in (

SELECT
    invid,
    database_name,
    database_role,
    oracle_version,
    v_host_code,
    host_name,
    usageid,
    db_name,
    host
FROM
    temp_list_map
union
SELECT
    invid,
    database_name,
    database_role,
    oracle_version,
    v_host_code,
    host_name,
    usageid,
    db_name,
    host
FROM
TEMP_LIST_MAP_EXADATA
) loop
-- Load v_lic_db_inventory

INSERT INTO v_lic_db_inventory (
    baseline_id,
    database_name,
    application_name,
    environment,
    oracle_version,
    rac_type,
    business_unit,
    appliance,
    database_role,
    pci_required,
    sox_required,
    encryption_required,
    dataguard,
    golden_gate,
    backup_enabled,
    end_of_life,
    db_monitoring_tool,
    monitoring,
    comments,
    instance_count,
    db_source,
    dr_solution,
    dr_location,
    env_category,
    v_host_code,
    app_id,
    storage_type,
    db_home,
    sw_csi,
    ref_app_id
)
select
    p_baseline,
    database_name,
    application_name,
    environment,
    oracle_version,
    rac_type,
    business_unit,
    appliance,
    database_role,
    pci_required,
    sox_required,
    encryption_required,
    dataguard,
    golden_gate,
    backup_enabled,
    end_of_life,
    db_monitoring_tool,
    monitoring,
    comments,
    instance_count,
    db_source,
    dr_solution,
    dr_location,
    env_category,
    v_host_code,
    app_id,
    storage_type,
    db_home,
    sw_csi,
    ref_app_id
 from v_db_inventory i
 where
 i.database_name = c1.database_name
 and i.database_role = c1.database_role
 and not exists
 (
 select 1 from v_lic_db_inventory l where 
 i.database_name = l.database_name 
 and i.database_role = l.database_role
 and l.baseline_id = p_baseline
 );   

INSERT INTO v_lic_product_usage (
    baseline_id,
    host_name,
    instance_name,
    database_name,
    open_mode,
    database_role,
    dbcreated,
    dbid,
    version,
    banner,
    gid,
    con_id,
    con_name,
    product,
    usage,
    last_sample_date,
    first_usage_date,
    last_usage_date
) 
SELECT
    p_baseline,
    c1.host_name,
    c1.database_name,
    c1.database_name,
    open_mode,
    c1.database_role,
    created,
    dbid,
    version,
    banner,
    gid,
    con_id,
    con_name,
    product,
    usage,
    last_sample_date,
    first_usage_date,
    last_usage_date
FROM
    v_license_product_usage i
where
i.database_name = c1.db_name; 


INSERT INTO v_lic_feature_usage (
    baseline_id,
    host_name,
    instance_name,
    database_name,
    open_mode,
    database_role,
    dbcreated,
    dbid,
    version,
    banner,
    product,
    feature_being_used,
    usage,
    last_sample_date,
    detected_usages,
    total_samples,
    currently_used,
    first_usage_date,
    last_usage_date,
    extra_feature_info
)
SELECT
    p_baseline,
    c1.host_name,
    c1.database_name,
    c1.database_name,
    open_mode,
    c1.database_role,
    created,
    dbid,
    version,
    banner,
    product,
    feature_being_used,
    usage,
    last_sample_date,
    detected_usages,
    total_samples,
    currently_used,
    first_usage_date,
    last_usage_date,
    extra_feature_info
FROM
    v_license_feature_usage i
where
i.database_name = c1.db_name; 

-- Load V_LIC_HOST_INV
INSERT INTO v_lic_host_inv (
    baseline_id,
    host_name,
    network_type,
    lic_core,
    core_count,
    processor_config_speed,
    server_model,
    hardware_vendor,
    os_type_version,
    processor_bit,
    server_creation_date,
    phy_virt,
    dc_location,
    global_zone_solaris,
    phy_memory,
    server_monitoring_tool,
    host_code,
    db_id,
    cluster_id,
    clustered,
    os_type,
    env_source,
    hw_csi
    ) 
    select
    P_baseline,
    host_name,
    network_type,
    core_count,
    core_count,
    processor_config_speed,
    server_model,
    hardware_vendor,
    os_type_version,
    processor_bit,
    server_creation_date,
    phy_virt,
    dc_location,
    global_zone_solaris,
    phy_memory,
    server_monitoring_tool,
    host_code,
    db_id,
    cluster_id,
    clustered,
    os_type,
    env_source,
    hw_csi
   from v_host_inv_tbl i
   where
   host_code = c1.v_host_code
 and not exists
 (
 select 1 from v_lic_host_inv l where 
 i.host_code = l.host_code
 and i.host_name = l.host_name
  and l.baseline_id = p_baseline
 );   
-- Load V_LIC_DB_INVENTORY
 
end loop;
end ;

 procedure load_json(
        p_action   IN VARCHAR2 DEFAULT NULL,
          p_baseline in NUMBER default null,      
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) as
 date_mask varchar2(255) := 'DD-MON-YYYY HH24:MI:SS';
 l_host_code varchar2(255);
 l_database_id number;
 l_sqlerrm varchar2(4000);
begin
 null;
 /*
 V_LIC_BASELINE_JSONLOAD
 */
 
null;
/*
 delete from v_lic_db_inventory where baseline_id = p_baseline;
 delete from v_lic_host_inv where baseline_id = p_baseline;
 delete from v_lic_feature_usage where baseline_id = p_baseline;
 delete from v_lic_product_usage where baseline_id = p_baseline;
*/
 --
 --Map data from demo hosts to charter hosts
 --
for c1 in (

SELECT
STATUS_ID,
host_name,
    database_name,
    max(version) database_version,
    max(p.database_name) database_role,
    max(record_created) last_collected
    
FROM
    v_lic_jsonload_product_vw p
where
 record_created >= trunc(sysdate)  - nvl(p_parm1,'30')
--
--Only load records that we have not already loaded into this baseline
--
and not exists (
select 1
   from V_LIC_BASELINE_JSONLOAD j
 where   
   BASELINE_ID  = p_baseline
 and   j.STATUS_ID = p.STATUS_ID

) 
group by
STATUS_ID,
host_name,
    database_name
) loop

--
-- Insert a record into the tracking table for license uploads from JSON
--
INSERT INTO v_lic_baseline_jsonload (
    baseline_id,
    status_id,
    database_name,
    host_name

) VALUES (
p_baseline
,c1.status_id
,c1.database_name
,c1.host_name
);


-- Delete Previous upload in this baseline
-- delete from v_lic_host_inv where baseline_id = p_baseline
-- and host_name = c1.host_name
-- ;

-- Load V_LIC_HOST_INV
INSERT INTO v_lic_host_inv (
    baseline_id,
    host_name,
    network_type,
    lic_core,
    core_count,
    processor_config_speed,
    server_model,
    hardware_vendor,
    os_type_version,
    processor_bit,
    server_creation_date,
    phy_virt,
    dc_location,
    global_zone_solaris,
    phy_memory,
    server_monitoring_tool,
    host_code,
    db_id,
    cluster_id,
    clustered,
    os_type,
    env_source,
    hw_csi
    ) 
    select
    P_baseline,
    host_name,
    network_type,
    core_count,
    core_count,
    processor_config_speed,
    server_model,
    hardware_vendor,
    os_type_version,
    processor_bit,
    server_creation_date,
    phy_virt,
    dc_location,
    global_zone_solaris,
    phy_memory,
    server_monitoring_tool,
    host_code,
    db_id,
    cluster_id,
    clustered,
    os_type,
    env_source,
    hw_csi
   from v_host_inv_tbl i
   where
   host_name = c1.host_name
 and not exists
 (
 select 1 from v_lic_host_inv l where 
 i.host_code = l.host_code
 and i.host_name = l.host_name
  and l.baseline_id = p_baseline
 );   

-- Check that the host was created
select
max(host_code) into
l_host_code
 from v_lic_host_inv i
   where
   host_name = c1.host_name ;
--
-- If we didnt find the HOST in Inventory Add something
--
if l_host_code is null  then
-- Load v_lic_db_inventory
l_host_code := GET_HOST_CODE;
INSERT INTO v_lic_host_inv (
    baseline_id,
    host_name,
    host_code,
    lic_core,
    core_count
     
) values (
p_baseline
,c1.host_name
,l_host_code
,1
,1
)
;   

end if;


 
 
 --Cleanup the database and license sturtures for the DB
 delete from v_lic_db_inventory where baseline_id = p_baseline and database_name = c1.database_name;
 delete from v_lic_feature_usage where baseline_id = p_baseline and database_name = c1.database_name;
 delete from v_lic_product_usage where baseline_id = p_baseline and database_name = c1.database_name;

-- Load v_lic_db_inventory
INSERT INTO v_lic_db_inventory (
    baseline_id,
    database_name,
    application_name,
    environment,
    oracle_version,
    rac_type,
    business_unit,
    appliance,
    database_role,
    pci_required,
    sox_required,
    encryption_required,
    dataguard,
    golden_gate,
    backup_enabled,
    end_of_life,
    db_monitoring_tool,
    monitoring,
    comments,
    instance_count,
    db_source,
    dr_solution,
    dr_location,
    env_category,
    v_host_code,
    app_id,
    storage_type,
    db_home,
    sw_csi,
    ref_app_id
)
select
    p_baseline,
    database_name,
    application_name,
    environment,
    oracle_version,
    rac_type,
    business_unit,
    appliance,
    database_role,
    pci_required,
    sox_required,
    encryption_required,
    dataguard,
    golden_gate,
    backup_enabled,
    end_of_life,
    db_monitoring_tool,
    monitoring,
    comments,
    instance_count,
    db_source,
    dr_solution,
    dr_location,
    env_category,
    v_host_code,
    app_id,
    storage_type,
    db_home,
    sw_csi,
    ref_app_id
 from v_db_inventory i
 where
 i.database_name = c1.database_name
 --and i.database_role = c1.database_role
 and not exists
 (
 select 1 from v_lic_db_inventory l where 
 i.database_name = l.database_name 
 and i.database_role = l.database_role
 and l.baseline_id = p_baseline
 );   

--Check that the DB exists
select
max(database_id ) into
l_database_id
 from v_lic_db_inventory i
 where
 i.database_name = c1.database_name
;
--
-- If we didnt find the DB in Inventory Add something
--
if l_database_id is null  then
-- Load v_lic_db_inventory
INSERT INTO  v_lic_db_inventory (
    baseline_id,
    database_name,
    database_role,
    oracle_version,
    v_host_code,
    comments
) values (
p_baseline
,c1.database_name
,c1.database_role
,c1.database_version
,l_host_code
,'Unregistred Database on '||c1.host_name
 );   

end if;

begin

INSERT INTO v_lic_product_usage (
    baseline_id,
    host_name,
    instance_name,
    database_name,
    open_mode,
    database_role,
    dbcreated,
    dbid,
    version,
    banner,
    gid,
    con_id,
    con_name,
    product,
    usage,
    last_sample_date,
    first_usage_date,
    last_usage_date
) 
SELECT
    p_baseline,
    host_name,
    database_name,
    database_name,
    open_mode,
    database_role,
    created,
    dbid,
    version,
    banner,
    gid,
    con_id,
    con_name,
    product,
    usage,
    to_date(last_sample_date,date_mask),
    to_date(first_usage_date,date_mask),
    to_date(last_usage_date,date_mask)
FROM
    --v_license_product_usage i
    v_lic_jsonload_product_vw i
where
i.database_name = c1.database_name; 

exception
when others then
 if p_debug = 'Y' then
 l_sqlerrm := sqlerrm;
   dbms_output.put_line(substr(l_sqlerrm,255)|| ' on Insert v_lic_product_usage'  );
 end if;

end;

Begin
INSERT INTO v_lic_feature_usage (
    baseline_id,
    host_name,
    instance_name,
    database_name,
    open_mode,
    database_role,
    dbcreated,
    dbid,
    version,
    banner,
    product,
    feature_being_used,
    usage,
    last_sample_date,
    detected_usages,
    total_samples,
    currently_used,
    first_usage_date,
    last_usage_date,
    extra_feature_info
)
SELECT
    p_baseline,
    host_name,
    database_name,
    database_name,
    open_mode,
    database_role,
    created,
    dbid,
    version,
    banner,
    product,
    feature_being_used,
    usage,
    to_date(last_sample_date,date_mask),
    detected_usages,
    total_samples,
    currently_used,
    to_date(first_usage_date,date_mask),
    to_date(last_usage_date,date_mask),
    extra_feature_info
FROM
    v_lic_jsonload_feature_vw i
where
i.database_name = c1.database_name
; 

exception
when others then
 if p_debug = 'Y' then
 l_sqlerrm := sqlerrm;
   dbms_output.put_line(substr(l_sqlerrm,255)|| ' on Insert v_lic_feature_usage'  );
 end if;

end;
 
end loop;
 
end ;

procedure check_schedule(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_baseline in NUMBER default null,
        p_host IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_parm2 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) as
l_start_on date;
l_plus_days number := 7;
begin
  null;
  --
  -- Look at the discovery schedule 
  -- 1) Reschedule any schedules that have executed
  -- 2) Update the Stats
 for c1 in (
 SELECT
    lic_schedule_id,
    schedule_name,
    schedule_type,
    ticket_ref,
    host_name,
    filter_parms,
    execute_interval,
    schedule_start_date,
    schedule_start_hr,
    last_run_time ,
    current_run_time ,
    number_of_runs,
    current_schedule_id,
    last_schedule_id,
    status
FROM
    v_lic_discovery_schedule_vw
  where
  status = 'Active'
  and execute_interval in ('DAILY','WEEKLY','MONTHLY','QUARTERLY')
  and current_run_time <= sysdate
 ) loop
 -- For all Active schedules
 -- That have executed, need to look at there execution interval
 -- re-schedule the based on there execute_interval
   null;
   
 if c1.execute_interval = 'DAILY' then
  l_plus_days := 1;
 elsif  c1.execute_interval = 'DAILY' then
  l_plus_days := 7;
 elsif  c1.execute_interval = 'MONTHLY' then
  l_plus_days := 30;
 elsif  c1.execute_interval = 'QUARTERLY' then
  l_plus_days := 90;
 end if;
 --Setup for next run
 l_start_on := c1.schedule_start_date + l_plus_days;
  update  v_lic_discovery_schedule 
    set   schedule_start_date = l_start_on,
   last_schedule_id = current_schedule_id  ,
    number_of_runs = nvl(number_of_runs,0) + 1
 where
 lic_schedule_id = c1.lic_schedule_id ;
 
  STANDARD_TASK_MGR.save_task(
        p_action =>   'LICENSE_DISCOVERY',
        p_page  =>  '2250',
        p_parm1  => c1.lic_schedule_id
  );

 
 end loop;
  
  
end ;


END LICENSE_MGR;

/
--------------------------------------------------------
--  DDL for Package Body LOGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."LOGGER" 
as
  -- Note: The license is defined in the package specification of the logger package
  --
  -- Conditional Compilation variables:
  -- $$NO_OP
  --  When true, completely disables all logger DML.Also used to generate the logger_no_op.sql file
  --
  -- $$RAC_LT_11_2:
  --  Set in logger_configure.
  --  Handles the fact that RAC doesn't support global app contexts until 11.2
  --
  -- $$FLASHBACK_ENABLED
  --  Set in logger_configure.
  --  Determine whether or not we can grab the scn from dbms_flashback.
  --  Primarily used in the trigger on logger_logs.
  --
  -- $$APEX
  --  Set in logger_configure.
  --  True if we can query a local synonym to wwv_flow_data to snapshot the APEX session state.
  --
  -- $$LOGGER_DEBUG
  --  Only to be used during development of logger
  --  Primarily used for dbms_output.put_line calls
  --  Part of #64
  --
  -- $$LOGGER_PLUGIN_<TYPE> : For each type of plugin
  --  Introduced with #46
  --  $$LOGGER_PLUGIN_ERROR
  --


  -- TYPES
  type ts_array is table of timestamp index by varchar2(100);


  -- VARIABLES
  g_log_id number;
  g_proc_start_times ts_array;
  g_running_timers pls_integer := 0;

  -- #46
  g_plug_logger_log_error rec_logger_log;

  g_in_plugin_error boolean := false;






  -- CONSTANTS
  gc_line_feed constant varchar2(1) := chr(10);
  gc_cflf constant varchar2(2) := chr(13)||chr(10);
  gc_date_format constant varchar2(255) := 'DD-MON-YYYY HH24:MI:SS';
  gc_timestamp_format constant varchar2(255) := gc_date_format || ':FF';
  gc_timestamp_tz_format constant varchar2(255) := gc_timestamp_format || ' TZR';

  gc_ctx_attr_level constant varchar2(5) := 'level';
  gc_ctx_attr_include_call_stack constant varchar2(18) := 'include_call_stack';

  -- #46 Plugin context names
  gc_ctx_plugin_fn_log constant varchar2(30) := 'plugin_fn_log';
  gc_ctx_plugin_fn_info constant varchar2(30) := 'plugin_fn_information';
  gc_ctx_plugin_fn_warn constant varchar2(30) := 'plugin_fn_warning';
  gc_ctx_plugin_fn_error constant varchar2(30) := 'plugin_fn_error';
  gc_ctx_plugin_fn_perm constant varchar2(30) := 'plugin_fn_permanent';

  -- #113 Preference names
  gc_pref_level constant logger_prefs.pref_name%type := 'LEVEL';
  gc_pref_include_call_stack constant logger_prefs.pref_name%type := 'INCLUDE_CALL_STACK';
  gc_pref_protect_admin_procs constant logger_prefs.pref_name%type := 'PROTECT_ADMIN_PROCS';
  gc_pref_install_schema constant logger_prefs.pref_name%type := 'INSTALL_SCHEMA';
  gc_pref_purge_after_days constant logger_prefs.pref_name%type := 'PURGE_AFTER_DAYS';
  gc_pref_purge_min_level constant logger_prefs.pref_name%type := 'PURGE_MIN_LEVEL';
  gc_pref_logger_version constant logger_prefs.pref_name%type := 'LOGGER_VERSION';
  gc_pref_client_id_expire_hours constant logger_prefs.pref_name%type := 'PREF_BY_CLIENT_ID_EXPIRE_HOURS';
  gc_pref_logger_debug constant logger_prefs.pref_name%type := 'LOGGER_DEBUG';
  gc_pref_plugin_fn_error constant logger_prefs.pref_name%type := 'PLUGIN_FN_ERROR';




  -- *** PRIVATE ***

  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created
   * @param p_str
   * @return True if p_str is a number
   */
  function is_number(p_str in varchar2)
    return boolean
  as
    l_num number;
  begin
    l_num := to_number(p_str);
    return true;
  exception
    when others then
      return false;
  end is_number;


  /**
   * Validates assertion. Will raise an application error if assertion is false
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 29-Mar-2013
   * @param p_condition Boolean condition to validate
   * @param p_message Message to include in application error if p_condition fails
   */
  procedure assert(
    p_condition in boolean,
    p_message in varchar2)
  as
  begin
    $if $$no_op $then
      null;
    $else
      if not p_condition or p_condition is null then
        raise_application_error(-20000, p_message);
      end if;
    $end
  end assert;


  /**
   * Returns the display/print friendly parameter information
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 20-Jan-2013
   * @param p_parms Array of parameters (can be null)
   * @return Clob of param information
   */
  function get_param_clob(p_params in logger.tab_param)
    return clob
  as
    l_return clob;
    l_no_vars constant varchar2(255) := 'No params defined';
    l_index pls_integer;
  begin

    $if $$no_op $then
      return null;
    $else
      -- Generate line feed delimited list
      if p_params.count > 0 then
        -- Using while true ... option allows for unordered param list
        l_index := p_params.first;
        while true loop
          l_return := l_return || p_params(l_index).name || ': ' || p_params(l_index).val;

          l_index := p_params.next(l_index);

          if l_index is null then
            exit;
          else
            l_return := l_return || gc_line_feed;
          end if;
        end loop;

      else
        -- No Parameters
        l_return := l_no_vars;
      end if;

      return l_return;
    $end
  end get_param_clob;



  /**
   * Sets the global context
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_attribute Attribute for context to set
   * @param p_value Value
   * @param p_client_id Optional client_id. If specified will only set the attribute/value for specific client_id (not global)
   */
  procedure save_global_context(
    p_attribute in varchar2,
    p_value in varchar2,
    p_client_id in varchar2 default null)
  is
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      dbms_session.set_context(
        namespace => g_context_name,
        attribute => p_attribute,
        value => p_value,
        client_id => p_client_id);
    $end

    commit; -- MD: moved commit to outside of the NO_OP check since commit or rollback must occur in this procedure
  end save_global_context;



  /**
   * Will return the extra column appended with the display friendly parameters
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 1-May-2013
   * @param p_extra Current "Extra" field
   * @param p_params Parameters. If null, then no changes to the Extra column
   */
  function set_extra_with_params(
    p_extra in logger_logs.extra%type,
    p_params in tab_param
  )
    return logger_logs.extra%type
  as
    l_extra logger_logs.extra%type;
  begin
    $if $$no_op $then
      return null;
    $else
      if p_params.count = 0 then
        return p_extra;
      else
        l_extra := p_extra || gc_line_feed || gc_line_feed || '*** Parameters ***' || gc_line_feed || gc_line_feed || get_param_clob(p_params => p_params);
      end if;

      return l_extra;
    $end

  end set_extra_with_params;


  /**
   * Returns common system level context values
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, USER, or INSTANCe
   * @param p_vertical True of values should have a line break after each value. False for comman seperated list.
   * @param p_show_null Show null values
   * @return
   */
  function get_sys_context(
    p_detail_level in varchar2 default 'USER', -- ALL, NLS, USER, INSTANCE
    p_vertical in boolean default false,
    p_show_null in boolean default false)
    return clob
  is
    l_ctx clob;
    l_detail_level varchar2(20) := upper(p_detail_level);

    procedure append_ctx(p_name in varchar2)
    is
      r_pad number := 30;
      l_value varchar2(100);

      invalid_userenv_parm exception;
      pragma exception_init(invalid_userenv_parm, -2003);

    begin
      l_value := sys_context('USERENV',p_name);

      if p_show_null or l_value is not null then
        if p_vertical then
          l_ctx := l_ctx || rpad(p_name,r_pad,' ')||': '|| l_value || gc_cflf;
        else
          l_ctx := l_ctx || p_name||': '|| l_value ||', ';
        end if;
      end if;
    exception
      when invalid_userenv_parm then
        null;
    end append_ctx;


  begin
    $if $$no_op $then
      return null;
    $else
      if l_detail_level in ('ALL','NLS','INSTANCE') then
        append_ctx('NLS_CALENDAR');
        append_ctx('NLS_CURRENCY');
        append_ctx('NLS_DATE_FORMAT');
        append_ctx('NLS_DATE_LANGUAGE');
        append_ctx('NLS_SORT');
        append_ctx('NLS_TERRITORY');
        append_ctx('LANG');
        append_ctx('LANGUAGE');
      end if;
      if l_detail_level in ('ALL','USER') then
        append_ctx('CURRENT_SCHEMA');
        append_ctx('SESSION_USER');
        append_ctx('OS_USER');
        append_ctx('CLIENT_IDENTIFIER');
        append_ctx('CLIENT_INFO');
        append_ctx('IP_ADDRESS');
        append_ctx('HOST');
        append_ctx('TERMINAL');
      end if;

      if l_detail_level in ('ALL','USER') then
        append_ctx('AUTHENTICATED_IDENTITY');
        append_ctx('AUTHENTICATION_DATA');
        append_ctx('AUTHENTICATION_METHOD');
        append_ctx('ENTERPRISE_IDENTITY');
        append_ctx('POLICY_INVOKER');
        append_ctx('PROXY_ENTERPRISE_IDENTITY');
        append_ctx('PROXY_GLOBAL_UID');
        append_ctx('PROXY_USER');
        append_ctx('PROXY_USERID');
        append_ctx('IDENTIFICATION_TYPE');
        append_ctx('ISDBA');
      end if;

      if l_detail_level in ('ALL','INSTANCE') then
        append_ctx('DB_DOMAIN');
        append_ctx('DB_NAME');
        append_ctx('DB_UNIQUE_NAME');
        append_ctx('INSTANCE');
        append_ctx('INSTANCE_NAME');
        append_ctx('SERVER_HOST');
        append_ctx('SERVICE_NAME');
      end if;

      if l_detail_level in ('ALL') then
        append_ctx('ACTION');
        append_ctx('AUDITED_CURSORID');
        append_ctx('BG_JOB_ID');
        append_ctx('CURRENT_BIND');
        append_ctx('CURRENT_SCHEMAID');
        append_ctx('CURRENT_SQL');
        append_ctx('CURRENT_SQLn');
        append_ctx('CURRENT_SQL_LENGTH');
        append_ctx('ENTRYID');
        append_ctx('FG_JOB_ID');
        append_ctx('GLOBAL_CONTEXT_MEMORY');
        append_ctx('GLOBAL_UID');
        append_ctx('MODULE');
        append_ctx('NETWORK_PROTOCOL');
        append_ctx('SESSION_USERID');
        append_ctx('SESSIONID');
        append_ctx('SID');
        append_ctx('STATEMENTID');
      end if;

      return rtrim(l_ctx,', ');
    $end
  end get_sys_context;


  /**
   * Checks if admin functions can be run
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return True if user can run admin procs.
   */
 function admin_security_check
    return boolean
  is
    l_protect_admin_procs logger_prefs.pref_value%type;
    l_return boolean default false;
  begin
    $if $$no_op $then
      l_return := true;
    $else
      l_protect_admin_procs := get_pref(logger.gc_pref_protect_admin_procs);
      if l_protect_admin_procs = 'TRUE' then
        if get_pref(logger.gc_pref_install_schema) = sys_context('USERENV','SESSION_USER') then
          l_return := true;
        else
          l_return := false;
          raise_application_error (-20000, 'You are not authorized to call this procedure. Change Logger pref: PROTECT_ADMIN_PROCS to false to avoid this.');
        end if;
      else
        l_return := true;
      end if;
    $end

    return l_return;

  end admin_security_check;


  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  - #111 Use get_pref to remove duplicate code
   *
   * @author Tyler Muth
   * @created ???
   * @param
   * @return If client level specified will return it, otherwise global level.
   */
  function get_level_number
    return number
    $if $$rac_lt_11_2 $then
      $if not dbms_db_version.ver_le_10_2 $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
      $end
    $end
  is
    l_level number;
    l_level_char varchar2(50);

    $if $$logger_debug $then
      l_scope varchar2(30) := 'get_level_number';
    $end

  begin
    $if $$no_op $then
      return g_off;
    $else
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ': selecting logger_level');
      $end

      l_level := convert_level_char_to_num(logger.get_pref(logger.gc_pref_level));

      return l_level;
    $end
  end get_level_number;


  /**
   * Determines if callstack should be while logging
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return
   */
  function include_call_stack
    return boolean
    $if 1=1
      and $$rac_lt_11_2
      and not dbms_db_version.ver_le_10_2
      and ($$no_op is null or not $$no_op) $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
    $end
  is
    l_call_stack_pref logger_prefs.pref_value%type;
  begin
    $if $$no_op $then
      return false;
    $else
      $if $$rac_lt_11_2 $then
        l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
      $else
        l_call_stack_pref := sys_context(g_context_name,gc_ctx_attr_include_call_stack);

        if l_call_stack_pref is null then
          l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
          save_global_context(
            p_attribute => gc_ctx_attr_include_call_stack,
            p_value => l_call_stack_pref,
            p_client_id => sys_context('userenv','client_identifier'));
        end if;
      $end

      if l_call_stack_pref = 'TRUE' then
        return true;
      else
        return false;
      end if;
    $end
  end include_call_stack;


  /**
   * Returns date diff in "... sectons/minutes/days/etc ago" format
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date_start
   * @param p_date_stop
   * @return Text version of date diff
   */
  function date_text_format_base (
    p_date_start in date,
    p_date_stop  in date)
  return varchar2
  as
    x varchar2(20);
  begin
    $if $$no_op $then
      return null;
    $else
      x :=
        case
          when p_date_stop-p_date_start < 1/1440
            then round(24*60*60*(p_date_stop-p_date_start)) || ' seconds'
          when p_date_stop-p_date_start < 1/24
            then round(24*60*(p_date_stop-p_date_start)) || ' minutes'
          when p_date_stop-p_date_start < 1
            then round(24*(p_date_stop-p_date_start)) || ' hours'
          when p_date_stop-p_date_start < 14
            then trunc(p_date_stop-p_date_start) || ' days'
          when p_date_stop-p_date_start < 60
            then trunc((p_date_stop-p_date_start)/7) || ' weeks'
          when p_date_stop-p_date_start < 365
            then round(months_between(p_date_stop,p_date_start)) || ' months'
          else round(months_between(p_date_stop,p_date_start)/12,1) || ' years'
        end;
      x:= regexp_replace(x,'(^1 [[:alnum:]]{4,10})s','\1');
      x:= x || ' ago';
      return substr(x,1,20);
    $end
  end date_text_format_base;


  /**
   * Parses the callstack to get unit and line number
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_callstack
   * @param o_unit
   * @param o_lineno
   */
  procedure get_debug_info(
    p_callstack in clob,
    o_unit out varchar2,
    o_lineno out varchar2 )
  as
    --
    l_callstack varchar2(10000) := p_callstack;
  begin
    $if $$no_op $then
      null;
    $else
      l_callstack := substr( l_callstack, instr( l_callstack, chr(10), 1, 5 )+1 );
      l_callstack := substr( l_callstack, 1, instr( l_callstack, chr(10), 1, 1 )-1 );
      l_callstack := trim( substr( l_callstack, instr( l_callstack, ' ' ) ) );
      o_lineno := substr( l_callstack, 1, instr( l_callstack, ' ' )-1 );
      o_unit := trim(substr( l_callstack, instr( l_callstack, ' ', -1, 1 ) ));
    $end
  end get_debug_info;


  /**
   * Main procedure that will store log data into logger_logs table
   *
   *
   * Modifications
   *  - 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_log_level
   * @param p_scope
   * @param p_extra
   * @param p_callstack
   * @param p_params
   *
   */
  procedure log_internal(
    p_text in varchar2,
    p_log_level in number,
    p_scope in varchar2,
    p_extra in clob default null,
    p_callstack in varchar2 default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
    l_proc_name varchar2(100);
    l_lineno varchar2(100);
    l_text varchar2(32767);
    l_callstack varchar2(3000);
    l_extra logger_logs.extra%type;
  begin
    $if $$no_op $then
      null;
    $else
      l_text := p_text;

      -- Generate callstack text
      if p_callstack is not null and logger.include_call_stack then
        logger.get_debug_info(
          p_callstack => p_callstack,
          o_unit => l_proc_name,
          o_lineno => l_lineno);

        l_callstack  := regexp_replace(p_callstack,'^.*$','',1,4,'m');
        l_callstack  := regexp_replace(l_callstack,'^.*$','',1,1,'m');
        l_callstack  := ltrim(replace(l_callstack,chr(10)||chr(10),chr(10)),chr(10));

      end if;

      l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

      ins_logger_logs(
        p_unit_name => upper(l_proc_name) ,
        p_scope => p_scope ,
        p_logger_level =>p_log_level,
        p_extra => l_extra,
        p_text =>l_text,
        p_call_stack  =>l_callstack,
        p_line_no => l_lineno,
        po_id => g_log_id);
    $end
  end log_internal;


  /**
   * Run plugin
   *
   * Notes:
   *  - Currently only supports error type plugin but has been built to support other types
   *  - -- FUTURE mdsouza: When supporting other plugin types put conditional compilation where applicable
   *  - -- FUTURE mdsouza: Include this in tests (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_log Record that plugin should be run for
   */
  procedure run_plugin(p_logger_log in logger.rec_logger_log)
  as
    l_plugin_fn logger_prefs.pref_value%type;
    l_plugin_ctx varchar2(30);

    l_sql varchar2(255);

    -- For exception block
    l_params logger.tab_param;
    l_scope logger_logs.scope%type;

    -- Mark "in_plugin" as true/false
    -- Put in separate procedure since more logic may be applied
    -- And called from exception block as well
    procedure start_stop_plugin(
      p_in_plugin boolean -- True/False depending on action
    )
    as
    begin
      if p_logger_log.logger_level = logger.g_error then
        g_in_plugin_error := p_in_plugin;
      end if;
    end start_stop_plugin;

    function f_get_set_global_context(
      p_ctx in varchar2
    )
      return varchar2
    as
      l_return varchar2(255);
    begin
      $if $$logger_debug $then
        dbms_output.put_line('Calling f_get_set_global_conext');
      $end

      l_return := upper(get_pref(p_pref_name =>
        case
          when p_logger_log.logger_level = g_error then gc_ctx_plugin_fn_error
        end
      ));

      $if $$logger_debug $then
        dbms_output.put_line('l_return: ' || l_return);
      $end

      save_global_context(p_attribute => p_ctx, p_value => l_return);
      return l_return;
    end f_get_set_global_context;

  begin
    start_stop_plugin(p_in_plugin => true);

    $if $$logger_debug $then
      dbms_output.put_line('in run_plugin. g_in_plugin_error: ' || logger.tochar(g_in_plugin_error));
    $end

    if 1=2 then
      null;
    elsif p_logger_log.logger_level = logger.g_error then
      l_plugin_ctx := gc_ctx_plugin_fn_error;
    end if;

    if l_plugin_ctx is not null then
      l_plugin_fn := coalesce(
        sys_context(g_context_name, l_plugin_ctx),
        f_get_set_global_context(p_ctx => l_plugin_ctx));

      $if $$logger_debug $then
        dbms_output.put_line('l_plugin_fn: ' || l_plugin_fn);
      $end

      if 1=1
        and l_plugin_fn is not null
        and l_plugin_fn != 'NONE' then

        l_sql := 'begin ' || l_plugin_fn || '(logger.get_plugin_rec(' || p_logger_log.logger_level || ')); end;';

        $if $$logger_debug $then
          dbms_output.put_line('l_sql: ' || l_sql);
        $end

        execute immediate l_sql;

      else
        -- Should never reach this point since plugin_fn should have a value
        logger.log_error('Error l_plugin_fn does not have value');
      end if; -- l_plugin_fn
    else
      -- Should never reach this point since plugin_ctx should have a value
      logger.log_error('Error l_plugin_ctx does not have value');
    end if; -- l_plugin_ctx is not null

    start_stop_plugin(p_in_plugin => false);

  exception
    when others then
      logger.append_param(l_params, 'Logger.id', p_logger_log.id);
      logger.append_param(l_params, 'Logger.logger_level', p_logger_log.logger_level);
      logger.append_param(l_params, 'Plugin Function', l_plugin_fn);

      select scope
      into l_scope
      from logger_logs_5_min
      where 1=1
        and id = p_logger_log.id;

      logger.log_error('Exception in plugin procedure: ' || l_plugin_fn, l_scope, null, l_params);

      start_stop_plugin(p_in_plugin => false);

      raise;
  end run_plugin;




  -- **** PUBLIC ****


  /**
   * Sets all the contexts to null
   *
   * Notes:
   *  - Though this is public it is not a documented procedure. Only used with logger_configure.
   *
   * Related Tickets:
   *  - #46 Plugin support
   *  - #110 Clear all contexts (including ones with client identifier)
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure null_global_contexts
  is
    pragma autonomous_transaction;
  begin
    $if $$no_op or $$rac_lt_11_2 $then
      null;
    $else
      dbms_session.clear_all_context(
         namespace => g_context_name);
    $end

    commit;
  end null_global_contexts;


  /**
   * Converts string names to text value
   *
   * Changes
   *  - 2.1.0: Start to use global variables and correct numbers
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level String representation of level
   * @return level number. -1 if not found
   */
  function convert_level_char_to_num(
    p_level in varchar2)
    return number
  is
    l_level         number;
  begin
    $if $$no_op $then
      return null;
    $else
      case p_level
        when g_off_name then l_level := g_off;
        when g_permanent_name then l_level := g_permanent;
        when g_error_name then l_level := g_error;
        when g_warning_name then l_level := g_warning;
        when g_information_name then l_level := g_information;
        when g_debug_name then l_level := g_debug;
        when g_timing_name then l_level := g_timing;
        when g_sys_context_name then l_level := g_sys_context;
        when g_apex_name then l_level := g_apex;
        else l_level := -1;
      end case;
    $end

    return l_level;
  end convert_level_char_to_num;


  /**
   * Converts the logger level num to char format
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_level
   * @return Logger level string format
   */
  function convert_level_num_to_char(
    p_level in number)
    return varchar2
  is
    l_return varchar2(255);
  begin
    $if $$no_op $then
      null;
    $else
      l_return :=
        case p_level
          when g_off then g_off_name
          when g_permanent then g_permanent_name
          when g_error then g_error_name
          when g_warning then g_warning_name
          when g_information then g_information_name
          when g_debug then g_debug_name
          when g_timing then g_timing_name
          when g_sys_context then g_sys_context_name
          when g_apex then g_apex_name
          else null
        end;
    $end

    return l_return;
  end convert_level_num_to_char;





  /**
   * Determines if the statement can be stored in LOGGER_LOGS
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #44: Expose publically
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Level (number)
   * @return True of statement can be logged to LOGGER_LOGS
   */
  function ok_to_log(p_level in number)
    return boolean
    $if 1=1
      and $$rac_lt_11_2
      and not dbms_db_version.ver_le_10_2
      and ($$no_op is null or not $$no_op) $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
    $end
  is
    l_level number;
    l_level_char varchar2(50);

    $if $$logger_debug $then
      l_scope varchar2(30) := 'ok_to_log';
    $end

  begin
    $if $$no_op $then
      return false;
    $else

      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ': in function');
      $end

      $if $$rac_lt_11_2 $then
        $if $$logger_debug $then
          dbms_output.put_line(l_scope || ': calling get_level_number');
        $end
        l_level := get_level_number;
      $else
        l_level := sys_context(g_context_name,gc_ctx_attr_level);

        if l_level is null then
          $if $$logger_debug $then
            dbms_output.put_line(l_scope || ': level was null, getting and setting in context');
          $end

          l_level := get_level_number;

          save_global_context(
            p_attribute => gc_ctx_attr_level,
            p_value => l_level,
            p_client_id => sys_context('userenv','client_identifier'));
        end if;
      $end

      if l_level >= p_level then
        return true;
      else
        return false;
      end if;
   $end
  end ok_to_log;


  /**
   * Determines if log statements will actually be stored.
   *
   * @author Martin D'Souza
   * @created 25-Jul-2013
   *
   * @param p_level Level (DEBUG etc..)
   * @return True of log statements for that level or below will be logged
   */
  function ok_to_log(p_level in varchar2)
    return boolean
  as
  begin
    $if $$no_op $then
      return false;
    $else
      return ok_to_log(p_level => convert_level_char_to_num(p_level => p_level));
    $end
  end ok_to_log;




  /**
   * ???
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date
   * @return
   */
  function date_text_format (p_date in date)
    return varchar2
  as
  begin
    $if $$no_op $then
      return null;
    $else
      return date_text_format_base(
        p_date_start => p_date   ,
        p_date_stop  => sysdate);
    $end
  end date_text_format;


  function get_character_codes(
    p_string        in varchar2,
    p_show_common_codes   in boolean default true)
    return varchar2
  is
    l_string  varchar2(32767);
    l_dump    varchar2(32767);
    l_return  varchar2(32767);
  begin
    -- replace tabs with ^
    l_string := replace(p_string,chr(9),'^');
    -- replace all other control characters such as carriage return / line feeds with ~
    l_string := regexp_replace(l_string,'[[:cntrl:]]','~',1,0,'m');

    select dump(p_string) into l_dump from dual;

    l_dump  := regexp_replace(l_dump,'(^.+?:)(.*)','\2',1,0); -- get everything after the :
    l_dump  := ','||l_dump||','; -- leading and trailing commas
    l_dump  := replace(l_dump,',',',,'); -- double the commas. this is for the regex.
    l_dump  := regexp_replace(l_dump,'(,)([[:digit:]]{1})(,)','\1  \2\3',1,0); -- lpad all single digit numbers out to 3
    l_dump  := regexp_replace(l_dump,'(,)([[:digit:]]{2})(,)','\1 \2\3',1,0);  -- lpad all double digit numbers out to 3
    l_dump  := ltrim(replace(l_dump,',,',','),','); -- remove the double commas
    l_dump  := lpad(' ',(5-instr(l_dump,',')),' ')||l_dump;

    -- replace every individual character with 2 spaces, itself and a comma so it lines up with the dump output
    l_string := ' '||regexp_replace(l_string,'(.){1}','  \1,',1,0);

    l_return := rtrim(l_dump,',') || chr(10) || rtrim(l_string,',');

    if p_show_common_codes then
      l_return := 'Common Codes: 13=Line Feed, 10=Carriage Return, 32=Space, 9=Tab'||chr(10) ||l_return;
    end if;

    return l_return;

  end get_character_codes;

  /**
   * Store APEX items in logger_logs_apex_items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115: Only log not-null values
   *  - #114: Bulk insert (no more row by row)
   *  - #54: Support for p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_log_id logger_logs.id to reference
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page. It is assumed that it has been validated by the time it hits here.
   * @param p_log_null_items If set to false, null values won't be logged
   */
  procedure snapshot_apex_items(
    p_log_id in logger_logs.id%type,
    p_item_type in varchar2,
    p_log_null_items in boolean)
  is
    l_app_session number;
    l_app_id number;
    l_log_null_item_yn varchar2(1);
    l_item_type varchar2(30) := upper(p_item_type);
    l_item_type_page_id number;
  begin
    $if $$no_op $then
      null;
    $else
      $if $$apex $then
        l_app_session := v('APP_SESSION');
        l_app_id := v('APP_ID');

        l_log_null_item_yn := 'N';
        if p_log_null_items then
          l_log_null_item_yn := 'Y';
        end if;

        if logger.is_number(l_item_type) then
          l_item_type_page_id := to_number(l_item_type);
        end if;

        insert into logger_logs_apex_items(log_id,app_session,item_name,item_value)
        select p_log_id, l_app_session, item_name, item_value
        from (
          -- Application items
          select 1 app_page_seq, 0 page_id, item_name, v(item_name) item_value
          from apex_application_items
          where 1=1
            and application_id = l_app_id
            and l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_app)
          union all
          -- Application page items
          select 2 app_page_seq, page_id, item_name, v(item_name) item_value
          from apex_application_page_items
          where 1=1
            and application_id = l_app_id
            and (
              1=2
              or l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_page)
              or (l_item_type_page_id is not null and l_item_type_page_id = page_id)
            )
          )
        where 1=1
          and (l_log_null_item_yn = 'Y' or item_value is not null)
        order by app_page_seq, page_id, item_name;

      $end -- $if $$apex $then

      null; -- Keep this in place incase APEX is not compiled
    $end -- $$no_op
  end snapshot_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #46: Added plugin support
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_error(
    p_text in varchar2 default null,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
    l_proc_name varchar2(100);
    l_lineno varchar2(100);
    l_text varchar2(32767);
    l_call_stack varchar2(4000);
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_error) then
        get_debug_info(
          p_callstack => dbms_utility.format_call_stack,
          o_unit => l_proc_name,
          o_lineno => l_lineno);

        l_call_stack := dbms_utility.format_error_stack() || gc_line_feed || dbms_utility.format_error_backtrace;

        if p_text is not null then
          l_text := p_text || gc_line_feed || gc_line_feed;
        end if;

        l_text := l_text || dbms_utility.format_error_stack();

        l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

        ins_logger_logs(
          p_unit_name => upper(l_proc_name) ,
          p_scope => p_scope ,
          p_logger_level => logger.g_error,
          p_extra => l_extra,
          p_text => l_text,
          p_call_stack => l_call_stack,
          p_line_no => l_lineno,
          po_id => g_log_id);

        -- Plugin
        $if $$logger_plugin_error $then

          if not g_in_plugin_error then
            g_plug_logger_log_error.logger_level := logger.g_error;
            g_plug_logger_log_error.id := g_log_id;

            $if $$logger_debug $then
              dbms_output.put_line('Starting call to run_plugin error');
            $end

            run_plugin(p_logger_log => g_plug_logger_log_error);
          end if; -- not g_in_plugin_error
        $end

      end if; -- ok_to_log
    $end
  end log_error;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_permanent(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_permanent) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_permanent,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params
        );
      end if;
    $end
  end log_permanent;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warning(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_warning) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_warning,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_warning;


  /**
   * Wrapper for log_warning
   *
   * Notes:
   *  - #80
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 9-9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warn(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_warning(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_warn;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_information(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_information) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_information,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_information;


  /**
   * Wrapper for short call to log_information
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #80
   *
   * @author Martin D'Souza
   * @created 9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_info(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_information(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_info;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin

    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_debug,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log;


  /**
   * Get list of CGI values
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @return CGI values
   */
  function get_cgi_env(
    p_show_null   in boolean default false)
    return clob
  is
    l_cgienv clob;

    $if $$no_op is null or not $$no_op $then
      procedure append_cgi_env(
        p_name    in varchar2,
        p_val   in varchar2)
      is
        r_pad number := 30;
      begin
        if p_show_null or p_val is not null then
          l_cgienv := l_cgienv || rpad(p_name,r_pad,' ')||': '||p_val||gc_cflf;
        end if;
      end append_cgi_env;
    $end

  begin
    $if $$no_op $then
      return null;
    $else
      for i in 1..nvl(owa.num_cgi_vars,0) loop
        append_cgi_env(
          p_name      => owa.cgi_var_name(i),
          p_val       => owa.cgi_var_val(i));

      end loop;

      return l_cgienv;
    $end
  end get_cgi_env;


  /**
   * Logs system environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   * - #29 Support for definging level
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, INSTANCE
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_userenv(
    p_detail_level in varchar2 default 'USER',-- ALL, NLS, USER, INSTANCE,
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_sys_context(
          p_detail_level => p_detail_level,
          p_vertical => true,
          p_show_null => p_show_null);

        log_internal(
          p_text => 'USERENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_userenv;


  /**
   * Logs CGI environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_cgi_env(
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_cgi_env(p_show_null    => p_show_null);
        log_internal(
          p_text => 'CGI ENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_cgi_env;


  /**
   * Logs character codes for given string
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_show_common_codes
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_character_codes(
    p_text in varchar2,
    p_scope in logger_logs.scope%type default null,
    p_show_common_codes in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    l_dump clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_dump := get_character_codes(p_text,p_show_common_codes);

        log_internal(
          p_text => 'GET_CHARACTER_CODES output stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_debug),
          p_scope => p_scope,
          p_extra => l_dump);
      end if;
    $end
  end log_character_codes;


  /**
   * Log's APEX items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115 Only log not-null values
   *  - #29 Support for definging level
   *  - #54: Add p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page.
   * @param p_log_null_items If set to false, null values won't be logged
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_apex_items(
    p_text in varchar2 default 'Log APEX Items',
    p_scope in logger_logs.scope%type default null,
    p_item_type in varchar2 default logger.g_apex_item_type_all,
    p_log_null_items in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then

        $if $$apex $then
          -- Validate p_item_type
          assert(
            p_condition => upper(p_item_type) in (logger.g_apex_item_type_all, logger.g_apex_item_type_app, logger.g_apex_item_type_page) or logger.is_number(p_item_type),
            p_message => logger.sprintf('APEX Item Scope was set to %s. Must be %s, %s, %s, or page number', p_item_type, logger.g_apex_item_type_all, logger.g_apex_item_type_page, logger.g_apex_item_type_page));

          log_internal(
            p_text => p_text,
            p_log_level => nvl(p_level, logger.g_apex),
            p_scope => p_scope);

          snapshot_apex_items(
            p_log_id => g_log_id,
            p_item_type => upper(p_item_type),
            p_log_null_items => p_log_null_items);
        $else
          l_error := 'Error! Logger is not configured for APEX yet. ';

          log_internal(
            p_text => l_error,
            p_log_level => logger.g_apex,
            p_scope => p_scope);
        $end
      end if;
    $end
    commit;
  end log_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Use localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_log_in_table
   */
  procedure time_start(
    p_unit in varchar2,
    p_log_in_table in boolean default true)
  is
    l_proc_name varchar2(100);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := g_running_timers + 1;

        if g_running_timers > 1 then
          -- Use 'a' since lpad requires a value to pad
          l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
        end if;

        g_proc_start_times(p_unit) := localtimestamp;

        l_text := l_pad||'START: '||p_unit;

        if p_log_in_table then
          ins_logger_logs(
            p_unit_name => p_unit ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_start;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73: Remove additional timer decrement since it was already happening in function time_stop
   *
   * @author Tyler Muth
   * @created ???
   * @param p_scope
   * @param p_unit
   */
  procedure time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null)
  is
    l_time_string varchar2(50);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          if g_running_timers > 1 then
            -- Use 'a' since lpad requires a value to pad
            l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
          end if;

          --l_time_string := rtrim(regexp_replace(systimestamp-(g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);
          -- Function time_stop will decrement the timers and pop the name from the g_proc_start_times array
          l_time_string := time_stop(
            p_unit => p_unit,
            p_log_in_table => false);

          l_text := l_pad||'STOP : '||p_unit ||' - '||l_time_string;

          ins_logger_logs(
            p_unit_name => p_unit,
            p_scope => p_scope ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer string
   */
  function time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table IN boolean default true)
    return varchar2
  is
    l_time_string varchar2(50);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          l_time_string := rtrim(regexp_replace(localtimestamp - (g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_time_string,
              po_id => g_log_id);
          end if;

          return l_time_string;

        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer in seconds
   */
  function time_stop_seconds(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true
    )
    return number
  is
    l_time_string varchar2(50);
    l_seconds number;
    l_interval interval day to second;

  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then
          l_interval := localtimestamp - (g_proc_start_times(p_unit));
          l_seconds := extract(day from l_interval) * 86400 + extract(hour from l_interval) * 3600 + extract(minute from l_interval) * 60 + extract(second from l_interval);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_seconds,
              po_id => g_log_id);
          end if;

          return l_seconds;

        end if;
      end if;
    $end
  end time_stop_seconds;


  /**
   * Resets all timers
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure time_reset
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := 0;
        g_proc_start_times.delete;
      end if;
    $end
  end time_reset;

  /**
   * Returns Global or User preference
   * User preference is only valid for LEVEL and INCLUDE_CALL_STACK
   *  - If a user setting exists, it will be returned, if not the system level preference will be return
   *
   * Updates
   *  - 2.0.0: Added user preference support
   *  - 2.1.2: Fixed issue when calling set_level with the same client_id multiple times
   *
   * Related Tickets:
   *  - #127: Added logger_prefs.pref_type
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_pref_name
   * @param p_pref_type Namespace for preference
   */
  function get_pref(
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_type in logger_prefs.pref_type%type default logger.g_pref_type_logger)
    return varchar2
    $if not dbms_db_version.ver_le_10_2  $then
      result_cache
      $if $$no_op is null or not $$no_op $then
        relies_on (logger_prefs, logger_prefs_by_client_id)
      $end
    $end
  is
    l_scope varchar2(30) := 'get_pref';
    l_pref_value logger_prefs.pref_value%type;
    l_client_id logger_prefs_by_client_id.client_id%type;
    l_pref_name logger_prefs.pref_name%type := upper(p_pref_name);
    l_pref_type logger_prefs.pref_type%type := upper(p_pref_type);
  begin

    $if $$no_op $then
      return null;
    $else
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ' select pref');
      $end

      l_client_id := sys_context('userenv','client_identifier');

      select pref_value
      into l_pref_value
      from (
        select pref_value, row_number () over (order by rank) rn
        from (
          -- Client specific logger levels trump system level logger level
          select
            case
              when l_pref_name = logger.gc_pref_level then logger_level
              when l_pref_name = logger.gc_pref_include_call_stack then include_call_stack
            end pref_value,
            1 rank
          from logger_prefs_by_client_id
          where 1=1
            and client_id = l_client_id
            -- Only try to get prefs at a client level if pref is in LEVEL or INCLUDE_CALL_STACK
            and l_client_id is not null
            -- #127
            -- Prefs by client aren't available for custom prefs right now
            -- Only need to search this table if p_pref_type is LOGGER
            and l_pref_type = logger.g_pref_type_logger
            and l_pref_name in (logger.gc_pref_level, logger.gc_pref_include_call_stack)
          union
          -- System level configuration
          select pref_value, 2 rank
          from logger_prefs
          where 1=1
            and pref_name = l_pref_name
            and pref_type = l_pref_type
        )
      )
      where rn = 1;
      return l_pref_value;
    $end

  exception
    when no_data_found then
      return null;
    when others then
      raise;
  end get_pref;


  /**
   * Sets a preference
   * If it does not exist, it will insert one
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 24-APR-2015
   * @param p_pref_type
   * @param p_pref_name
   * @param p_pref_value
   */
  procedure set_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_value in logger_prefs.pref_value%type)
  as
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper(p_pref_name));
  begin

    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not set ' || l_pref_type || '. Reserved for Logger');
      end if;

      merge into logger_prefs p
      using (select l_pref_type pref_type, l_pref_name pref_name, p_pref_value pref_value
             from dual) args
      on ( 1=1
        and p.pref_type = args.pref_type
        and p.pref_name = args.pref_name)
      when matched then
        update
        set p.pref_value =  args.pref_value
      when not matched then
        insert (pref_type, pref_name ,pref_value)
      values
        (args.pref_type, args.pref_name ,args.pref_value);
    $end -- $no_op

  end set_pref;

  /**
   * Removes a Preference
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 30-APR-2015
   *
   * @param p_pref_type
   * @param p_pref_name
   */
  procedure del_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type)
  is
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper (p_pref_name));
  begin
    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not delete ' || l_pref_type || '. Reserved for Logger');
      end if;

      delete from logger_prefs
      where 1=1
        and pref_type = l_pref_type
        and pref_name = l_pref_name;
    $end
  end del_pref;


  /**
   * Purges logger_logs data
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48 Support for overloading
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in number default null,
    p_purge_min_level in number)

  is
    $if $$no_op is null or not $$no_op $then
      l_purge_after_days number := nvl(p_purge_after_days,get_pref(logger.gc_pref_purge_after_days));
    $end
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else

      if admin_security_check then
        delete
          from logger_logs
         where logger_level >= p_purge_min_level
           and time_stamp < systimestamp - NUMTODSINTERVAL(l_purge_after_days, 'day')
           and logger_level > g_permanent;
      end if;
    $end
    commit;
  end purge;


  /**
   * Wrapper for Purge (to accept number for purge_min_level)
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in varchar2 default null,
    p_purge_min_level in varchar2 default null)

  is
  begin
    $if $$no_op $then
      null;
    $else
      purge(
        p_purge_after_days => to_number(p_purge_after_days),
        p_purge_min_level => convert_level_char_to_num(nvl(p_purge_min_level,get_pref(logger.gc_pref_purge_min_level))));
    $end
  end purge;


  /**
   * Purges all records that aren't marked as permanent
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure purge_all
  is
    l_purge_level number  := g_permanent;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if admin_security_check then
        delete from logger_logs where logger_level > l_purge_level;
      end if;
    $end
    commit;
  end purge_all;


  /**
   * Displays Logger's current status
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_output_format SQL-DEVELOPER | HTML | DBMS_OUPUT
   */
  procedure status(
    p_output_format in varchar2 default null) -- SQL-DEVELOPER | HTML | DBMS_OUPUT
  is
    l_debug varchar2(50) := 'Disabled';
    l_apex varchar2(50) := 'Disabled';
    l_flashback varchar2(50) := 'Disabled';
    dummy varchar2(255);
    l_output_format varchar2(30);
    l_version varchar2(20);
    l_client_identifier logger_prefs_by_client_id.client_id%type;

    -- For current client info
    l_cur_logger_level logger_prefs_by_client_id.logger_level%type;
    l_cur_include_call_stack logger_prefs_by_client_id.include_call_stack%type;
    l_cur_expiry_date logger_prefs_by_client_id.expiry_date%type;

    procedure display_output(
      p_name  in varchar2,
      p_value in varchar2)
    is
    begin
      if l_output_format = 'SQL-DEVELOPER' then
        dbms_output.put_line('<pre>'||rpad(p_name,25)||': <strong>'||p_value||'</strong></pre>');
      elsif l_output_format = 'HTTP' then
        htp.p('<br />'||p_name||': <strong>'||p_value||'</strong>');
      else
        dbms_output.put_line(rpad(p_name,25)||': '||p_value);
      end if;
    end display_output;

  begin
    if p_output_format is null then
      begin
        dummy := owa_util.get_cgi_env('HTTP_HOST');
        l_output_format := 'HTTP';
      exception
        when value_error then
        l_output_format := 'DBMS_OUTPUT';
        dbms_output.enable;
      end;
    else
      l_output_format := p_output_format;
    end if;

    display_output('Project Home Page','https://github.com/oraopensource/logger/');

    $if $$no_op $then
      display_output('Debug Level','NO-OP, Logger completely disabled.');
    $else
      $if $$apex $then
        l_apex := 'Enabled';
      $end

      select pref_value
      into l_debug
      from logger_prefs
      where 1=1
        and pref_type = logger.g_pref_type_logger
        and pref_name = logger.gc_pref_level;

      $if $$flashback_enabled $then
        l_flashback := 'Enabled';
      $end

      l_version := get_pref(logger.gc_pref_logger_version);

      display_output('Logger Version',l_version);
      display_output('Debug Level',l_debug);
      display_output('Capture Call Stack',get_pref(logger.gc_pref_include_call_stack));
      display_output('Protect Admin Procedures',get_pref(logger.gc_pref_protect_admin_procs));
      display_output('APEX Tracing',l_apex);
      display_output('SCN Capture',l_flashback);
      display_output('Min. Purge Level',get_pref(logger.gc_pref_purge_min_level));
      display_output('Purge Older Than',get_pref(logger.gc_pref_purge_after_days)||' days');
      display_output('Pref by client_id expire hours',get_pref(logger.gc_pref_client_id_expire_hours)||' hours');
      $if $$rac_lt_11_2  $then
        display_output('RAC pre-11.2 Code','TRUE');
      $end

      -- #46 Only display plugins if enabled
      $if $$logger_plugin_error $then
        display_output('PLUGIN_FN_ERROR',get_pref(logger.gc_pref_plugin_fn_error));
      $end

      -- #64
      $if $$logger_debug $then
        display_output('LOGGER_DEBUG',get_pref(logger.gc_pref_logger_debug) || '   *** SHOULD BE TURNED OFF!!! SET TO FALSE ***');
      $end


      l_client_identifier := sys_context('userenv','client_identifier');
      if l_client_identifier is not null then
        -- Since the client_identifier exists, try to see if there exists a record session sepecfic logging level
        -- Note: this query should only return 0..1 rows
        begin
          select logger_level, include_call_stack, expiry_date
          into l_cur_logger_level, l_cur_include_call_stack, l_cur_expiry_date
          from logger_prefs_by_client_id
          where client_id = l_client_identifier;

          display_output('Client Identifier', l_client_identifier);
          display_output('Client - Debug Level', l_cur_logger_level);
          display_output('Client - Call Stack', l_cur_include_call_stack);
          display_output('Client - Expiry Date', logger.tochar(l_cur_expiry_date));
        exception
          when no_data_found then
            null; -- No client specific logging set
          when others then
            raise;
        end;
      end if; -- client_identifier exists

      display_output('For all client info see', 'logger_prefs_by_client_id');

    $end
  end status;


  /**
   * Sets the logger level
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #60 Allow security check to be bypassed for client specific logging level
   *  - #48 Allow of numbers to be passed in p_level. Did not overload (see ticket comments as to why)
   *  - #110 Clear context values when level changes globally
   *  - #29 If p_level is deprecated, set to DEBUG
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Valid values: OFF,PERMANENT,ERROR,WARNING,INFORMATION,DEBUG,TIMING
   * @param p_client_id Optional: If defined, will set the level for the given client identifier. If null will affect global settings
   * @param p_include_call_stack Optional: Only valid if p_client_id is defined Valid values: TRUE, FALSE. If not set will use the default system pref in logger_prefs.
   * @param p_client_id_expire_hours If p_client_id, expire after number of hours. If not defined, will default to system preference PREF_BY_CLIENT_ID_EXPIRE_HOURS
   */
  procedure set_level(
    p_level in varchar2 default logger.g_debug_name,
    p_client_id in varchar2 default null,
    p_include_call_stack in varchar2 default null,
    p_client_id_expire_hours in number default null
  )
  is
    l_level varchar2(20);
    l_ctx varchar2(2000);
    l_include_call_stack varchar2(255);
    l_client_id_expire_hours number;
    l_expiry_date logger_prefs_by_client_id.expiry_date%type;

    l_id logger_logs.id%type;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      raise_application_error (-20000,
          'Either the NO-OP version of Logger is installed or it is compiled for NO-OP,  so you cannot set the level.');
    $else
      l_level := replace(upper(p_level),' ');

      if is_number(p_str => l_level) then
        l_level := convert_level_num_to_char(p_level => p_level);
      end if;

      l_include_call_stack := nvl(trim(upper(p_include_call_stack)), get_pref(logger.gc_pref_include_call_stack));

      assert(
          l_level in (g_off_name, g_permanent_name, g_error_name, g_warning_name, g_information_name, g_debug_name, g_timing_name, g_sys_context_name, g_apex_name),
        '"LEVEL" must be one of the following values: ' ||
          g_off_name || ', ' || g_permanent_name || ', ' || g_error_name || ', ' || g_warning_name || ', ' ||
          g_information_name || ', ' || g_debug_name || ', ' || g_timing_name || ', ' ||
          g_sys_context_name || ', ' || g_apex_name );
      assert(l_include_call_stack in ('TRUE', 'FALSE'), 'l_include_call_stack must be TRUE or FALSE');

      -- #60 Allow security check to be bypassed for client specific logging level
      if p_client_id is not null or admin_security_check then
        l_ctx := 'Host: '||sys_context('USERENV','HOST');
        l_ctx := l_ctx || ', IP: '||sys_context('USERENV','IP_ADDRESS');
        l_ctx := l_ctx || ', TERMINAL: '||sys_context('USERENV','TERMINAL');
        l_ctx := l_ctx || ', OS_USER: '||sys_context('USERENV','OS_USER');
        l_ctx := l_ctx || ', CURRENT_USER: '||sys_context('USERENV','CURRENT_USER');
        l_ctx := l_ctx || ', SESSION_USER: '||sys_context('USERENV','SESSION_USER');

        -- #29 Deprecate old levels. Log and set to DEBUG
        if l_level in (logger.g_apex_name, logger.g_sys_context_name, logger.g_timing_name)  then
          logger.ins_logger_logs(
            p_logger_level => logger.g_warning,
            p_text =>
              logger.sprintf('Logger level: %s1 is deprecated. Set for client_id %s2. Automatically setting to %s3', l_level, nvl(p_client_id, '<global>'), logger.g_debug_name),
            po_id => l_id);

          l_level := logger.g_debug_name;
        end if;


        -- Separate updates/inserts for client_id or global settings
        if p_client_id is not null then
          l_client_id_expire_hours := nvl(p_client_id_expire_hours, get_pref(logger.gc_pref_client_id_expire_hours));
          l_expiry_date := sysdate + l_client_id_expire_hours/24;

          merge into logger_prefs_by_client_id ci
          using (select p_client_id client_id from dual) s
            on (ci.client_id = s.client_id)
          when matched then update
            set logger_level = l_level,
              include_call_stack = l_include_call_stack,
              expiry_date = l_expiry_date,
              created_date = sysdate
          when not matched then
            insert(ci.client_id, ci.logger_level, ci.include_call_stack, ci.created_date, ci.expiry_date)
            values(p_client_id, l_level, l_include_call_stack, sysdate, l_expiry_date)
          ;

        else
          -- Global settings
          update logger_prefs
          set pref_value = l_level
          where 1=1
            and pref_type = logger.g_pref_type_logger
            and pref_name = logger.gc_pref_level;
        end if;

        -- #110 Need to reset all contexts so that level is reset for sessions where client_identifier is defined
        -- This is required for global changes since sessions with client_identifier set won't be properly updated.
        if p_client_id is null then
          logger.null_global_contexts;
        end if;

        logger.save_global_context(
          p_attribute => gc_ctx_attr_level,
          p_value => logger.convert_level_char_to_num(l_level),
          p_client_id => p_client_id); -- Note: if p_client_id is null then it will set for global`

        -- Manual insert to ensure that data gets logged, regardless of logger_level
        logger.ins_logger_logs(
          p_logger_level => logger.g_information,
          p_text => 'Log level set to ' || l_level || ' for client_id: ' || nvl(p_client_id, '<global>') || ', include_call_stack=' || l_include_call_stack || ' by ' || l_ctx,
          po_id => l_id);

      end if; -- p_client_id is not null or admin_security_check
    $end
    commit;
  end set_level;


  /**
   * Unsets a logger level for a given client_id
   * This will only unset for client specific logger levels
   * Note: An explicit commit will occur in this procedure
   *
   * @author Martin D'Souza
   * @created 6-Apr-2013
   *
   * @param p_client_id Client identifier (case sensitive) to unset logger level in.
   */
  procedure unset_client_level(p_client_id in varchar2)
  as
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      assert(p_client_id is not null, 'p_client_id is a required value');

      -- Remove from client specific table
      delete from logger_prefs_by_client_id
      where client_id = p_client_id;

      -- Remove context values
      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_level);

      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_include_call_stack);

    $end

    commit;
  end unset_client_level;


  /**
   * Unsets client_level that are stale (i.e. past thier expiry date)
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   * @param p_unset_after_hours If null then preference UNSET_CLIENT_ID_LEVEL_AFTER_HOURS
   */
  procedure unset_client_level
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (
        select client_id
        from logger_prefs_by_client_id
        where sysdate > expiry_date) loop

        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level;


  /**
   * Unsets all client specific preferences
   * An implicit commit will occur as unset_client_level makes a commit
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   */
  procedure unset_client_level_all
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (select client_id from logger_prefs_by_client_id) loop
        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level_all;


  /**
   * Displays commonly used dbms_output SQL*Plus settings
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure sqlplus_format
  is
  begin
    execute immediate 'begin dbms_output.enable(1000000); end;';
    dbms_output.put_line('set linesize 200');
    dbms_output.put_line('set pagesize 100');

    dbms_output.put_line('column id format 999999');
    dbms_output.put_line('column text format a75');
    dbms_output.put_line('column call_stack format a100');
    dbms_output.put_line('column extra format a100');

  end sqlplus_format;

  /**
   * Converts parameter to varchar2
   *
   * Notes:
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *  - Need to call this tochar instead of to_char since there will be a conflict when calling it
   *
   * Related Tickets:
   *  - #68
   *
   * @author Martin D'Souza
   * @created 07-Jun-2014
   * @param p_value
   * @return varchar2 value for p_value
   */
  function tochar(
    p_val in number)
    return varchar2
  as
  begin
    return to_char(p_val);
  end tochar;

  function tochar(
    p_val in date)
    return varchar2
  as
  begin
    return to_char(p_val, gc_date_format);
  end tochar;

  function tochar(
    p_val in timestamp)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_format);
  end tochar;

  function tochar(
    p_val in timestamp with time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  function tochar(
    p_val in timestamp with local time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  -- #119: Return null for null booleans
  function tochar(
    p_val in boolean)
    return varchar2
  as
  begin
    return case p_val when true then 'TRUE' when false then 'FALSE' else null end;
  end tochar;



  -- Handle Parameters

  /**
   * Append parameter to table of parameters
   * Nothing is actually logged in this procedure
   * This procedure is overloaded
   *
   * Related Tickets:
   *  - #67: Updated to reference to_char functions
   *
   * @author Martin D'Souza
   * @created 19-Jan-2013
   *
   * @param p_params Table of parameters (param will be appended to this)
   * @param p_name Name
   * @param p_val Value in its format. Will be converted to string
   */
  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in varchar2
  )
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      l_param.name := p_name;
      l_param.val := p_val;
      p_params(p_params.count + 1) := l_param;
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in number)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in date)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with local time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in boolean)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;


  /**
   * Handles inserts into LOGGER_LOGS.
   *
   * Replaces trigger for both performance issues and to be a single location for all insert statements
   *
   * autonomous_transaction so commit will be performed after insert
   *
   * @author Martin D'Souza
   * @created 30-Jul-2013
   *
   * Related Issues
   *  - #31: Initial ticket
   *  - #51: Added SID column
   *  - #70: Fixed missing no_op flag
   *  - #109: Fix length check for multibyte characters
   *
   * @param p_logger_level
   * @param p_text
   * @param p_scope
   * @param p_call_stack
   * @param p_unit_name
   * @param p_line_no
   * @param p_extra
   * @param po_id ID entered into logger_logs for this record
   */
  procedure ins_logger_logs(
    p_logger_level in logger_logs.logger_level%type,
    p_text in varchar2 default null, -- Not using type since want to be able to pass in 32767 characters
    p_scope in logger_logs.scope%type default null,
    p_call_stack in logger_logs.call_stack%type default null,
    p_unit_name in logger_logs.unit_name%type default null,
    p_line_no in logger_logs.line_no%type default null,
    p_extra in logger_logs.extra%type default null,
    po_id out nocopy logger_logs.id%type
    )
  as
    pragma autonomous_transaction;

    l_id logger_logs.id%type;
    l_text varchar2(32767) := p_text;
    l_extra logger_logs.extra%type := p_extra;
    l_tmp_clob clob;

  begin
    $if $$no_op $then
      null;
    $else
      -- Using select into to support version older than 11gR1 (see Issue 26)
      select logger_logs_seq.nextval
      into po_id
      from dual;

      -- 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column (Issue 17)
      $if $$large_text_column $then -- Only check for moving to Clob if small text column
        -- Don't do anything since column supports large text
      $else
        if lengthb(l_text) > 4000 then -- #109 Using lengthb for multibyte characters
          if l_extra is null then
            l_extra := l_text;
          else
            -- Using temp clob for performance purposes: http://www.talkapex.com/2009/06/how-to-quickly-append-varchar2-to-clob.html
            l_tmp_clob := gc_line_feed || gc_line_feed || '*** Content moved from TEXT column ***' || gc_line_feed;
            l_extra := l_extra || l_tmp_clob;
            l_tmp_clob := l_text;
            l_extra := l_extra || l_text;
          end if; -- l_extra is not null

          l_text := 'Text moved to EXTRA column';
        end if; -- length(l_text)
      $end

      insert into logger_logs(
        id, logger_level, text,
        time_stamp, scope, module,
        action,
        user_name,
        client_identifier,
        call_stack, unit_name, line_no ,
        scn,
        extra,
        sid,
        client_info
        )
       values(
         po_id, p_logger_level, l_text,
         systimestamp, lower(p_scope), sys_context('userenv','module'),
         sys_context('userenv','action'),
         nvl($if $$apex $then apex_application.g_user $else user $end,user),
         sys_context('userenv','client_identifier'),
         p_call_stack, upper(p_unit_name), p_line_no,
         null,
         l_extra,
         to_number(sys_context('userenv','sid')),
         sys_context('userenv','client_info')
         );

    $end -- $$NO_OP

    commit;
  end ins_logger_logs;


  /**
   * Does string replacement similar to C's sprintf
   *
   * Notes:
   *  - Uses the following replacement algorithm (in following order)
   *    - Replaces %s<n> with p_s<n>
   *    - Occurrences of %s (no number) are replaced with p_s1..p_s10 in order that they appear in text
   *    - %% is escaped to %
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *
   * Related Tickets:
   *  - #32: Also see #59
   *  - #95: Remove no_op clause
   *
   * @author Martin D'Souza
   * @created 15-Jun-2014
   * @param p_str Messsage to format using %s and %d replacement strings
   * @param p_s1
   * @param p_s2
   * @param p_s3
   * @param p_s4
   * @param p_s5
   * @param p_s6
   * @param p_s7
   * @param p_s8
   * @param p_s9
   * @param p_s10
   * @return p_msg with strings replaced
   */
  function sprintf(
    p_str in varchar2,
    p_s1 in varchar2 default null,
    p_s2 in varchar2 default null,
    p_s3 in varchar2 default null,
    p_s4 in varchar2 default null,
    p_s5 in varchar2 default null,
    p_s6 in varchar2 default null,
    p_s7 in varchar2 default null,
    p_s8 in varchar2 default null,
    p_s9 in varchar2 default null,
    p_s10 in varchar2 default null)
    return varchar2
  as
    l_return varchar2(4000);
    c_substring_regexp constant varchar2(10) := '%s';

  begin
    l_return := p_str;

    -- Replace %s<n> with p_s<n>``
    for i in 1..10 loop
      l_return := regexp_replace(l_return, c_substring_regexp || i,
        case
          when i = 1 then p_s1
          when i = 2 then p_s2
          when i = 3 then p_s3
          when i = 4 then p_s4
          when i = 5 then p_s5
          when i = 6 then p_s6
          when i = 7 then p_s7
          when i = 8 then p_s8
          when i = 9 then p_s9
          when i = 10 then p_s10
          else null
        end,
        1,0,'c');
    end loop;

    $if $$logger_debug $then
      dbms_output.put_line('Before sys.utl_lms: ' || l_return);
    $end

    -- Replace any occurences of %s with p_s<n> (in order) and escape %% to %
    l_return := sys.utl_lms.format_message(l_return,p_s1, p_s2, p_s3, p_s4, p_s5, p_s6, p_s7, p_s8, p_s9, p_s10);

    return l_return;

  end sprintf;


  /**
   * Returns the rec_logger_logs for given logger_level
   * Used for plugin.
   * Not meant to be called by general public, and thus not documented
   *
   * Notes:
   *  - -- FUTURE mdsouza: Add tests for this (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_level Logger level of plugin wanted to return
   * @return Logger rec based on plugin type
   */
  function get_plugin_rec(
    p_logger_level in logger_logs.logger_level%type)
    return logger.rec_logger_log
  as
  begin

    if p_logger_level = logger.g_error then
      return g_plug_logger_log_error;
    end if;
  end get_plugin_rec;

end logger;

/
--------------------------------------------------------
--  DDL for Package Body OAC$ANSIBLE_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" as

/*
author: Jaydipsinh Raulji
*/
PROCEDURE do_rest_call (
    p_url            IN VARCHAR2,
    p_http_method    IN VARCHAR2 DEFAULT 'GET',
    p_content_type   IN VARCHAR2 DEFAULT g_content_type,
    p_body           IN CLOB DEFAULT NULL,
    p_response       OUT CLOB
)
    AS
BEGIN
    apex_web_service.g_request_headers(1).name    := 'Content-Type';
    apex_web_service.g_request_headers(1).value   := p_content_type;
    
    dbms_output.put_line('inside p_content_type: ' ||p_content_type);
    dbms_output.put_line('inside p_url: ' ||p_url);
    dbms_output.put_line('inside p_http_method: ' ||p_http_method);
    dbms_output.put_line('inside p_username: ' ||p_username);
    dbms_output.put_line('inside p_password: ' ||p_password);
    dbms_output.put_line('inside g_wallet_path: ' ||g_wallet_path);
    dbms_output.put_line('inside g_wallet_pass: ' ||g_wallet_pass);
    dbms_output.put_line('inside p_body: ' ||p_body);
    

    IF
        p_body IS NOT NULL
    THEN
        dbms_output.put_line('with p_body: ');

        p_response   := apex_web_service.make_rest_request(
            p_url           => p_url,
            p_http_method   => p_http_method,
            p_username      => p_username,
            p_password      => p_password,
            p_wallet_path   => g_wallet_path,
            p_wallet_pwd    => g_wallet_pass,
            p_body          => p_body
        );
    ELSE
        dbms_output.put_line('without p_body: ');

        p_response   := apex_web_service.make_rest_request(
            p_url           => p_url,
            p_http_method   => p_http_method,
            p_username      => p_username,
            p_password      => p_password,
            p_wallet_path   => g_wallet_path,
            p_wallet_pwd    => g_wallet_pass
        );
    END IF;
--dbms_output.put_line('inside do_rest_call: ' ||p_response);

  INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response,
     body
    ) values (
    p_http_method,
    p_url,
     p_response,
     p_body
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside do_rest_call: ' ||p_url ||'' ||sqlerrm);
        p_response   := sqlerrm;
END do_rest_call;
   
 procedure make_rest_call   (p_flag in varchar2 default g_flag
                            ,p_id in number
                            ,p_param_json in varchar2
                            --,p_job_id out number
                            ,p_response out clob)
 as
  l_buffer         varchar2(32767);
  l_amount         number := 32000 ;
  l_offset         number := 1;
  l_clob           clob;
  v_id number;
  v_url varchar2(100);
  v_status varchar2(100);
  v_result_stdout clob;
  v_job_name varchar2(255);
 begin
  /*
  dbms_output.put_line('In make rest:'||substr(p_param_json,1,800) );
  dbms_output.put_line('In make rest flag:'||p_flag );
  dbms_output.put_line('Make URL:'||g_endpoint_prefix|| case when p_flag = 'W' then g_workflow_template else g_playbook_template end || p_id ||'/launch/');
  */
  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := g_content_type ; --'application/json'; 
  -- host should be dbtest04.techlab.com 
  /***/
  -- Setting Ask variable true.
    v_job_name:= oac$ansible_rest_utl.get_name(p_flag,p_id);
    set_ask_variable(g_endpoint_prefix|| case when p_flag = 'W' then g_workflow_template else g_playbook_template end || p_id ||'/',v_job_name,'true');
    
  
  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| case when p_flag = 'W' then g_workflow_template else g_playbook_template end || p_id ||'/launch/',
              p_http_method => 'POST',
              p_username => p_username ,
              p_password => p_password ,      
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => '{ 
                           "extra_vars": {
                             ' || p_param_json ||'
                             }
                          }'
              );
              
              INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response,
     body
    ) values (
    'POST',
    g_endpoint_prefix|| case when p_flag = 'W' then g_workflow_template else g_playbook_template end || p_id ||'/launch/',
     l_clob,
     '{ 
                           "extra_vars": {
                             ' || p_param_json ||'
                             }
                          }'
    );
   /* Changed MGP to ask for extra vars
  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| case when p_flag = 'W' then g_workflow_template else g_playbook_template end || p_id ||'/launch/',
              p_http_method => 'POST',
              p_username => p_username ,
              p_password => p_password ,      
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => '{
                           "extra_vars": {
                             ' || p_param_json ||'
                             }
                          }'
              );
  */
        -- we have separate function to parse data      
 /*   begin
        loop
            dbms_lob.read( l_clob, l_amount, l_offset, l_buffer );

            apex_json.parse(l_buffer);
            p_job_id := apex_json.get_varchar2(p_path => 'id')   ;  
            -- here we do parse response in order to enter into table.
             v_id := apex_json.get_varchar2(p_path => 'id')   ;     
             v_url := apex_json.get_varchar2(p_path => 'url')   ; 
             v_status := apex_json.get_varchar2(p_path => 'status')   ;     
             v_result_stdout := apex_json.get_varchar2(p_path => 'result_stdout');            

            --htp.p('ID : ' || apex_json.get_varchar2(p_path => 'id'));
            --htp.p('<br>');
            --htp.p(l_buffer);
            l_offset := l_offset + l_amount;
            l_amount := 32000;
        end loop;
    exception
        when no_data_found then
            null;
    end;

    */

    -- insert into the table.
       -- insert into V_SELF_SERVICE_STATUS (REQUEST_TYPE,JOB_NAME,JOB_NO,JOB_RESULT,TICKET_REF,TARGET_NAME,JOB_URL,RESULT_STDOUT)
       -- values ('PROVISIONING','Oracle Prechecks', v_id, v_status,:p20_TICKET_REF,:p20_CLUSTER_HOST, v_url, v_result_stdout);    
    p_response  := l_clob;    

 end make_rest_call;


procedure parse_and_store_resp (p_request_type in varchar2, -- e.g. provisioning
                                p_job_name in varchar2,     -- e.g. oracleprechecks
                                p_ticket_ref in varchar2,   -- e.g. 
                                p_target_name in varchar2,  -- e.g. this can be cluster name when cluster type or host name when host/standalone req. made
                                p_resp_clob in clob,
                                p_id out number,
                                p_request_id out number) 
as
  l_clob clob;
  l_buffer         varchar2(32767);
  l_amount         number;
  l_offset         number;
  l_response       clob;
--  l_endpoint       varchar2 (255) := 'https://tower.techlab.com/api/v2/job_templates/252/launch/';
  v_id number;
  v_request_id  number;
  v_url varchar2(100);
  v_status varchar2(100);
  v_result_stdout clob;
  v_sqlerrm varchar2(4000);
begin
    l_amount    := 32000;
    l_offset    := 1;
    l_clob      := p_resp_clob;
    begin
        loop
            dbms_lob.read( l_clob, l_amount, l_offset, l_buffer );
             apex_json.parse(l_buffer);                  
             v_id := apex_json.get_varchar2(p_path => 'id')   ;     
             v_url := apex_json.get_varchar2(p_path => 'url')   ; 
             v_status := apex_json.get_varchar2(p_path => 'status')   ;     
             v_result_stdout := apex_json.get_varchar2(p_path => 'result_stdout');

            l_offset := l_offset + l_amount;
            l_amount := 32000;
        end loop;        
    exception
      when no_data_found then
         null;
    end;
    -- assign the id parsed from the response.
        p_id := v_id;
        -- log the response entry.
        begin
         insert into V_SELF_SERVICE_STATUS (REQUEST_TYPE,JOB_NAME,JOB_NO,JOB_RESULT,TICKET_REF,TARGET_NAME,JOB_URL,RESULT_STDOUT)
         values (p_request_type,p_job_name, v_id, v_status,p_ticket_ref,p_target_name,v_url, v_result_stdout) 
            returning request_id into v_request_id ;
        exception when others then null;
          v_sqlerrm := SQLERRM;
          dbms_output.put_line('StoreFailed:'||v_sqlerrm);
        end;   
       -- assign the request record id created in table. 
        p_request_id := v_request_id; 

end parse_and_store_resp;

procedure do_cluster_workflow_rest (  p_job_name in varchar2,
                                      p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
--v_job_name      varchar2(50):= 'oracle-rac-install';
v_job_name varchar2(50) := p_job_name; 
v_workflow_id   number ;-- := get_id(g_workflow,v_job_name) ;
--v_workflow_id   number := 258 ;


begin

v_workflow_id   := get_id(g_workflow,v_job_name) ;
null;
    v_param_json :=
       '"host": "'       || p_host_name || '" ,
       "cluster_name": "'    || p_cluster_name || '",
       "cluster_type": "'    || p_cluster_type ||'",
       "gi_version": "'      || p_gi_version ||'",
       "env_source": "'      || p_env_source ||'",
       "application_name":"'  || p_application_name ||'",
       "business_unit": "'   || p_business_unit ||'",
       "network_type": "'    || p_network_type || '",
       "oracle_version": "'  || p_oracle_version ||'",
       "os_type": "'         || p_os_type ||'",
       "os_type_version": "' || p_os_type_version ||'",
       "phy_virt": "'        || p_phy_vert ||'",
       "clustered": "'       || p_clustered ||'",
       "dc_location": "'     || p_dc_location ||'",
       "server_monitoring_tool":"' || p_server_monitoring_tool ||'",
       "oracle_db_name": "'  || p_oracle_db_name ||'",
       "db_environment": "'  || p_db_environment || '",
       "rac_type": "'        || p_rac_type ||'",
       "database_role": "'   || p_database_role ||'",
       "env_category": "'    || p_env_category ||'",
       "storage_type": "'    || p_storage_type ||'",
       "db_monitoring_tool":"' || p_db_monitoring_tool ||'",
       "appliance": "'       || p_appliance ||'",
       "pci_required": "'    || p_pci_required ||'",
       "sox_required": "'    || p_sox_required ||'",
       "encryption_required": "' || p_encryption_required ||'",
       "backup_enabled": "'  || p_backup_enabled ||'",
       "monitoring": "'      || p_monitoring ||'"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => 'W',
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_cluster_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_cluster_workflow_rest;

procedure do_standalone_workflow_rest(p_job_name in varchar2,
                                      p_host_name in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_network_type in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_phy_vert in varchar2,
									  p_database_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name varchar2(50) := p_job_name;
--v_job_name      varchar2(50):= 'oracle-standalone-install';
--v_workflow_id   number := 249 ;
v_workflow_id   number ;--:= get_id(g_workflow,v_job_name) ;

begin
/*
if p_db_option = 'DB' then
    v_job_name  := 'Standalone-withDB';
else
    v_job_name  := 'Standalone-none-DB-Creation';
end if;
*/

v_workflow_id   := get_id(g_workflow,v_job_name) ;
null;
    v_param_json :=
       '"host": "'        || p_host_name || '" ,
       "oracle_version": "'    || p_oracle_version || '",
       "os_type": "'           || p_os_type ||'",
       "os_type_version": "'   || p_os_type_version ||'",
       "env_source": "'      || p_env_source ||'",
       "p_ticket_ref": "'      || p_ticket_ref || '",
       "network_type": "'      || p_network_type ||'",
       "dc_location":"'         || p_dc_location ||'",
       "server_monitoring_tool": "' || p_server_monitoring_tool ||'",
       "phy_virt": "'               || p_phy_vert || '",
       "oracle_db_name": "'          || p_database_name ||'",
       "db_environment": "'         || p_db_environment ||'",
       "rac_type": "'               || p_rac_type||'",
       "database_role": "'          || p_database_role ||'",
       "storage_type": "'           || p_storage_type ||'",
       "db_monitoring_tool": "'     || p_db_monitoring_tool ||'",
       "appliance":"'                || p_appliance ||'",
       "pci_required": "'           || p_pci_required ||'",
       "sox_required": "'           || p_sox_required ||'",
       "encryption_required": "'    || p_encryption_required ||'",
       "backup_enabled": "'         || p_backup_enabled ||'",
       "monitoring": "'             || p_monitoring ||'"';

    -- make a rest call.

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => 'W',
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    
      dbms_output.put_line('v_response: ' ||v_response);
   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

      p_job_id := v_job_id;

end do_standalone_workflow_rest;


procedure do_cluster_workflow_rest (  p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'oracle-rac-install';
v_workflow_id   number := 258 ;
begin
null;
    v_param_json :=
       '"host": "'       || p_host_name || '" ,
       "cluster_name": "'    || p_cluster_name || '",
       "cluster_type": "'    || p_cluster_type ||'",
       "gi_version": "'      || p_gi_version ||'",
       "env_source": "'      || p_env_source ||'",
       "application_name":"'  || p_application_name ||'",
       "business_unit": "'   || p_business_unit ||'",
       "network_type": "'    || p_network_type || '",
       "oracle_version": "'  || p_oracle_version ||'",
       "os_type": "'         || p_os_type ||'",
       "os_type_version": "' || p_os_type_version ||'",
       "phy_virt": "'        || p_phy_vert ||'",
       "clustered": "'       || p_clustered ||'",
       "dc_location": "'     || p_dc_location ||'",
       "server_monitoring_tool":"' || p_server_monitoring_tool ||'",
       "oracle_db_name": "'  || p_oracle_db_name ||'",
       "db_environment": "'  || p_db_environment || '",
       "rac_type": "'        || p_rac_type ||'",
       "database_role": "'   || p_database_role ||'",
       "env_category": "'    || p_env_category ||'",
       "storage_type": "'    || p_storage_type ||'",
       "db_monitoring_tool":"' || p_db_monitoring_tool ||'",
       "appliance": "'       || p_appliance ||'",
       "pci_required": "'    || p_pci_required ||'",
       "sox_required": "'    || p_sox_required ||'",
       "encryption_required": "' || p_encryption_required ||'",
       "backup_enabled": "'  || p_backup_enabled ||'",
       "monitoring": "'      || p_monitoring ||'"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => 'W',
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_cluster_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_cluster_workflow_rest;

procedure do_standalone_workflow_rest(p_host_name in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_network_type in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_phy_vert in varchar2,
									  p_database_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2,
                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'oracle-standalone-install';
v_workflow_id   number := 249 ;

begin
null;
    v_param_json :=
       '"host": "'        || p_host_name || '" ,
       "oracle_version": "'    || p_oracle_version || '",
       "os_type": "'           || p_os_type ||'",
       "os_type_version": "'   || p_os_type_version ||'",
       "env_source": "'      || p_env_source ||'",
       "p_ticket_ref": "'      || p_ticket_ref || '",
       "network_type": "'      || p_network_type ||'",
       "dc_location":"'         || p_dc_location ||'",
       "server_monitoring_tool": "' || p_server_monitoring_tool ||'",
       "phy_virt": "'               || p_phy_vert || '",
       "oracle_db_name": "'          || p_database_name ||'",
       "db_environment": "'         || p_db_environment ||'",
       "rac_type": "'               || p_rac_type||'",
       "database_role": "'          || p_database_role ||'",
       "storage_type": "'           || p_storage_type ||'",
       "db_monitoring_tool": "'     || p_db_monitoring_tool ||'",
       "appliance":"'                || p_appliance ||'",
       "pci_required": "'           || p_pci_required ||'",
       "sox_required": "'           || p_sox_required ||'",
       "encryption_required": "'    || p_encryption_required ||'",
       "backup_enabled": "'         || p_backup_enabled ||'",
       "monitoring": "'             || p_monitoring ||'"';

    -- make a rest call.

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => 'W',
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

      p_job_id := v_job_id;

end do_standalone_workflow_rest;

procedure add_host (p_inventory_id in number default g_default_inventory_id, p_host_name in varchar2,p_response out clob)
as 

  v_param_json    clob;
  l_clob           clob;

/*  v_response      clob;
  l_buffer         varchar2(32767);
  l_amount         number := 32000 ;
  l_offset         number := 1;
  l_clob           clob;
  v_id number;
  v_url varchar2(100);
  v_status varchar2(100);
  v_result_stdout clob;*/
begin
    null;

   --"name": "'|| p_host_name || g_tower_domain ||'" ,  
   -- MGP 18-NOV Took off addng the domain when adding the host
    v_param_json :=
       '{
       "name": "'|| p_host_name ||'" ,
       "description": "",
       "inventory": "'|| p_inventory_id ||'",
       "enabled": "true",
       "instance_id": "",
       "variables":""
       }';


  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := g_content_type ; --'application/json'; 
  -- host should be dbtest04.techlab.com 
  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| g_host_template  ,
              p_http_method => 'POST',
              p_username => p_username ,
              p_password => p_password ,
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => v_param_json
              /*p_body => '{
                           "extra_vars": {
                             ' || v_param_json ||'
                             }
                          }'*/
              );
        -- we have separate function to parse data      
 /*   begin
        loop
            dbms_lob.read( l_clob, l_amount, l_offset, l_buffer );

            apex_json.parse(l_buffer);
            p_job_id := apex_json.get_varchar2(p_path => 'id')   ;  
            -- here we do parse response in order to enter into table.
             v_id := apex_json.get_varchar2(p_path => 'id')   ;     
             v_url := apex_json.get_varchar2(p_path => 'url')   ; 
             v_status := apex_json.get_varchar2(p_path => 'status')   ;     
             v_result_stdout := apex_json.get_varchar2(p_path => 'result_stdout');            

            --htp.p('ID : ' || apex_json.get_varchar2(p_path => 'id'));
            --htp.p('<br>');
            --htp.p(l_buffer);
            l_offset := l_offset + l_amount;
            l_amount := 32000;
        end loop;
    exception
        when no_data_found then
            null;
    end;

    */
    p_response  := l_clob;
 exception 
    when others then null;  
end add_host;

-- This function intake url and get the id for the playbook/workflows.
FUNCTION get_id ( p_url VARCHAR2 ) RETURN NUMBER IS
    v_id       NUMBER;
    l_clob     CLOB;
    l_amount   NUMBER;
    l_offset   NUMBER;
    l_buffer   VARCHAR2(32767);
BEGIN
    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type;
    l_clob := apex_web_service.make_rest_request(
        p_url           => p_url,
        p_http_method   => 'GET',
        p_username      => p_username,
        p_password      => p_password,
        p_wallet_path   => g_wallet_path,
        p_wallet_pwd    => g_wallet_pass
    );
    dbms_output.put_line('URL is : ' || p_url);
    dbms_output.put_line('Response  is : ' || l_clob);
    l_amount := 32000;
    l_offset := 1;
                dbms_output.put_line(' Function: ' || l_clob);

    BEGIN
        LOOP
            dbms_lob.read(
                l_clob,
                l_amount,
                l_offset,
                l_buffer
            );
            apex_json.parse(l_buffer);
            v_id := apex_json.get_varchar2(
                p_path   => 'results[1].id'
            );
            l_offset := l_offset + l_amount;
            l_amount := 32000;
            dbms_output.put_line('v_id: ' || v_id);
        END LOOP;
    EXCEPTION
        WHEN no_data_found THEN null;
        htp.p(sqlerrm);
            dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);
    END;
       RETURN v_id;
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);
                htp.p('Error inside GET_ID Function: ' || sqlerrm);  

        RETURN v_id;

END get_id;



FUNCTION get_id ( p_workflow_playbook in varchar2 default g_workflow , p_name in VARCHAR2 ) RETURN NUMBER IS
    v_id       NUMBER;
    l_clob     CLOB;
    l_amount   NUMBER;
    l_offset   NUMBER;
    l_buffer   VARCHAR2(32767);
BEGIN
    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type;
    dbms_output.put_line(' URL: ' || g_endpoint_prefix|| case when p_workflow_playbook = 'W' then g_workflow_template else g_playbook_template end 
    || '?name='|| p_name);
    l_clob := apex_web_service.make_rest_request(
        p_url           => g_endpoint_prefix|| case when p_workflow_playbook = 'W' then g_workflow_template 
                                                    when p_workflow_playbook = 'I' then g_inventory_template
                                                    when p_workflow_playbook = 'P' then g_playbook_template   
                                                    when p_workflow_playbook = g_host then g_host_template
                                                    when p_workflow_playbook = g_group then g_group_template 
                                                    end || '?name='|| p_name ,
        p_http_method   => 'GET',
        p_username      => p_username,
        p_password      => p_password,
        p_wallet_path   => g_wallet_path,
        p_wallet_pwd    => g_wallet_pass
    );

    l_amount := 32000;
    l_offset := 1;
                dbms_output.put_line(' Function: ' || l_clob);

    BEGIN
        LOOP
            dbms_lob.read(
                l_clob,
                l_amount,
                l_offset,
                l_buffer
            );
            apex_json.parse(l_buffer);
            v_id := apex_json.get_varchar2(
                p_path   => 'results[1].id'
            );
             dbms_output.put_line('v_id: ' || v_id);

            l_offset := l_offset + l_amount;
            l_amount := 32000;
        END LOOP;
    EXCEPTION
        WHEN no_data_found THEN null;
            --dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);
    END;
       RETURN v_id;
EXCEPTION
    WHEN OTHERS THEN raise;
        dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);  
        RETURN v_id;
END get_id;



FUNCTION get_playbook_id ( p_name IN VARCHAR2 ) RETURN NUMBER
    AS
BEGIN
    RETURN oac$ansible_rest_utl.get_id(
        p_workflow_playbook   => g_playbook,
        p_name                => p_name
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_playbook_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_playbook_id;


FUNCTION get_workflow_id ( p_name IN VARCHAR2 ) RETURN NUMBER
    AS
  template_id number;
BEGIN
 SELECT
    max(template_id)
    into
    template_id
FROM
    v_ansible_template_store
    where
    template_name = p_name
    ;
    RETURN  template_id;

EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_workflow_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_workflow_id;



FUNCTION get_workflow_id_old ( p_name IN VARCHAR2 ) RETURN NUMBER
    AS
BEGIN
    RETURN oac$ansible_rest_utl.get_id(
        p_workflow_playbook   => g_workflow,
        p_name                => p_name
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_workflow_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_workflow_id_old;

FUNCTION get_inventory_id ( p_name IN VARCHAR2 DEFAULT g_default_inventory ) RETURN NUMBER
    AS
BEGIN
    RETURN oac$ansible_rest_utl.get_id(
        p_workflow_playbook   => g_inventory,
        p_name                => p_name
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_inventory_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_inventory_id;


FUNCTION get_host_id ( p_name IN VARCHAR2 ) RETURN NUMBER
    AS
BEGIN
    RETURN oac$ansible_rest_utl.get_id(
        p_workflow_playbook   => g_host,
        p_name                => p_name
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_host_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_host_id;

FUNCTION get_group_id ( p_name IN VARCHAR2 ) RETURN NUMBER
    AS
BEGIN
    RETURN oac$ansible_rest_utl.get_id(
        p_workflow_playbook   => g_group,
        p_name                => p_name
    );
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error in get_group_id for : '
         || p_name
         || ' '
         || sqlerrm);
        RETURN NULL;
END get_group_id;

procedure add_group (p_inventory_id in number default g_default_inventory_id, p_group_name in varchar2,p_response out clob)
as 

  v_param_json    clob;
  l_clob          clob;

/*  v_response      clob;
  l_buffer         varchar2(32767);
  l_amount         number := 32000 ;
  l_offset         number := 1;
  l_clob           clob;
  v_id number;
  v_url varchar2(100);
  v_status varchar2(100);
  v_result_stdout clob;*/
begin
    null;

    v_param_json :=
       '{
       "name": "'|| p_group_name  || '" ,
       "inventory": "'|| p_inventory_id ||'"
       }';


  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := g_content_type ; --'application/json'; 
  -- host should be dbtest04.techlab.com 
  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| g_group_template  ,
              p_http_method => 'POST',
              p_username => p_username ,
              p_password => p_password ,
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => v_param_json
              /*p_body => '{
                           "extra_vars": {
                             ' || v_param_json ||'
                             }
                          }'*/
              );
        -- we have separate function to parse data      
 /*   begin
        loop
            dbms_lob.read( l_clob, l_amount, l_offset, l_buffer );

            apex_json.parse(l_buffer);
            p_job_id := apex_json.get_varchar2(p_path => 'id')   ;  
            -- here we do parse response in order to enter into table.
             v_id := apex_json.get_varchar2(p_path => 'id')   ;     
             v_url := apex_json.get_varchar2(p_path => 'url')   ; 
             v_status := apex_json.get_varchar2(p_path => 'status')   ;     
             v_result_stdout := apex_json.get_varchar2(p_path => 'result_stdout');            

            --htp.p('ID : ' || apex_json.get_varchar2(p_path => 'id'));
            --htp.p('<br>');
            --htp.p(l_buffer);
            l_offset := l_offset + l_amount;
            l_amount := 32000;
        end loop;
    exception
        when no_data_found then
            null;
    end;

    */

    p_response  := l_clob;
 exception 
    when others then null;  
end add_group;

procedure delete_group (p_group_id in number, p_response out clob)
as 
  v_param_json    clob;
  l_clob          clob;
begin

  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := g_content_type ; --'application/json'; 

  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| g_group_template || p_group_id || '/' ,
              p_http_method => 'DELETE',
              p_username => p_username ,
              p_password => p_password ,
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => v_param_json
              );

    p_response  := l_clob;
 exception 
    when others then 
    dbms_output.put_line('Error inside delete_group '||sqlerrm);  
    p_response := p_response || 'Error in deleting Group '||p_group_id || ' . '||sqlerrm;
end delete_group;

/**
author: Jaydipsinh Raulji
Purpose: Delete the given host from the tower inventory.
*/
procedure delete_host (p_host_id in number, p_response out clob)
as 
  v_param_json    clob;
  l_clob          clob;
begin

  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := g_content_type ; --'application/json'; 

  l_clob := apex_web_service.make_rest_request(
              p_url => g_endpoint_prefix|| g_host_template || p_host_id || '/' ,
              p_http_method => 'DELETE',
              p_username => p_username ,
              p_password => p_password ,
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass ,
              p_body => v_param_json
              );

    p_response  := l_clob;
 exception 
    when others then 
    dbms_output.put_line('Error inside delete_host '||sqlerrm);  
end delete_host;

/**
--author: Jaydipsinh Raulji
Purpose: Addding/Association of the existing hosts to the given group.
*/
PROCEDURE add_host_to_group (
    p_group_id   IN NUMBER,
    p_host_id    IN NUMBER,
    p_response   OUT CLOB
) AS
    v_param_json   CLOB;
    l_clob         CLOB;
BEGIN
    v_param_json := '{
       "id": ' || p_host_id|| '
       }';   -- adding host id in json body
    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type; --'application/json'; 
    l_clob := apex_web_service.make_rest_request(
        p_url           => g_endpoint_prefix
         || g_group_template
         || p_group_id
         || '/'
         || g_host_template,
        p_http_method   => 'POST',
        p_username      => p_username,
        p_password      => p_password,
        p_wallet_path   => g_wallet_path,
        p_wallet_pwd    => g_wallet_pass,
        p_body          => v_param_json
    );

    p_response := l_clob;
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside add_host_to_group ' || sqlerrm);
END add_host_to_group;

/**
--author: Jaydipsinh Raulji
Purpose: creating new host and adding to the given group.
*/
PROCEDURE create_host_to_group (
    p_inventory_id       IN NUMBER,
    p_group_id           IN NUMBER,
    p_host_name          IN VARCHAR2,
    p_host_description   IN VARCHAR2 DEFAULT '',
    p_enabled            IN VARCHAR2 DEFAULT 'True',--True/False
    p_instance_id        IN NUMBER DEFAULT '',
    p_variables          IN VARCHAR2 DEFAULT '',
    p_response           OUT CLOB
) AS
    v_param_json   CLOB;
    l_clob         CLOB;
BEGIN


--      MGP nov-18 Took Out appending domain to host
--       "name": "'|| p_host_name || g_tower_domain ||'" ,

    v_param_json :=
       '{
       "name": "'|| p_host_name ||'" ,
       "description": "'||p_host_description||'",
       "inventory": "'|| p_inventory_id ||'",
       "enabled": "'||p_enabled||'",
       "instance_id": "'||p_instance_id||'",
       "variables":"'||p_variables||'"
       }';   -- adding host id in json body

    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type; --'application/json'; 
    l_clob := apex_web_service.make_rest_request(
        p_url           => g_endpoint_prefix
         || g_group_template
         || p_group_id
         || '/'
         || g_host_template,
        p_http_method   => 'POST',
        p_username      => p_username,
        p_password      => p_password,
        p_wallet_path   => g_wallet_path,
        p_wallet_pwd    => g_wallet_pass,
        p_body          => v_param_json
    );

    p_response := l_clob;
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside create_host_to_group ' || sqlerrm);
END create_host_to_group;

-- **********  Procedure for Oracle Precheck  **********

procedure do_oracle_precheck_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle_prereqs';
--v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prifix,g_playbook_template),v_job_name), '/');
v_workflow_id   number;-- := get_id(g_playbook,v_job_name) ;
begin
null;
    v_workflow_id  := get_id(g_playbook,v_job_name) ;

    v_param_json := '"host": "'|| p_host_name || g_tower_domain || '" ';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_precheck_rest;


-- **********  Procedure Oracle - Run Cluster Verify  **********

procedure do_oracle_run_cluster_verify_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle - Run Cluster Verify';
--v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prifix,g_playbook_template), v_job_name), '/');
v_workflow_id   number;-- := get_id(g_playbook,v_job_name);
begin
null;
    v_workflow_id  := get_id(g_playbook,v_job_name);
    v_param_json :=  '"host": "'|| p_host_name || g_tower_domain ||'" ';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;
end do_oracle_run_cluster_verify_rest;


-- **********  Procedure for Oracle - Install 12c Grid Standalone  **********  

procedure do_oracle_install_12c_grid_standalone_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle - Install 12c Grid Standalone';
v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number ;--:= get_id(g_playbook,v_job_name);
begin
null;
    v_workflow_id  := get_id(g_playbook,v_job_name);

    v_param_json := '"host": "'|| p_host_name || g_tower_domain ||'",
		             "env_source": "'|| p_env_source ||'" ';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_install_12c_grid_standalone_rest;


-- **********  Procedure for Oracle - Install 12c Database  **********

procedure do_oracle_install_12c_database_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
									  p_rac_install in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle - Install 12c Database';
v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number;-- := get_id(g_playbook,v_job_name) ;
begin
null;
    v_workflow_id := get_id(g_playbook,v_job_name) ;

    v_param_json := '"host": "'|| p_host_name || g_tower_domain ||'"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_install_12c_database_rest;


-- **********  Procedure for Oracle upgrade from 11g  to 12c database  **********

procedure do_oracle_upgrade_from_11g_to_12c_database_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_oracle_db_home in varchar2,
									  p_oracle_db_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle upgrade from 11g  to 12c database';
v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/' );
v_workflow_id   number;-- := get_id(g_playbook,v_job_name) ;
begin
null;
    v_workflow_id  := get_id(g_playbook,v_job_name) ;

    v_param_json := '"host": "'|| p_host_name || g_tower_domain ||'"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_upgrade_from_11g_to_12c_database_rest;


-- **********  Procedure for Oracle - Create DB Instance  **********


procedure do_oracle_create_db_instance_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_oracle_db_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle - Create DB Instance';
v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number;-- := get_id(g_playbook,v_job_name) ;
begin
null;
    v_workflow_id  := get_id(g_playbook,v_job_name) ;

    v_param_json := '"host": "'|| p_host_name || g_tower_domain ||'",
	                "oracle_db_name": "'|| p_oracle_db_name || '"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_create_db_instance_rest;


-- **********  Procedure for Oracle - Install 12c Grid Cluster  **********

procedure do_oracle_install_12c_grid_cluster_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_cluster_name in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as

v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
v_job_name      varchar2(50):= 'Oracle - Install 12c Grid Cluster';
v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number;-- := get_id(g_playbook,v_job_name) ;
begin
    v_workflow_id  := get_id(g_playbook,v_job_name) ;

    v_param_json := '"host": "' || p_host_name || g_tower_domain ||'"';

    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_cluster_name,            --since cluster_name is there
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_oracle_install_12c_grid_cluster_rest;


-- **********  Procedure for Grid-PSU-apply  **********

procedure do_grid_psu_apply_rest (  p_host_name in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
                                      p_patch_type in varchar2,
									  p_patch_file in varchar2,
									  p_oracle_db_home in varchar2,

                                      p_job_id out number,
                                      p_request_id out number
                                    )
as
v_param_json    clob;
v_response      clob;
v_job_id        number;
--v_request_type  varchar2(50) := 'PROVISIONING';
v_request_type  varchar2(50) := 'PATCHING';
--v_job_name      varchar2(50):= 'Grid-PSU-apply';
v_job_name      varchar2(50):= 'psu-patching-rdbms';

--v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number ;--:= get_id(g_playbook,v_job_name) ;
l_hosts_a APEX_APPLICATION_GLOBAL.VC_ARR2;
l_host_id number; -- tower host id
l_group_id number; -- tower group id
l_group_name varchar2(255) := lower(replace(p_ticket_ref,' ','-')) ;
l_host_code varchar2(255);
c_RESPONSE clob; -- Tower host and group reponse
begin
null;
 --
 -- Check the group to see if it exists
 select OAC$ANSIBLE_REST_UTL.get_group_id(l_group_name) into l_group_id from dual;
 if l_group_id is null then
  -- Add a group
   add_group (  
               P_GROUP_NAME => l_group_name,
              P_RESPONSE => c_RESPONSE) ;  

   select OAC$ANSIBLE_REST_UTL.get_group_id(l_group_name) into l_group_id from dual;

 else
  --group does exists Hmmm add a diff group?
  null;
 end if;
-- DBMS_OUTPUT.PUT_LINE ('The group id ' ||l_group_id);
 --
 -- Passed in value from the select list could be multiple hosts
 l_hosts_a := APEX_UTIL.STRING_TO_TABLE(p_host_name);
  -- Loop thru the passed in list of hosts
  FOR i IN 1..l_hosts_a.count 
  LOOP
     select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)||g_tower_domain) into l_host_id from dual;
     select max(host_code) into l_host_code from v_host_inv_tbl where host_name = l_hosts_a(i);
    -- DBMS_OUTPUT.PUT_LINE (l_hosts_a(i));
     --Is the Host in tower if not add it
     if l_host_id is null then
       add_host (  
        P_HOST_NAME => l_hosts_a(i)
       ,P_RESPONSE => c_RESPONSE) ;

       select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)||g_tower_domain) into l_host_id from dual;
     end if;
     --Add the Host to the group  
   --  DBMS_OUTPUT.PUT_LINE (l_hosts_a(i)||g_tower_domain||' - The host id ' ||l_host_id);
      create_host_to_group (  P_INVENTORY_ID => g_default_inventory_id,
       P_GROUP_ID => l_GROUP_ID,
       P_HOST_NAME => l_hosts_a(i),
       P_HOST_DESCRIPTION => l_hosts_a(i),
       P_ENABLED =>null,
      P_INSTANCE_ID => l_host_id,
     P_VARIABLES => null,
      P_RESPONSE => c_RESPONSE) ;
    /*  add_host_to_group (  P_GROUP_ID => l_GROUP_ID,
       P_HOST_ID => l_HOST_ID,
       P_RESPONSE => c_RESPONSE) ;  */


    END LOOP;

    -- Lookup ID from V_ANSIBLE_TEMPLATE_STORE
    v_workflow_id := OAC$ANSIBLE_UTL.GET_TEMPLATE_ID('psu-patching-rdbms-fresh') ;
    --v_workflow_id := 321 ;

    --
    -- Build out all the parms for the PSU by looking up the patch ingo
    --
    for c1 in (
     SELECT
        id,
        patch_file_name,
       patch_type,
      patch_quarter,
      patch_year,
      software_version,
      opatch_version,
      patch_status
     FROM
      v_patch_lookup_tbl 
    where patch_file_name = p_patch_file
    ) loop
    v_param_json :=
  --     '"oracle_db_home": "'       || p_oracle_db_home || '.techlab.com",
  --	    '"host": "'       || p_host_name ||'.'||g_tower_domain|| '",

	    '"host": "'       || l_group_name || '",
		"patch_file": "'       || p_patch_file || '",
		"patch_type": "'       || p_patch_type || '",
		"patch_quarter": "'       || c1.patch_quarter || '",
        "patch_year": "'       || c1.patch_year || '",
        "opatch_version_required": "' ||c1.opatch_version  || '",
        "opatch_util_installer": "'       || p_patch_type || '",
        "db_home": "'       || p_oracle_db_home || '",
        "host_code": "'       || l_host_code || '",
		"oracle_installer_path": "/ansible"';
      end loop;
           /*"patch_file": "p27967747_121020_Linux-x86-64.zip",
	    "host": "oralab1.techlab.com",
		"patch_type": "ORACLE",
		"oracle_installer_path": "/ansible"

        host: the host or group to execute the playbook against. This can also be a Group from the Inventory
patch_file - The full name of the Patch file
patch_type - GRID or ORACLE (if combined use GRID)
patch_quarter - The Patch Quarter to use in 3 char format (e.g. Jul)
patch_year - The Patch Year to use in full format (e.g. 2018)
opatch_version_required - The expected OPatch Version for this PSU (as returned by opatch	version )
opatch_util_installer - The name of the zipfile at '/yum/source/ORACLE_DB/OPATCH/' to install the expected OPatch
version
db_home - database Home for APEX
host_code - for APEX
        */
    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => g_playbook,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    

      p_job_id := v_job_id;

end do_grid_psu_apply_rest;


function setup_oracle_patch_vars(
 p_patch_file in varchar2
) return varchar2 as
  v_param_json varchar2(32000);
Begin
    --
    -- Build out all the parms for the PSU by looking up the patch ingo
    --
    for c1 in (
     SELECT
        id,
        patch_file_name,
       patch_type,
      patch_quarter,
      patch_year,
      software_version,
      opatch_version,
      patch_status,
      opatch_file,
      OJVM_PATCH,
      PSU_VERSION
     FROM
      v_patch_lookup_tbl 
    where patch_file_name = p_patch_file
    ) loop
     --"patch_type": "'       || c1.patch_type || '",
    v_param_json :=
	    
	   '"patch_file": "'       || p_patch_file || '",       
        "patch_quarter": "'       || c1.patch_quarter || '",
        "patch_year": "'       || c1.patch_year || '",
        "psu_version": "'       || c1.PSU_VERSION || '",
        "opatch_version_required": "' ||c1.opatch_version  || '",
        "opatch_util_installer": "'       || c1.opatch_file || '",
        "ojvm_patch": "'       || c1.OJVM_PATCH || '"';
        
      end loop;
     -- Passed back in call so that the request record can be updated 
    
    return  replace(v_param_json,chr(10));   
    dbms_output.put_line('v_param_json: ' ||v_param_json); 

end;
-- **********  Procedure for rdbms-PSU-apply  **********

procedure do_psu_apply_rest (  P_PATCH_REQUEST_ID in number,
                                 p_host_name in varchar2,
                                     p_cluster in varchar2,
                                     p_target_type in varchar2,
                                     p_patch_type in varchar2,
                                      p_ticket_ref in varchar2,
									  p_env_source in  varchar2,
                                      p_dc_location in varchar2,
									  p_patch_file in varchar2,
									  p_oracle_db_home in varchar2,

                                      p_job_id out number,
                                      p_request_id out number,
                                      p_extra_vars out clob
                                    )
as
v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PATCHING';
v_job_name      varchar2(50):= 'psu-patching-rdbms';

--v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number ;--:= get_id(g_playbook,v_job_name) ;
v_playbook_type varchar2(255) := g_workflow;
v_playbook_name varchar2(255) := 'psu-patching-rdbms-fresh'; 
l_hosts_a APEX_APPLICATION_GLOBAL.VC_ARR2;
l_host_id number; -- tower host id
l_group_id number; -- tower group id
l_group_name varchar2(255) := lower(replace(p_ticket_ref,' ','-')) ;
l_host_code varchar2(255);
c_RESPONSE clob; -- Tower host and group reponse
 cluster_host_names varchar2(32000);
begin
null;
 
 DBMS_OUTPUT.PUT_LINE ('Target Type ' ||p_target_type);

 if p_target_type = 'Standalone' then
 -- Passed in value from the select list could be multiple hosts
 l_hosts_a := APEX_UTIL.STRING_TO_TABLE(p_host_name);
else
 --Clustered
 begin
          select listagg(trim(HOST_NAME), ':') within group (order by 1) 
          into cluster_host_names from V_HOST_INV_VW where HOST_CODE = p_cluster;
  exception 
  when others then null;
   cluster_host_names  :='no_cluster_hosts';
  end ; 
end if;
 
 --
 -- Check the group to see if it exists
 select OAC$ANSIBLE_REST_UTL.get_group_id(l_group_name) into l_group_id from dual;
 if l_group_id is null then
  -- Add a group
   add_group (  
               P_GROUP_NAME => l_group_name,
              P_RESPONSE => c_RESPONSE) ;  

   select OAC$ANSIBLE_REST_UTL.get_group_id(l_group_name) into l_group_id from dual;

 else
  --group does exists Hmmm add a diff group?
  null;
 end if;
-- DBMS_OUTPUT.PUT_LINE ('The group id ' ||l_group_id);
 --
  -- Loop thru the passed in list of hosts
  FOR i IN 1..l_hosts_a.count 
  LOOP
  -- Changed so that we do not append domain to host
  --     select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)||g_tower_domain) into l_host_id from dual;
     select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)) into l_host_id from dual;

     select max(host_code) into l_host_code from v_host_inv_tbl where host_name = l_hosts_a(i);
    -- DBMS_OUTPUT.PUT_LINE (l_hosts_a(i));
     --Is the Host in tower if not add it
     if l_host_id is null then
       add_host (  
        P_HOST_NAME => l_hosts_a(i)
       ,P_RESPONSE => c_RESPONSE) ;

  -- Changed so that we do not append domain to host
  --     select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)||g_tower_domain) into l_host_id from dual;
     select OAC$ANSIBLE_REST_UTL.get_host_id(l_hosts_a(i)) into l_host_id from dual;

     end if;
     --Add the Host to the group  
   --  DBMS_OUTPUT.PUT_LINE (l_hosts_a(i)||g_tower_domain||' - The host id ' ||l_host_id);
      create_host_to_group (  P_INVENTORY_ID => g_default_inventory_id,
       P_GROUP_ID => l_GROUP_ID,
       P_HOST_NAME => l_hosts_a(i),
       P_HOST_DESCRIPTION => l_hosts_a(i),
       P_ENABLED =>null,
      P_INSTANCE_ID => l_host_id,
     P_VARIABLES => null,
      P_RESPONSE => c_RESPONSE) ;
    /*  add_host_to_group (  P_GROUP_ID => l_GROUP_ID,
       P_HOST_ID => l_HOST_ID,
       P_RESPONSE => c_RESPONSE) ;  */


    END LOOP;

    -- Lookup ID from V_ANSIBLE_TEMPLATE_STORE
    --v_playbook_type varchar2(255) := g_workflow;
    --v_playbook_name varchar2(255) := 'psu-patching-'||p_patch_type; 
     dbms_output.put_line('Lookup WF: ' ||v_playbook_name); 
    --v_workflow_id := OAC$ANSIBLE_UTL.GET_TEMPLATE_ID(v_playbook_name) ;
    
    --Post Go-Live add the ability to have workflows for diff patch types
    -- v_playbook_name := 'psu-patching-'||p_patch_type; 

    v_workflow_id := OAC$ANSIBLE_UTL.GET_TEMPLATE_ID(v_playbook_name) ;
    
    
    --v_workflow_id := 321 ;

    --
    -- Build out all the parms for the PSU by looking up the patch ingo
    --
    /*
    for c1 in (
     SELECT
        id,
        patch_file_name,
       patch_type,
      patch_quarter,
      patch_year,
      software_version,
      opatch_version,
      patch_status,
      opatch_file,
      OJVM_PATCH
     FROM
      v_patch_lookup_tbl 
    where patch_file_name = p_patch_file
    ) loop
    v_param_json :=
  --     '"oracle_db_home": "'       || p_oracle_db_home || '.techlab.com",
  --	    '"host": "'       || p_host_name ||'.'||g_tower_domain|| '",
  -- opatch_util_installer
  -- NOt sure what the Host_code should be
  --		"patch_type": "'       || p_patch_type || '",
  -- "host_code": "'       || case when :P44_CLUSTERED = 'YES' then v_host_name_list else  :P44_CLUSTER_HOST end || '",
	    '"host": "'       || l_group_name || '",
		"patch_file": "'       || p_patch_file || '",
		"patch_quarter": "'       || c1.patch_quarter || '",
        "patch_year": "'       || c1.patch_year || '",
        "opatch_version_required": "' ||c1.opatch_version  || '",
        "opatch_util_installer": "'       || c1.opatch_file || '",
        "ojvm_patch": "'       || c1.OJVM_PATCH || '",
        "db_home": "'       || p_oracle_db_home || '",
        "host_code": "'       || case when p_target_type = 'Standalone' then replace(p_host_name,':',',') else p_cluster  end || '",
		"oracle_installer_path": "/ansible"';
      end loop;
      */
     -- Passed back in call so that the request record can be updated 
--		"oracle_installer_path": "/ansible",'||

      v_param_json :=
 	    '"host": "'       || l_group_name || '",
        "db_home": "'       || p_oracle_db_home || '",
        "ticket_ref": "'       || p_ticket_ref || '",
        "standard_task_id": "0",
        "host_code": "'       || case when p_target_type = 'Standalone' then replace(p_host_name,':',',') else p_cluster  end || '",'||
         OAC$ANSIBLE_REST_UTL.setup_oracle_patch_vars(p_patch_file ); 
    p_extra_vars := v_param_json;
    -- make a rest call.

    dbms_output.put_line('v_param_json: ' ||v_param_json); 

      OAC$ANSIBLE_REST_UTL.MAKE_REST_CALL(
        P_FLAG => v_playbook_type,
        P_ID => v_workflow_id,
        P_PARAM_JSON => v_param_json,
        P_RESPONSE => v_response
      );    

     dbms_output.put_line('v_response: ' ||v_response);    

   -- parse and store response


      OAC$ANSIBLE_REST_UTL.PARSE_AND_STORE_RESP(
        P_REQUEST_TYPE => v_request_type,
        P_JOB_NAME => v_job_name,
        P_TICKET_REF => p_ticket_ref,
        P_TARGET_NAME => p_host_name,
        P_RESP_CLOB => v_response,
        P_ID => v_job_id,
        p_request_id => p_request_id
      );   

        dbms_output.put_line('v_job_id: ' ||v_job_id);    
        dbms_output.put_line('p_request_id: ' ||p_request_id);    
      p_job_id := v_job_id;
      
  
  
-- Grab the Execution Details so we can link to the log on Page 35
UPDATE  v_patch_request_queue
 set JOB_ID = P_JOB_ID
 ,REQUEST_ID  = P_REQUEST_ID 
,extra_vars = p_extra_vars
, group_id = l_GROUP_ID

where
id =  P_PATCH_REQUEST_ID; 

end do_psu_apply_rest;

--
-- **********  Procedure for Get Playbook  call when press REFRESH Button  **********

procedure get_playbook (  p_endpoint in varchar2,

                                      p_job_id out number,
									  p_url out varchar2,
									  p_job_status out varchar2,
									  p_stdout out varchar2,
									  p_response out varchar2
                                    )
as

  l_clob clob;
  l_amount         number;
  l_offset         number;
  l_buffer         varchar2(32767);
  v_amount         number;
  v_offset         number;

  v_response      clob;
  v_id number;
  v_url varchar2(100);
  v_status varchar2(100);
  v_result_stdout clob;  

begin
  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := 'application/json'; 
  -- host should be dbtest04.techlab.com 

  v_response := apex_web_service.make_rest_request(
              p_url => p_endpoint,
              p_http_method => 'GET',
              p_username => p_username ,
              p_password => p_password ,
              p_wallet_path => g_wallet_path,
              p_wallet_pwd => g_wallet_pass 
              );

    v_amount := 32000;
    v_offset := 1;



    begin
        loop
            dbms_lob.read( v_response, l_amount, l_offset, l_buffer );

            apex_json.parse(l_buffer);
            p_job_id := apex_json.get_varchar2(p_path => 'id')   ;     
            p_url := apex_json.get_varchar2(p_path => 'url')   ;     
            p_job_status := apex_json.get_varchar2(p_path => 'status')   ;     
            p_stdout := apex_json.get_varchar2(p_path => 'result_stdout');

             v_id := apex_json.get_varchar2(p_path => 'id')   ; 
             v_status := apex_json.get_varchar2(p_path => 'status')   ;     
             v_result_stdout := apex_json.get_varchar2(p_path => 'result_stdout');

           --htp.p('ID : ' || apex_json.get_varchar2(p_path => 'id'));
            --htp.p('<br>');
            --htp.p(l_buffer);
            v_offset := l_offset + l_amount;
            v_amount := 32000;
        end loop;
    exception
        when no_data_found then
            dbms_output.put_line('No Data Found......');
    end;


    update v_self_service_status set JOB_RESULT = v_status , RESULT_STDOUT = v_result_stdout  where job_no = (p_job_id);    
    p_response  := v_response;

end get_playbook;

/*
procedure insert_request_queue(  
                                      p_request_id in number,
                                      p_template_name in varchar2,
                                      p_job_id in varchar2,
                                      p_job_name in varchar2,
                                      p_job_url in varchar2,
                                      p_status in varchar2,
                                      p_db_option in varchar2,
                                      p_host_name in varchar2,
                                      p_cluster_name in varchar2,
                                      p_cluster_type in varchar2,
                                      p_gi_version in varchar2,
                                      p_env_source in  varchar2,
                                      p_ticket_ref in varchar2,
                                      p_application_name in varchar2,
                                      p_business_unit in varchar2,
                                      p_network_type in varchar2,
                                      p_oracle_version in varchar2,
                                      p_os_type in varchar2,
                                      p_os_type_version in varchar2,
                                      p_phy_vert in varchar2,
                                      p_clustered in varchar2,
                                      p_dc_location in varchar2,
                                      p_server_monitoring_tool in varchar2,
                                      p_oracle_db_name in varchar2,
                                      p_db_environment in varchar2,
                                      p_rac_type in varchar2,
                                      p_database_role in varchar2,
                                      --p_env_category in varchar2,
                                      p_storage_type in varchar2,
                                      p_db_monitoring_tool in varchar2,
                                      p_appliance in varchar2,
                                      p_pci_required in varchar2,
                                      p_sox_required in varchar2,
                                      p_encryption_required in varchar2,
                                      p_backup_enabled in varchar2,
                                      p_monitoring in varchar2
                                 )
 as
 host_name_list clob := TO_CLOB(p_host_name);
 begin
         dbms_output.put_line(p_monitoring);
         insert into REQUEST_QUEUE (REQUEST_ID,
                                    TEMPLATE_NAME,
                                    JOB_ID,JOB_NAME,
                                    JOB_URL,
                                    STATUS,
                                    CLUSTER_NAME,
                                    CLUSTER_TYPE,
                                    GI_VERSION,
                                    ENV_SOURCE,
                                    TICKET_REF,
                                    APPLICATION_NAME,
                                    BUSINESS_UNIT,
                                    DB_OPTION,
                                    HOST_NAME,
                                    NETWORK_TYPE,
                                    ORACLE_VERSION,
                                    OS_TYPE,
                                    OS_TYPE_VERSION,
                                    PHY_VERT,
                                    CLUSTERED,
                                    DC_LOCATION,
                                    SERVER_MONITOTING_TOOL,
                                    DATABASE_NAME,
                                    ENVIRONMENT,
                                    RAC_TYPE,
                                    DATABASE_ROLE,
                                    STORAGE_TYPE,
                                    DB_MONITORING_TOOL,
                                    APPLIANCE,
                                    PCI_REQUIRED,
                                    SOX_REQUIRED,
                                    ENCRYPTION_REQUIRED,
                                    BACKUP_REQUIRED,
                                    MONITORING,
                                    CREATED,
                                    CREATED_BY,
                                    UPDATED,
                                   UPDATED_BY
                                   )
                        values (p_request_id
                                ,p_template_name
                                ,p_job_id
                                ,p_job_name
                                ,p_job_url
                                ,p_status
                                ,p_cluster_name
                                ,p_cluster_type
                                ,p_gi_version
                                ,p_env_source
                                ,p_ticket_ref
                                ,p_application_name
                                ,NULL
                                ,p_db_option
                                ,host_name_list
                                ,p_network_type
                                ,p_oracle_version
                                ,p_os_type
                                ,p_os_type_version
                                ,p_phy_vert
                                ,p_clustered
                                ,p_dc_location
                                ,p_server_monitoring_tool
                                ,p_oracle_db_name
                                ,p_db_environment
                                ,p_rac_type
                                ,p_database_role
                                ,p_storage_type
                                ,p_db_monitoring_tool
                                ,p_appliance
                                ,p_pci_required
                                ,p_sox_required
                                ,p_encryption_required
                                ,p_backup_enabled
                                ,p_monitoring
                                ,''
                                ,''
                                ,''
                                ,''
                               );
 end insert_request_queue;*/
-- Provide config options so that globals are set based on V_APP_SETTINGS
 -- Support multiple verbs
 procedure config(p_action in varchar2 default 'INIT',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
 ) 
 as
 Begin
   null;
   -- Set the standard globals for this Oracle install 
   if p_action = 'INIT' then
   for c1 in (
   select
   setting_value
   ,setting_category 
   from V_APP_SETTINGS
   where
   setting_category in (
   'TOWER ACCOUNT','TOWER ACCOUNT PASSWORD','TOWER URL','TOWER ENDPOINT','ORACLE_WALLET_PATH','ORACLE INVENTORY','ORACLE INVENTORY ID','TOWER DOMAIN','WALLET_PASSWORD'
     )  
   ) loop
     null;
     if  c1.setting_category =    'TOWER ACCOUNT' then
       p_username := c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER ACCOUNT PASSWORD' then
       p_password := oac$ansible_utl.decrypt(c1.setting_value);
     end if;     
     if  c1.setting_category =    'TOWER URL' then
       g_tower_url:= c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER ENDPOINT' then
       g_endpoint_prefix := c1.setting_value;
     end if;
     if  c1.setting_category =    'ORACLE_WALLET_PATH' then
       g_wallet_path := c1.setting_value;
     end if;
     if  c1.setting_category =    'ORACLE INVENTORY' then
       g_default_inventory := c1.setting_value;
     end if;
     if  c1.setting_category =    'ORACLE INVENTORY ID' then
       g_default_inventory_id := c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER DOMAIN' then
       g_tower_domain := c1.setting_value;
     end if;
     if  c1.setting_category =    'WALLET_PASSWORD' then
       g_wallet_pass := oac$ansible_utl.decrypt(c1.setting_value);
     end if;

   end loop;
 
  -- Set the standard globals for this MSSQL install 
   elsif p_action = 'INIT_MSSQL' then
   for c1 in (
   select
   setting_value
   ,setting_category 
   from V_APP_SETTINGS
   where
   setting_category in (
   'TOWER ACCOUNT','TOWER ACCOUNT PASSWORD','TOWER URL','TOWER ENDPOINT','ORACLE_WALLET_PATH','MSSQL_INVENTORY','MSSQL_INVENTORY_ID','TOWER DOMAIN','WALLET_PASSWORD'
     )  
   ) loop
     null;
     if  c1.setting_category =    'TOWER ACCOUNT' then
       p_username := c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER ACCOUNT PASSWORD' then
       p_password := oac$ansible_utl.decrypt(c1.setting_value);
     end if;     
     if  c1.setting_category =    'TOWER URL' then
       g_tower_url:= c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER ENDPOINT' then
       g_endpoint_prefix := c1.setting_value;
     end if;
     if  c1.setting_category =    'ORACLE_WALLET_PATH' then
       g_wallet_path := c1.setting_value;
     end if;
     if  c1.setting_category =    'MSSQL_INVENTORY' then
       g_default_inventory := c1.setting_value;
     end if;
     if  c1.setting_category =    'MSSQL_INVENTORY_ID' then
       g_default_inventory_id := c1.setting_value;
     end if;
     if  c1.setting_category =    'TOWER DOMAIN' then
       g_tower_domain := c1.setting_value;
     end if;
     if  c1.setting_category =    'WALLET_PASSWORD' then
       g_wallet_pass := oac$ansible_utl.decrypt(c1.setting_value);
     end if;

   end loop;
 elsif p_action = 'SETPASSWORD' then
  -- Allow for command line set of Passwords in the v_APP_SETTINGS
  null;
  /*  select
   setting_value
   ,setting_category 
   from V_APP_SETTINGS
   where
   setting_category in (
   'TOWER ACCOUNT','TOWER ACCOUNT PASSWORD','TOWER URL','TOWER ENDPOINT','ORACLE_WALLET_PATH','ORACLE INVENTORY','ORACLE INVENTORY ID','TOWER DOMAIN','WALLET_PASSWORD'
     )  
  */
   if upper(p_parm1) = 'TOWER ACCOUNT PASSWORD' and p_parm2 is not null then    
      update V_APP_SETTINGS
      set setting_value = oac$ansible_utl.encrypt(p_parm2)
      where setting_category = 'TOWER ACCOUNT PASSWORD';
     dbms_output.put_line(  p_parm1 ||' Set to :'|| p_parm2);
    elsif upper(p_parm1) = 'WALLET_PASSWORD' and p_parm2 is not null then    
      update V_APP_SETTINGS
      set setting_value = oac$ansible_utl.encrypt(p_parm2)
      where setting_category = 'WALLET_PASSWORD';
      dbms_output.put_line(  p_parm1 ||' Set to :'|| p_parm2); 
    elsif upper(p_parm1) = 'TEST PASSWORD' and p_parm2 is not null then    
      update V_APP_SETTINGS
      set setting_value = oac$ansible_utl.encrypt(p_parm2)
      where setting_category = 'TEST PASSWORD';
     dbms_output.put_line(  p_parm1 ||' Set to :'|| p_parm2); 
   else
   dbms_output.put_line( 'Failed to SETPASSWORD check inputs');
   dbms_output.put_line( 'p_parm1: '||   p_parm1);
   dbms_output.put_line( 'p_parm1: '||   p_parm1);
   end if;
  elsif p_action = 'PRINT' then
     dbms_output.put_line( rpad('## V_APP_SETTINGS #',70,'#'));
     dbms_output.put_line( 'p_username: '||   p_username);
     dbms_output.put_line( 'p_password: '||   p_password);
     dbms_output.put_line( 'g_endpoint_prefix: '||   g_endpoint_prefix);
     dbms_output.put_line( 'g_default_inventory: '||   g_default_inventory);
     dbms_output.put_line( 'g_default_inventory_id: '||   g_default_inventory_id);
     dbms_output.put_line( 'g_tower_domain: '||   g_tower_domain);
     dbms_output.put_line( 'g_wallet_path: '||   g_wallet_path);
     dbms_output.put_line( 'g_wallet_pass: '||   g_wallet_pass);
     dbms_output.put_line( 'g_tower_url: '||   g_tower_url);     
     dbms_output.put_line( rpad('#',70,'#'));

/*       p_password := c1.setting_value;
       g_endpoint_prefix := c1.setting_value;
       g_default_inventory := c1.setting_value;
       g_default_inventory_id := c1.setting_value;
       g_tower_domain := c1.setting_value;
       g_wallet_path := c1.setting_value;
       g_wallet_pass := c1.setting_value;

   dbms_output.put_line( );*/
  end if ; -- Init Action

 End config;   

-- This function intake url and get the name for the playbook/workflows template.
FUNCTION get_name (
    p_template_type   IN VARCHAR2 DEFAULT g_workflow,
    p_id              IN VARCHAR2
) RETURN VARCHAR2 IS

    v_name     VARCHAR2(255);
    l_clob     CLOB;
    l_amount   NUMBER;
    l_offset   NUMBER;
    l_buffer   VARCHAR2(32767);
    l_values   apex_json.t_values;    
BEGIN
    oac$ansible_rest_utl.do_rest_call(
        p_url        => g_endpoint_prefix ||CASE
                WHEN
                    p_template_type = 'W'
                THEN
                    g_workflow_template 
                                                    --when p_template_type = 'I' then g_inventory_template
                WHEN
                    p_template_type = 'P'
                THEN
                    g_playbook_template   
                                                    --when p_template_type = g_host then g_host_template
                                                    --when p_template_type = g_group then g_group_template 
            END ||p_id ||'/',
        p_response   => l_clob
    );

    --dbms_output.put_line(' Function: ' || l_clob);
   /* apex_json.parse(
        p_values   => l_values,
        p_source   => l_clob,
        p_strict => false
    );
    v_name     := apex_json.get_varchar2(
        p_values   => l_values,
        p_path     => 'name'
    );*/
        l_amount   := 32000;
    l_offset   := 1;
    BEGIN
        LOOP
            dbms_lob.read(
                l_clob,
                l_amount,
                l_offset,
                l_buffer
            );
            apex_json.parse(l_buffer);
            v_name     := apex_json.get_varchar2(
                p_path   => 'name'
            );
            dbms_output.put_line('v_name: ' || v_name);
            l_offset   := l_offset + l_amount;
            l_amount   := 32000;
        END LOOP;
    EXCEPTION
        WHEN no_data_found THEN
            NULL;
            --dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);
    END;    
-- dbms_output.put_line('123: '||v_name);   
    RETURN v_name;
EXCEPTION
    WHEN OTHERS THEN
        RAISE;
        dbms_output.put_line('Error inside get_name Function: ' || sqlerrm);
        RETURN v_name;
END get_name;

-- This function intake url and get the name for the playbook/workflows.

FUNCTION get_name ( p_url VARCHAR2 ) RETURN VARCHAR2 IS

    v_name     VARCHAR2(255);
    l_clob     CLOB;
    l_amount   NUMBER;
    l_offset   NUMBER;
    l_buffer   VARCHAR2(32767);
    l_values   apex_json.t_values;
BEGIN
    oac$ansible_rest_utl.do_rest_call(
        p_url        => p_url,
        p_response   => l_clob
    );
    dbms_output.put_line('URL is : ' || p_url);
    dbms_output.put_line('Response  is : ' || l_clob);
    l_amount   := 32000;
    l_offset   := 1;
    dbms_output.put_line(' Function: ' || l_clob);
  /*  apex_json.parse(
        p_values   => l_values,
        p_source   => l_clob,
        p_strict => true
    );
    v_name     := apex_json.get_varchar2(
        p_values   => l_values,
        p_path     => 'name'
    );*/
    BEGIN
        LOOP
            dbms_lob.read(
                l_clob,
                l_amount,
                l_offset,
                l_buffer
            );
            apex_json.parse(l_buffer);
            v_name     := apex_json.get_varchar2(
                p_path   => 'name'
            );
            dbms_output.put_line('v_name: ' || v_name);
            l_offset   := l_offset + l_amount;
            l_amount   := 32000;
        END LOOP;
    EXCEPTION
        WHEN no_data_found THEN
            NULL;
            --dbms_output.put_line('Error inside GET_ID Function: ' || sqlerrm);
    END;    
    RETURN v_name;
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside get_name Function: ' || sqlerrm);
        htp.p('Error inside get_name Function: ' || sqlerrm);
        RETURN v_name;
END get_name;

-- This procedure set the ask variable value.
PROCEDURE set_ask_variable (
    p_url    VARCHAR2,
    p_name   IN VARCHAR2,
    p_flag   IN VARCHAR DEFAULT 'true'
) IS
    l_clob   CLOB;
BEGIN
    oac$ansible_rest_utl.do_rest_call(
        p_url           => p_url,
        p_http_method   => 'PUT',
        p_body          => '{
                 "name": "' ||p_name ||'",
                 "allow_simultaneous": ' ||p_flag ||',
                 "ask_variables_on_launch": ' ||p_flag ||'
                }',
        p_response      => l_clob
    );

    dbms_output.put_line('URL is : ' || p_url);
    dbms_output.put_line('Response  is : ' || l_clob);
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('Error inside set_ask_variable : ' || sqlerrm);
END set_ask_variable;

-- initialize
BEGIN
   --Set Globals based on V_APP_SETTINGS
    config('INIT');
   -- config('PRINT');
   -- g_default_inventory_id := oac$ansible_rest_utl.get_id(g_inventory,g_default_inventory);
   -- config('PRINT');

EXCEPTION
    WHEN OTHERS THEN
        NULL;
END oac$ansible_rest_utl;

/

  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" TO "CHARTER2_SQL";
  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_REST_UTL" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package Body OAC$ANSIBLE_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."OAC$ANSIBLE_UTL" AS
    encryption_type   PLS_INTEGER := dbms_crypto.encrypt_des + dbms_crypto.chain_cbc + dbms_crypto.pad_pkcs5;
    encryption_key    RAW(32) := utl_raw.cast_to_raw('0111SAFC');


     -- The encryption key should be 8 bytes or more for DES algorithm. Here I used MESSYKICKGOAL as encrypted key

    FUNCTION get_template_id (
        p_template_typ   IN               VARCHAR2,
        p_app_id         IN               NUMBER,
        p_page_id        IN               NUMBER,
        p_apex_feature   IN               VARCHAR2
    ) RETURN NUMBER AS
    BEGIN
        FOR i IN (
            SELECT
                template_name,
                template_id
            FROM
                v_ansible_template_store
            WHERE
                template_type = p_template_typ
                AND apex_app_id = p_app_id
                AND apex_menu_item = p_page_id
                AND ( upper(apex_feature) = upper(p_apex_feature)
                      OR p_apex_feature IS NULL )
        ) LOOP
            RETURN i.template_id;
        END LOOP;

        RETURN NULL;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_template_id' || sqlerrm);
    END;

    FUNCTION get_template_id (
        p_template_name IN   VARCHAR2
    ) RETURN NUMBER AS
    BEGIN
        FOR i IN (
            SELECT
                template_id
            FROM
                v_ansible_template_store
            WHERE
                template_name = p_template_name
        ) LOOP
            RETURN i.template_id;
        END LOOP;

        RETURN NULL;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_template_id' || sqlerrm);
    END;

    FUNCTION get_template_name (
        p_template_typ   IN               VARCHAR2,
        p_app_id         IN               NUMBER,
        p_page_id        IN               NUMBER,
        p_apex_feature   IN               VARCHAR2
    ) RETURN VARCHAR2 AS
    BEGIN
        FOR i IN (
            SELECT
                template_name,
                template_id
            FROM
                v_ansible_template_store
            WHERE
                template_type = p_template_typ
                AND apex_app_id = p_app_id
                AND TO_CHAR(apex_menu_item) = TO_CHAR(p_page_id)
                AND ( upper(apex_feature) = upper(p_apex_feature)
                      OR p_apex_feature IS NULL )

                --UPPER(APEX_FEATURE) = nvl(UPPER(P_APEX_FEATURE) ,P_APEX_FEATURE )
        ) LOOP
            RETURN i.template_name;
        END LOOP;

        RETURN NULL;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_template_name' || sqlerrm);
            RETURN NULL;
    END;

    PROCEDURE get_template_info (
        p_template_typ    IN                VARCHAR2,
        p_app_id          IN                NUMBER,
        p_page_id         IN                NUMBER,
        p_apex_feature    IN                VARCHAR2,
        p_template_id     OUT               NUMBER,
        p_template_name   OUT               VARCHAR2
    ) AS
    BEGIN
        FOR i IN (
            SELECT
                template_name,
                template_id
            FROM
                v_ansible_template_store
            WHERE
                template_type = p_template_typ
                AND apex_app_id = p_app_id
                AND apex_menu_item = p_page_id
                AND ( upper(apex_feature) = upper(p_apex_feature)
                      OR p_apex_feature IS NULL )
        ) LOOP
            p_template_id := i.template_id;
            p_template_name := i.template_name;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_template_info' || sqlerrm);
    END;

    FUNCTION get_tower_domain RETURN VARCHAR2 AS
    BEGIN
        FOR i IN (
            SELECT
                setting_value
            FROM
                v_app_settings
            WHERE
                setting_category = 'TOWER DOMAIN'
        ) LOOP
            RETURN i.setting_value;
        END LOOP;

        RETURN NULL;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_tower_domain' || sqlerrm);
    END;

    FUNCTION get_inventory_id RETURN NUMBER AS
    BEGIN
        FOR i IN (
            SELECT
                setting_value
            FROM
                v_app_settings
            WHERE
                setting_category = 'ORACLE INVENTORY ID'
        ) LOOP
            RETURN i.setting_value;
        END LOOP;

        RETURN NULL;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('get_inventory_id' || sqlerrm);
    END;

    PROCEDURE exec_workflow (
        p_req_id IN   NUMBER
    ) AS

        v_inventory_id    NUMBER;
        p_ticket_ref      VARCHAR2(200);
        p_response        CLOB;
        v_param_json      CLOB;
        v_template_type   VARCHAR2(1);
        v_request_type    VARCHAR2(200);
        v_job_name        VARCHAR2(200);
        v_workflow_id     NUMBER;
        v_group_id        NUMBER;
        v_host_name       CLOB;
        v_host_id         number;
  --p_req_id number;
        p_request_id      NUMBER;
        v_job_id          NUMBER;
        v_response        CLOB;
        l_unq_grp varchar2(255) := '_'||to_char(sysdate,'HH24_MI_SS');
        v_group_name varchar2(255);
    BEGIN
        v_inventory_id := oac$ansible_utl.get_inventory_id;
        SELECT
            ticket_ref,
            extra_vars,
            template_type,

        --TEMPLATE_NAME,
            job_name,
            request_type,
            host_name
        INTO
            p_ticket_ref,
            v_param_json,
            v_template_type,
            v_job_name,
            v_request_type,
            v_host_name
        FROM
            v_request_queue
        WHERE
            id = p_req_id;
        
        
        --Setup a Unique Grp Name
        --Added MGP Jan 10 2019
        -- 
        v_group_name := p_ticket_ref||l_unq_grp;
       
        v_workflow_id := oac$ansible_rest_utl.get_workflow_id(v_job_name);
        
        oac$ansible_rest_utl.add_group(p_inventory_id => v_inventory_id, p_group_name => p_ticket_ref, p_response => p_response);

        v_group_id := oac$ansible_rest_utl.get_group_id(p_ticket_ref);
        
        BEGIN

    -- ADDING THE GROUP ID
            UPDATE v_request_queue
            SET
                group_id = v_group_id
            WHERE
                id = p_req_id;

            COMMIT;
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('ADDING GROUP ID TO TABLE: ' || sqlerrm);
        END;

  -- adding multiple hosts to the group

        FOR i IN (
            SELECT
                column_value
            FROM
                TABLE ( apex_string.split(v_host_name, ',') )
                order by column_value
        ) LOOP
        
          --MGP do not apply the domain to the host
          --For Charter Demo needed to remove appending the
          -- 
          --   v_host_id := oac$ansible_rest_utl.get_host_id(i.column_value || oac$ansible_rest_utl.g_tower_domain);
            v_host_id := oac$ansible_rest_utl.get_host_id(i.column_value );

            
            IF
                v_host_id IS NOT NULL
            THEN
              dbms_output.put_line('Hosts exists');
                oac$ansible_rest_utl.add_host_to_group(
                    p_group_id   => v_group_id,
                    p_host_id    => v_host_id,
                    p_response   => p_response
                );
                 dbms_output.put_line(p_response);
            ELSE
              dbms_output.put_line('Hosts dos not exists');

                oac$ansible_rest_utl.create_host_to_group(
                    p_inventory_id   => v_inventory_id,
                    p_group_id       => v_group_id,
                    p_host_name      => i.column_value,
                    p_response       => p_response
                );
               dbms_output.put_line(p_response); 
            END IF;
        END LOOP;

        oac$ansible_rest_utl.make_rest_call(
            p_flag         => v_template_type,
            p_id           => v_workflow_id,
            p_param_json   => v_param_json,
            p_response     => v_response
        );

        dbms_output.put_line('v_response: ' || v_response);
        UPDATE v_request_queue
        SET
            status = 'E'
        WHERE
            id = p_req_id;

        COMMIT;

   -- parse and store response
        oac$ansible_rest_utl.parse_and_store_resp(p_request_type => v_request_type, p_job_name => v_job_name, p_ticket_ref => p_ticket_ref
        , p_target_name => v_host_name, p_resp_clob => v_response, p_id => v_job_id, p_request_id => p_request_id);

        dbms_output.put_line('v_job_id: ' || v_job_id);
        dbms_output.put_line('p_request_id: ' || p_request_id);
        UPDATE v_self_service_status
        SET
            req_queue_id = p_req_id
        WHERE
            request_id = p_request_id;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(sqlerrm);
    END;

    FUNCTION exec_workflow (
        p_req_id IN   NUMBER
    ) return number AS

        v_inventory_id    NUMBER;
        p_ticket_ref      VARCHAR2(200);
        p_response        CLOB;
        v_param_json      CLOB;
        v_template_type   VARCHAR2(1);
        v_request_type    VARCHAR2(200);
        v_job_name        VARCHAR2(200);
        v_workflow_id     NUMBER;
        v_group_id        NUMBER;
        v_host_name       CLOB;
        v_host_id         number;

  --p_req_id number;
        p_request_id      NUMBER;
        v_job_id          NUMBER;
        v_response        CLOB;
        l_unq_grp varchar2(255) := '_'||to_char(sysdate,'HH24_MI_SS');
        v_group_name varchar2(255);
    BEGIN
        v_inventory_id := oac$ansible_utl.get_inventory_id;
        SELECT
            ticket_ref,
            extra_vars,
            template_type,

        --TEMPLATE_NAME,
            job_name,
            request_type,
            host_name
        INTO
            p_ticket_ref,
            v_param_json,
            v_template_type,
            v_job_name,
            v_request_type,
            v_host_name
        FROM
            v_request_queue
        WHERE
            id = p_req_id;
            
           --For Uniqueness
        --Added MGP Jan 10 2019
        -- 
        v_group_name := p_ticket_ref||l_unq_grp;    
        --dbms_output.put_line('Extra vars:'||substr(v_param_json,1,2000) );
        v_workflow_id := oac$ansible_rest_utl.get_workflow_id(v_job_name);
        dbms_output.put_line('Job name: ' || v_job_name); 
        dbms_output.put_line('Workflow id: ' || v_workflow_id);
        oac$ansible_rest_utl.add_group(p_inventory_id => v_inventory_id, p_group_name => p_ticket_ref, p_response => p_response);

        v_group_id := oac$ansible_rest_utl.get_group_id(p_ticket_ref);
        BEGIN

    -- ADDING THE GROUP ID
            UPDATE v_request_queue
            SET
                group_id = v_group_id
            WHERE
                id = p_req_id;

            COMMIT;
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('ADDING GROUP ID TO TABLE: ' || sqlerrm);
        END;
  -- dbms_output.put_line('Grp Id:'||v_group_id);
  -- adding multipl hosts to the group
    --    dbms_output.put_line('Raw Host:'||v_host_name);
        FOR i IN (
            SELECT
                column_value
            FROM TABLE ( apex_string.split(v_host_name,',') )
            order by column_value
        ) LOOP
        
            --v_host_id := oac$ansible_rest_utl.get_host_id(i.column_value || oac$ansible_rest_utl.g_tower_domain);
            v_host_id := oac$ansible_rest_utl.get_host_id(i.column_value );
            -- dbms_output.put_line('Id:'||v_host_id);
            IF
                v_host_id IS NOT NULL
            THEN
           -- dbms_output.put_line('Add Id:'||v_host_name);
                oac$ansible_rest_utl.add_host_to_group(
                    p_group_id   => v_group_id,
                    p_host_id    => v_host_id,
                    p_response   => p_response
                );
           --  dbms_output.put_line('Add ID Response:'||p_response);   
            ELSE
            --    dbms_output.put_line('Create host:'||i.column_value);
                 --  DBMS_OUTPUT.PUT_LINE (l_hosts_a(i)||g_tower_domain||' - The host id ' ||l_host_id);
                oac$ansible_rest_utl.create_host_to_group(
                    p_inventory_id   => v_inventory_id,
                    p_group_id       => v_group_id,
                    p_host_name      => i.column_value,
                    p_response       => p_response
                );
            -- dbms_output.put_line('Response:'||p_response);

            END IF;
        END LOOP;
     
        oac$ansible_rest_utl.make_rest_call(
            p_flag         => v_template_type,
            p_id           => v_workflow_id,
            p_param_json   => v_param_json,
            p_response     => v_response
        );

        dbms_output.put_line('v_response: ' || v_response);
        UPDATE v_request_queue
        SET
            status = 'E'
        WHERE
            id = p_req_id;

        COMMIT;

   -- parse and store response
        oac$ansible_rest_utl.parse_and_store_resp(p_request_type => v_request_type, p_job_name => v_job_name, p_ticket_ref => p_ticket_ref
        , p_target_name => v_host_name, p_resp_clob => v_response, p_id => v_job_id, p_request_id => p_request_id);

        dbms_output.put_line('v_job_id: ' || v_job_id);
        dbms_output.put_line('p_request_id: ' || p_request_id);
        UPDATE v_self_service_status
        SET
            req_queue_id = p_req_id
        WHERE
            request_id = p_request_id;

        COMMIT;
        return p_request_id;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(sqlerrm);
            return null;
    END;

    FUNCTION exec_playbook_c (
        p_req_id IN   NUMBER
    ) return number AS

        v_inventory_id    NUMBER;
        p_ticket_ref      VARCHAR2(200);
        p_response        CLOB;
        v_param_json      CLOB;
        v_template_type   VARCHAR2(1);
        v_request_type    VARCHAR2(200);
        v_job_name        VARCHAR2(200);
        v_workflow_id     NUMBER;
        v_group_id        NUMBER;
        v_host_name       CLOB;
        v_host_id         number;
        v_cluster_name    v_request_queue.cluster_name%TYPE;

  --p_req_id number;
        p_request_id      NUMBER;
        v_job_id          NUMBER;
        v_response        CLOB;
    BEGIN
        v_inventory_id := oac$ansible_utl.get_inventory_id;
        SELECT
            ticket_ref,
            extra_vars,
            template_type,

        --TEMPLATE_NAME,
            job_name,
            request_type,
            host_name,
            cluster_name
        INTO
            p_ticket_ref,
            v_param_json,
            v_template_type,
            v_job_name,
            v_request_type,
            v_host_name,
            v_cluster_name
        FROM
            v_request_queue
        WHERE
            id = p_req_id;
        --dbms_output.put_line('Extra vars:'||substr(v_param_json,1,2000) );
        v_workflow_id := oac$ansible_rest_utl.get_workflow_id(v_job_name);
        dbms_output.put_line('Job name: ' || v_job_name); 
        dbms_output.put_line('Workflow id: ' || v_workflow_id);
        oac$ansible_rest_utl.add_group(p_inventory_id => v_inventory_id, p_group_name => v_cluster_name , p_response => p_response);

        v_group_id := oac$ansible_rest_utl.get_group_id(v_cluster_name);
        BEGIN

    -- ADDING THE GROUP ID
            UPDATE v_request_queue
            SET
                group_id = v_group_id
            WHERE
                id = p_req_id;

            COMMIT;
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('ADDING GROUP ID TO TABLE: ' || sqlerrm);
        END;
  -- dbms_output.put_line('Grp Id:'||v_group_id);
  -- adding multipl hosts to the group
    --    dbms_output.put_line('Raw Host:'||v_host_name);
        FOR i IN (
            SELECT
                column_value
            FROM TABLE ( apex_string.split(v_host_name,',') )
        ) LOOP
        
            v_host_id := oac$ansible_rest_utl.get_host_id(i.column_value );
            -- dbms_output.put_line('Id:'||v_host_id);
            IF
                v_host_id IS NOT NULL
            THEN
          --  dbms_output.put_line('Add Id:'||v_host_name);
                oac$ansible_rest_utl.add_host_to_group(
                    p_group_id   => v_group_id,
                    p_host_id    => v_host_id,
                    p_response   => p_response
                );
            ELSE
             --   dbms_output.put_line('Create host:'||i.column_value);
                 --  DBMS_OUTPUT.PUT_LINE (l_hosts_a(i)||g_tower_domain||' - The host id ' ||l_host_id);
                oac$ansible_rest_utl.create_host_to_group(
                    p_inventory_id   => v_inventory_id,
                    p_group_id       => v_group_id,
                    p_host_name      => i.column_value,
                    p_response       => p_response
                );
            END IF;
        END LOOP;
     
        oac$ansible_rest_utl.make_rest_call(
            p_flag         => v_template_type,
            p_id           => v_workflow_id,
            p_param_json   => v_param_json,
            p_response     => v_response
        );

        dbms_output.put_line('v_response: ' || v_response);
        UPDATE v_request_queue
        SET
            status = 'E'
        WHERE
            id = p_req_id;

        COMMIT;

   -- parse and store response
        oac$ansible_rest_utl.parse_and_store_resp(p_request_type => v_request_type, p_job_name => v_job_name, p_ticket_ref => p_ticket_ref
        , p_target_name => v_host_name, p_resp_clob => v_response, p_id => v_job_id, p_request_id => p_request_id);

        dbms_output.put_line('v_job_id: ' || v_job_id);
        dbms_output.put_line('p_request_id: ' || p_request_id);
        UPDATE v_self_service_status
        SET
            req_queue_id = p_req_id
        WHERE
            request_id = p_request_id;

        COMMIT;
        return p_request_id;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(sqlerrm);
            return null;
    END;    
    
    FUNCTION encrypt (
        p_plaintext VARCHAR2
    ) RETURN RAW
        DETERMINISTIC
    IS
        encrypted_raw   RAW(2000);
    BEGIN
        encrypted_raw := dbms_crypto.encrypt(src => utl_raw.cast_to_raw(p_plaintext), typ => encryption_type, key => encryption_key
        );

        RETURN encrypted_raw;
    END encrypt;

    FUNCTION decrypt (
        p_encryptedtext RAW
    ) RETURN VARCHAR2
        DETERMINISTIC
    IS
        decrypted_raw   RAW(2000);
    BEGIN
        decrypted_raw := dbms_crypto.decrypt(src => p_encryptedtext, typ => encryption_type, key => encryption_key);

        return(utl_raw.cast_to_varchar2(decrypted_raw));
    END decrypt;

    -- Removing the group and setting the status to the O.
    PROCEDURE remove_group ( p_req_id IN NUMBER ) IS
        v_response   CLOB;
    BEGIN
        NULL;
        FOR i IN (
            SELECT
                group_id
            FROM v_request_queue
            WHERE
                id = p_req_id
        ) LOOP
            oac$ansible_rest_utl.delete_group(i.group_id,v_response);
            
            IF   instr(v_response,'Error') <= 0     THEN
                UPDATE v_request_queue
                    SET
                        status = 'O'
                WHERE
                    id = p_req_id;

                COMMIT;
            else
             dbms_output.put_line('Error during remove:' || instr(v_response,'Error'));            
             dbms_output.put_line('Remove Group for request response:');
             dbms_output.put_line(substr(v_response,1,250));
            END IF;
            
            v_response   := NULL;
        END LOOP;
    
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('Remove Group for request' || sqlerrm);
    END;

    /**
     author: Jaydipsinh Raulji
     Purpose: Delete hosts associated with given job request.
    */    
    PROCEDURE remove_hosts ( p_req_id IN NUMBER ) IS
        v_response   CLOB;
        v_host_id    NUMBER;
    BEGIN
        NULL;
        FOR i IN (
            SELECT
                column_value
            FROM v_request_queue,
                 TABLE ( apex_string.split(host_name,',') )
            WHERE
                id = p_req_id
        ) LOOP
            v_host_id   := oac$ansible_rest_utl.get_host_id(i.column_value || oac$ansible_rest_utl.g_tower_domain);
            IF
                v_host_id IS NOT NULL
            THEN
                oac$ansible_rest_utl.delete_host(v_host_id,v_response);
            END IF;
    
        END LOOP;
    
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('Remove Host for request' || sqlerrm);
    END;    

    PROCEDURE refresh_job ( p_self_srvc_id IN NUMBER ) AS
    
        l_clob            CLOB;
            --l_amount          NUMBER;
           -- l_offset          NUMBER;
           -- l_buffer          VARCHAR2(32767);
            --v_amount          NUMBER;
           -- v_offset          NUMBER;
        v_response        CLOB;
            --v_id              NUMBER;
        v_job_url         VARCHAR2(100);
        v_status          VARCHAR2(500);
        v_result_stdout   CLOB;
        l_values          apex_json.t_values;
            --p_endpoint        VARCHAR2(100);
    BEGIN
        --INTO v_job_url
        FOR i IN (
            SELECT
                job_url
            FROM v_self_service_status
            WHERE
                request_id = p_self_srvc_id
        ) LOOP
            dbms_output.put_line('Inside Refresh Job...');
            oac$ansible_rest_utl.do_rest_call(
                p_url           => rtrim(oac$ansible_rest_utl.g_tower_url,'/') ||i.job_url,
                p_http_method   => 'GET',
                p_response      => v_response
            );
            --DBMS_OUTPUT.PUT_LINE(v_response);
    
            l_clob            := v_response;
            --v_amount          := 32000;
            --v_offset          := 1;
            dbms_output.put_line('Inside Refresh Job2...');
            apex_json.parse(
                p_values   => l_values,
                p_source   => l_clob
            );
            v_status          := apex_json.get_varchar2(
                p_values   => l_values,
                p_path     => 'status'
            );
            v_result_stdout   := apex_json.get_varchar2(
                p_values   => l_values,
                p_path     => 'result_stdout'
            );
            
            -- fetching stdout result.             
            oac$ansible_rest_utl.do_rest_call(
                p_url           => rtrim(oac$ansible_rest_utl.g_tower_url,'/') ||i.job_url ||'stdout/?format=txt',
                p_http_method   => 'GET',
                p_response      => v_result_stdout
            );              
            --dbms_output.put_line('v_status: ' || v_status);
            --dbms_output.put_line('v_result_stdout: ' || v_result_stdout);
            UPDATE v_self_service_status
                SET
                    job_result = v_status,
                    result_stdout = v_result_stdout
            WHERE
                request_id = p_self_srvc_id;
    
            COMMIT;
        END LOOP;
    END refresh_job;

    /**
     author: Jaydipsinh Raulji
     Purpose: This procedure will be used as a part of job which do check not completed jobs & refresh the same.
    */
    PROCEDURE refresh_jobs
        AS
    BEGIN
        FOR i IN (
            SELECT
                request_id
            FROM v_self_service_status
            WHERE
                TRIM(job_result) NOT IN (
                    'failed','successful','canceled'
                )
        ) LOOP
            oac$ansible_utl.refresh_job(i.request_id);
        END LOOP;
    END;
    
    /**
     author: Jaydipsinh Raulji
     Purpose: This procedure will be used as a part of job which do check completed jobs & remove associated groups.
     Updated defination to executed only executed and completed ones.
    */
    PROCEDURE remove_job_groups
        AS
    BEGIN
     dbms_output.put_line('Removing Any Groups and Hosts that have completed Jobs');
        FOR i IN (
          SELECT
            s.request_id,
                s.req_queue_id,
                s.TICKET_REF,
                s.JOB_NAME,
                s.created ,
                q.group_id
            FROM v_self_service_status s
            ,v_request_queue q
            WHERE
                    TRIM(s.job_result) IN (
                        'failed','successful','canceled'
                    )
             and    s.req_queue_id = q.id
              --Only Jobs we have not already removed the group on
              --
                AND EXISTS (
                        SELECT
                            1
                        FROM v_request_queue
                        WHERE
                                v_request_queue.id = req_queue_id
                            AND v_request_queue.status = 'E'
                    )
               --
               -- Do not remove the group if a Job is running/pending 
               -- that refrences the same group
               --
              and not exists (
             SELECT
                s.req_queue_id,
                s.TICKET_REF,
                s.JOB_NAME,
                s.created ,
                q.group_id
            FROM v_self_service_status si
            ,v_request_queue qi
            WHERE
                    TRIM(si.job_result) NOT IN (
                        'failed','successful','canceled'
                    )
            
             and    si.req_queue_id = qi.id
             and qi.group_id = q.group_id
            )
             and s.created >= sysdate - 60
           order by created desc
        ) LOOP
            dbms_output.put_line('Remove group Ticket Ref/Job: '||i.TICKET_REF||'/'||i.job_name);
            oac$ansible_utl.remove_group(i.req_queue_id);
        END LOOP;
    

    END; 


 --
 --
 --

PROCEDURE LOAD_TOWER_SETUP (
    p_action   IN         VARCHAR2 DEFAULT 'LOAD',
    p_parm1    IN         VARCHAR2 DEFAULT NULL,
    p_parm2    IN         VARCHAR2 DEFAULT NULL,
    p_parm3    IN         VARCHAR2 DEFAULT NULL
) AS

    l_clob           CLOB;
    v_id             NUMBER;
    v_url            VARCHAR2(1000) ;
    v_status         VARCHAR2(1000);
    p_username       VARCHAR2(255) := 'apex';
    p_password       VARCHAR2(255) := 'apex1234';
    g_endpoint_prefix  VARCHAR2(1000);
    g_wallet_path    VARCHAR2(255) := 'file:/home/oracle/app/oracle/product/12.2.0/dbhome_1/user';
    g_wallet_pass    VARCHAR2(255) := 'oracle123';
    g_content_type   VARCHAR2(255) := 'application/json';
       g_tower_url  VARCHAR2(1000);
     l_finish       boolean          := false;
     next_url varchar2(1000);
   
    BEGIN
    -- Purpose:
    -- Load Tower setup into tables so that we can use them to create LOVs
    -- which will be used for populating our mapping table
    --  V_ANSIBLE_TEMPLATE_STORE
    -- The Procudre make 3 Rest calls to extract 
    -- Organizations
    -- Inventories
    -- job_templates
    --  It takes the result sand loads them into tables, Only add records that are missing, 
    -- So  it can be called reptable in case we need to refresh Could add deletes to the tables..

     OAC$ANSIBLE_REST_UTL.config ('INIT');
     p_username := OAC$ANSIBLE_REST_UTL.p_username;
     p_password := OAC$ANSIBLE_REST_UTL.p_password;
     g_wallet_path   := OAC$ANSIBLE_REST_UTL.g_wallet_path ;
     g_wallet_pass  := OAC$ANSIBLE_REST_UTL.g_wallet_pass;
     g_endpoint_prefix  := OAC$ANSIBLE_REST_UTL.g_endpoint_prefix;
     g_tower_url := OAC$ANSIBLE_REST_UTL.g_tower_url;
     --If the URl ends in / then remove it as the next URLs begin with the /
     if  substr(g_tower_url,-1) = '/' then
        g_tower_url := substr(g_tower_url,1,length(g_tower_url) -1 );
     end if;   



    apex_web_service.g_request_headers(1).name := 'Content-Type';
    apex_web_service.g_request_headers(1).value := g_content_type; --'application/json'; 
  -- host should be dbtest04.techlab.com 

   delete from v_ansible_job_templates; 
  l_finish  := false;
  v_url    := g_endpoint_prefix|| 'job_templates/';
  while not l_finish loop
  
      OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 

 /*   l_clob := apex_web_service.make_rest_request(p_url => v_url, p_http_method => 'GET', p_username => p_username, p_password => p_password
    , p_wallet_path => g_wallet_path, p_wallet_pwd => g_wallet_pass);
    --    DBMS_OUTPUT.PUT_LINE(substr(l_clob,1,300));    
   */ 
    /*
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    );*/
   -- 
   --Added a commit for tracing
   --
   commit;
   
    INSERT INTO v_ansible_job_templates (
        id,
        name,
        description,
        playbook,
        url,
        inventory,
        TEMPLATE_TYPE
    )
        SELECT
            id,
            name,
            description,
            playbook,
            url,
            inventory,
            'P'
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) COLUMNS name VARCHAR2(255) PATH 'name', id NUMBER PATH 'id', inventory VARCHAR2
            (1000) PATH 'inventory', description VARCHAR2(1000) PATH 'description', playbook VARCHAR2(1000) PATH 'playbook', url VARCHAR2
            (1000) PATH 'url' ) x;

  select
            x.next_page into next_url 
        from xmltable( 
            '/json'
            passing apex_json.to_xmltype( l_clob )
            columns
                next_page varchar2(1000) path 'next'
        ) x;
        
        if next_url is null then 
        l_finish := true; 
        else
         v_url := g_tower_url||next_url;
         --dbms_output.put_line('Hosts Next: '||v_url);
        end if;
   
 end loop;
 
--  v_url := 'https://tower.techlab.com/api/v2/workflow_job_templates/';

 l_finish  := false;
  v_url    := g_endpoint_prefix|| 'workflow_job_templates/';
  while not l_finish loop

      OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 
       
    --    DBMS_OUTPUT.PUT_LINE(substr(l_clob,1,300));    
    /*
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    );*/
   -- 
   --Added a commit for tracing
   --
   commit;

    INSERT INTO v_ansible_job_templates (
        id,
        name,
        description,
        playbook,
        url,
        inventory,
        TEMPLATE_TYPE
    )
        SELECT
            id,
            name,
            description,
            playbook,
            url,
            inventory,
            'W'
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) COLUMNS name VARCHAR2(255) PATH 'name', id NUMBER PATH 'id', inventory VARCHAR2
            (1000) PATH 'inventory', description VARCHAR2(1000) PATH 'description', playbook VARCHAR2(1000) PATH 'playbook', url VARCHAR2
            (1000) PATH 'url' ) x
        ;

  select
            x.next_page into next_url 
        from xmltable( 
            '/json'
            passing apex_json.to_xmltype( l_clob )
            columns
                next_page varchar2(1000) path 'next'
        ) x;
        
        if next_url is null then 
        l_finish := true; 
        else
         v_url := g_tower_url||next_url;
         --dbms_output.put_line('Hosts Next: '||v_url);
        end if;
   
 end loop;
   -- v_url := 'https://tower.techlab.com/api/v2/inventories/';
   v_url    := g_endpoint_prefix|| 'inventories/';
/*
    l_clob := apex_web_service.make_rest_request(p_url => v_url, p_http_method => 'GET', p_username => p_username, p_password => p_password
    , p_wallet_path => g_wallet_path, p_wallet_pwd => g_wallet_pass);
   --    DBMS_OUTPUT.PUT_LINE(substr(l_clob,1,300));    
*/
     OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 
    /*   
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    );*/
   -- 
   --Added a commit for tracing
   --
   commit;
   delete from v_ansible_inventories;
    INSERT INTO v_ansible_inventories (
        id,
        name,
        description,
        organization,
        variables
    )
        SELECT
            id,
            name,
            description,
            organization,
            variables
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) COLUMNS name VARCHAR2(255) PATH 'name', id NUMBER PATH 'id', inventory VARCHAR2
            (1000) PATH 'inventory', description VARCHAR2(1000) PATH 'description', organization NUMBER PATH 'organization', variables
            VARCHAR2(4000) PATH 'variables' ) x ;

   -- v_url := 'https://tower.techlab.com/api/v2/organizations/';
   v_url    := g_endpoint_prefix|| 'organizations/';
/*
    l_clob := apex_web_service.make_rest_request(p_url => v_url, p_http_method => 'GET', p_username => p_username, p_password => p_password
    , p_wallet_path => g_wallet_path, p_wallet_pwd => g_wallet_pass);
   --    DBMS_OUTPUT.PUT_LINE(substr(l_clob,1,300));    
  */
       OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 
    /*   
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    ); */
   -- 
   --Added a commit for tracing
   --
   commit;
  delete from v_ansible_organizations;
  INSERT INTO v_ansible_organizations (
    id,
    name,
    description
)        SELECT
             id,
    name,
    description
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) COLUMNS name VARCHAR2(255) PATH 'name', id NUMBER PATH 'id', description
            VARCHAR2(1000) PATH 'description' ) x ;
    
    
   l_finish  := false;
   v_url    := g_endpoint_prefix|| 'groups/';
   delete from v_ansible_groups; 
  while not l_finish loop
  
      OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 
   /* 
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    );*/
   -- 
   --Added a commit for tracing
   --
   commit;
   
   
   
    INSERT INTO v_ansible_groups (
        id,
        name,
        description,
        url,
        inventory,
        total_hosts
    )
    SELECT
        id,
        name,
        description,
        url,
        inventory,
        total_hosts
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) 
             COLUMNS
             name VARCHAR2(255) PATH 'name',
             id NUMBER PATH 'id',
             inventory VARCHAR2(1000) PATH 'inventory',
             description VARCHAR2(1000) PATH 'description',
             url VARCHAR2(1000) PATH 'url' ,
             total_hosts NUMBER PATH 'total_hosts' ) x
   ;
     select
            x.next_page into next_url 
        from xmltable( 
            '/json'
            passing apex_json.to_xmltype( l_clob )
            columns
                next_page varchar2(1000) path 'next'
        ) x;
        
        if next_url is null then 
        l_finish := true; 
        else
         v_url := g_tower_url||next_url;
         --dbms_output.put_line('Hosts Next: '||v_url);
        end if;
   
 end loop;
 
 
   delete from v_ansible_hosts;   
   l_finish  := false;
   v_url    := g_endpoint_prefix|| 'hosts/';

   while not l_finish loop

  
      OAC$ANSIBLE_REST_UTL.do_rest_call (  P_URL => v_url,
       P_HTTP_METHOD => 'GET',
       P_CONTENT_TYPE => g_content_type,
       P_RESPONSE => l_clob) ; 
    /*
    INSERT INTO v_ansible_api_result (
     request_type,
     call_url,
     response
    ) values (
    'GET',
     v_url,
     l_clob
    );
    */
   -- 
   --Added a commit for tracing
   --
    commit;
   
    INSERT INTO v_ansible_hosts (
        id,
        name,
        description,
        url,
        inventory
    )
    SELECT
        id,
        name,
        description,
        url,
        inventory
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) 
             COLUMNS
             name VARCHAR2(255) PATH 'name',
             id NUMBER PATH 'id',
             inventory VARCHAR2(1000) PATH 'inventory',
             description VARCHAR2(1000) PATH 'description',
             url VARCHAR2(1000) PATH 'url' ,
             total_hosts NUMBER PATH 'total_hosts' ) x
   ;
 

   select
            x.next_page into next_url 
        from xmltable( 
            '/json'
            passing apex_json.to_xmltype( l_clob )
            columns
                next_page varchar2(1000) path 'next'
        ) x;
        
        if next_url is null then 
        l_finish := true; 
        else
         v_url := g_tower_url||next_url;
         --dbms_output.put_line('Hosts Next: '||v_url);
        end if;
   
 end loop;


 
 /*
    FOR c1 IN (
        SELECT
            *
        FROM
            XMLTABLE (
                --'/json/items/row'
             '/json/results/row' PASSING apex_json.to_xmltype(l_clob) COLUMNS name VARCHAR2(255) PATH 'name', id NUMBER PATH 'id', description
            VARCHAR2(1000) PATH 'description' ) x
    ) LOOP
        dbms_output.put_line(c1.id
                             || ' '
                             || c1.name
                             || ', '
                             || c1.description
                             || ' ');
    END LOOP;
*/
    end;

 procedure setup_batch_jobs(
  p_action in varchar2 default 'DAILY',
p_parm1 in varchar2 default null,
p_parm2 in varchar2 default null,
p_parm3 in varchar2 default null
) as
jobno number;
qt varchar2(30) := '''';
good_job number := 0;
Begin

  if p_action in ('DAILY','CREATE') then
    /* Refresh the job status every 30 mins , only for jobs with non completed status */
    setup_batch_job(  p_search => upper('%OAC$ANSIBLE_UTL.refresh_jobs%'),
    p_what => upper('OAC$ANSIBLE_UTL.refresh_jobs();'),
    p_start => sysdate + 5/(24 *60)  , 
    p_interval => 'sysdate + 30/(24 *60)' );

  /*
   setup_batch_job(  p_search => upper('%OAC$ANSIBLE_UTL.remove_job_groups%'),
    p_what => upper('OAC$ANSIBLE_UTL.remove_job_groups ();'),
    p_start => sysdate + 15/(24 *60)  , 
    p_interval => 'sysdate + 15/(24 *60)' );
*/
   /* Remove Groups and hosts every 8 hrs */
   setup_batch_job(  p_search => upper('%OAC$ANSIBLE_UTL.remove_job_groups%'),
    p_what => upper('OAC$ANSIBLE_UTL.remove_job_groups ();'),
    p_start => sysdate + .1/24  , 
    p_interval => 'sysdate + 8/24' );

   /* Run Operational Task every 15 Mins */
   setup_batch_job(  p_search => upper('%STANDARD_TASK_MGR .task_queue%'),
    p_what => upper('STANDARD_TASK_MGR .task_queue( p_action => '||qt||'CHECK_SCHEDULE'||qt||');'),
    p_start => sysdate + .1/24  , 
    p_interval => 'sysdate + .25/24' );


  elsif p_action in ('REMOVE','DELETE','DROP') then
    remove_batch_job(  p_search => upper('%OAC$ANSIBLE_UTL.remove_job_groups%'));
    remove_batch_job(  p_search => upper('%OAC$ANSIBLE_UTL.refresh_jobs%'));
    remove_batch_job(  p_search => upper('%STANDARD_TASK_MGR .task_queue%'));
  end if;
  
end;

 procedure setup_batch_job(
  p_search in varchar2 default null,
p_what in varchar2 default null,
p_start in date default null,
p_interval in varchar2 default null
) as
jobno number;
qt varchar2(30) := '''';
good_job number := 0;
Begin

  dbms_output.put_line('Remove Job:');
  dbms_output.put_line(rpad('-',75,'-'));
  for c2 in (
          select
           job
           ,broken
          from dba_jobs
          where
             upper(what) like p_search
         )
   loop
       if c2.broken = 'Y' then
        sys.dbms_ijob.remove(c2.job);
        dbms_output.put_line('Removing broken Job no:'||c2.job);
       else
        good_job := 1;
       end if;

   end loop;

 if good_job <= 0 then
   dbms_job.submit (jobno, p_what,  next_date => p_start , interval => p_interval );
 end if;
 
 
commit;
  dbms_output.put_line('New Job:');
  dbms_output.put_line(rpad('-',75,'-'));

  for c2 in (
          select
           job
           ,what
           ,to_char (NEXT_DATE,'DD-MON HH24:MI') NEXT_DATE
           ,interval
          from dba_jobs
          where
             upper(what) like p_search
         )
   loop
       dbms_output.put_line('Job no:'||c2.job);
       dbms_output.put_line('What:'||c2.what);
       dbms_output.put_line('Next:'||c2.Next_date);
       dbms_output.put_line('Interval:'||c2.interval);
   end loop;

end;


 procedure remove_batch_job(
  p_search in varchar2 default null,
p_what in varchar2 default null,
p_start in date default null,
p_interval in varchar2 default null
) as
jobno number;
qt varchar2(30) := '''';
good_job number := 0;
Begin

  dbms_output.put_line('Remove Job Serach for jobs like:');
  dbms_output.put_line('Search string :'||p_search);
  dbms_output.put_line(rpad('-',75,'-'));
  for c2 in (
          select
           job
           ,broken
          from dba_jobs
          where
             upper(what) like p_search
         )
   loop
        sys.dbms_ijob.remove(c2.job);
        dbms_output.put_line('For Search Removing Job no:'||c2.job);
   end loop;
 
 
commit;

end;


END oac$ansible_utl;

/

  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_UTL" TO "CHARTER2_SQL";
  GRANT EXECUTE ON "CHARTER2_INV"."OAC$ANSIBLE_UTL" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package Body OAC$AUTH_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."OAC$AUTH_UTL" is

function is_internal_admin
  return boolean
is
  v_admin_list varchar2(1000) := 'JMITCHELL:MPERRY:GURI:JRAULJI_DEV:HARPREET:JAY';
begin

  for i in (select 1 from dual 
                where exists 
                  ( select 1 from 
                     table( apex_string.split(v_admin_list,':') ) 
                     where COLUMN_VALUE = V('APP_USER')
                 ))
  loop
      return true;
  end loop;
  return false;
exception
when others then
  return false;
end is_internal_admin;

end "OAC$AUTH_UTL";

/
--------------------------------------------------------
--  DDL for Package Body OAC$FILE_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."OAC$FILE_UTL" AS

    FUNCTION get_path ( p_dir IN VARCHAR2 ) RETURN VARCHAR2 IS
        o_path   all_directories.directory_path%TYPE;
    BEGIN
        SELECT
            directory_path
        INTO
            o_path
        FROM all_directories d
        WHERE
            d.directory_name = p_dir;

        RETURN o_path;
    END get_path;

    FUNCTION get_ora_dirname ( p_path IN VARCHAR2 ) RETURN VARCHAR2
        IS
    BEGIN
        FOR i IN (
            SELECT
                directory_name
            FROM all_directories d
            WHERE
                d.directory_path = p_path
        ) LOOP
            RETURN i.directory_name;
        END LOOP;

        RETURN NULL;
    END get_ora_dirname;

    FUNCTION create_ora_dir (
        p_dir_name   IN VARCHAR2,
        p_dir_path   IN VARCHAR2
    ) RETURN VARCHAR2
        IS
    BEGIN
        EXECUTE IMMEDIATE 'create or replace directory ' ||p_dir_name ||' as ''' ||p_dir_path ||'''';
        RETURN p_dir_name;
    END;

    FUNCTION create_ora_dir ( p_dir_path IN VARCHAR2 ) RETURN VARCHAR2 IS
        v_dir_name   VARCHAR2(100);
        v_sql        VARCHAR2(2000);
    BEGIN
        v_dir_name   := g_dir_name_pref ||TO_CHAR(systimestamp,'RRMMDDHH24MISSFF6');
        v_sql        := 'create or replace directory ' ||v_dir_name ||' as ''' ||p_dir_path ||'''';
        EXECUTE IMMEDIATE ( v_sql ); 
        --EXECUTE IMMEDIATE 'create or replace directory ' ||v_dir_name ||' as ''' ||p_dir_path ||'''';
        RETURN v_dir_name;
    END;

    PROCEDURE drop_ora_dir ( p_dir_name IN VARCHAR2 ) IS
        v_sql   VARCHAR2(2000);
    BEGIN
        v_sql   := 'drop directory ' || p_dir_name;
        EXECUTE IMMEDIATE ( v_sql ); 
        --EXECUTE IMMEDIATE 'drop directory "' || p_dir_name || '"';
    END;

    FUNCTION get_clob_from_file (
        p_directory_name   IN VARCHAR2,
        p_file_name        IN VARCHAR2
    ) RETURN CLOB AS
        l_bfile         BFILE;
        l_returnvalue   CLOB;
    BEGIN
    
      /*
     
      Purpose:      Get clob from file
     
      Remarks:      
     
      Who     Date        Description
      ------  ----------  --------------------------------
      MBR     18.01.2011  Created
     
      */
        dbms_lob.createtemporary(l_returnvalue,false);
        l_bfile   := bfilename(p_directory_name,p_file_name);
        dbms_lob.fileopen(l_bfile,dbms_lob.file_readonly);
        dbms_lob.loadfromfile(
            l_returnvalue,
            l_bfile,
            dbms_lob.getlength(l_bfile)
        );
        dbms_lob.fileclose(l_bfile);
        RETURN l_returnvalue;
    EXCEPTION
        WHEN OTHERS THEN
            IF
                dbms_lob.fileisopen(l_bfile) = 1
            THEN
                dbms_lob.fileclose(l_bfile);
            END IF;

            dbms_lob.freetemporary(l_returnvalue);
            RAISE;
    END get_clob_from_file;

    FUNCTION read_file_to_clob (
        p_dir_name    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) RETURN CLOB IS

        l_bfile      BFILE;
        l_clob       CLOB := empty_clob ();
        l_clob1      CLOB;
        l_wrn        INT;
        l_src_off    INT := 1;
        l_dest_off   INT := 1;
        l_lang_ctx   INT := 0;
    BEGIN
        l_bfile   := bfilename(p_dir_name,p_file_name);
        dbms_lob.fileopen(l_bfile,dbms_lob.file_readonly);
        IF
            dbms_lob.getlength(l_bfile) > 0
        THEN
            dbms_lob.createtemporary(l_clob,true);
            dbms_lob.loadclobfromfile(
                l_clob,
                l_bfile,
                dbms_lob.getlength(l_bfile),
                l_src_off,
                l_dest_off,
                0,
                l_lang_ctx,
                l_wrn
            );

            l_clob1   := l_clob;
            dbms_lob.freetemporary(l_clob);
        END IF;

        dbms_lob.fileclose(l_bfile);
        RETURN l_clob1;
    END read_file_to_clob;

    FUNCTION read_file_to_clob2 (
        p_dir_path    IN VARCHAR2,
        p_file_name   IN VARCHAR2
    ) RETURN CLOB IS
        l_clob1       CLOB;
        v_dir_name    VARCHAR2(128);
        v_dir_name1   VARCHAR2(128);
    BEGIN
        v_dir_name    := oac$file_utl.get_ora_dirname(p_dir_path);
        IF
            v_dir_name IS NOT NULL
        THEN
            l_clob1   := read_file_to_clob(v_dir_name,p_file_name);
        ELSE
            BEGIN
                v_dir_name1   := create_ora_dir(p_dir_path);
                l_clob1       := read_file_to_clob(v_dir_name1,p_file_name);
                drop_ora_dir(v_dir_name1);
            EXCEPTION
                WHEN OTHERS THEN
                    drop_ora_dir(v_dir_name1);
                    dbms_output.put_line('Error inside read_file_to_clob2 ' || sqlerrm);
            END;
        END IF;

        RETURN l_clob1;
    END read_file_to_clob2;

    PROCEDURE get_file_attr (
        p_dir_name      IN VARCHAR2,
        p_file_name     IN VARCHAR2,
        p_exists        OUT BOOLEAN,
        p_file_length   OUT NUMBER,
        p_blocksize     OUT NUMBER
    )
        IS
    BEGIN
        utl_file.fgetattr(
            p_dir_name,
            p_file_name,
            p_exists,
            p_file_length,
            p_blocksize
        );
    END get_file_attr;

      ----------------------------------------------------------

    PROCEDURE get_path (
        p_file   IN VARCHAR2,
        p_path   OUT VARCHAR2
    ) IS
        v_file   utl_file.file_type;
    BEGIN
        v_file   := utl_file.fopen(g_default_dir,p_file,'r');
        utl_file.get_line(v_file,p_path);
        utl_file.fclose(v_file);
    END get_path;
 
      ----------------------------------------------------------

    PROCEDURE set_location ( p_file IN VARCHAR2 ) IS
        PRAGMA autonomous_transaction;
    BEGIN
        EXECUTE IMMEDIATE 'ALTER TABLE v_app_files LOCATION (''' || p_file || ''')';
    END set_location;

    FUNCTION list_files ( p_directory_file IN VARCHAR2 ) RETURN file_listing_ntt
        PIPELINED
    IS
        v_path   VARCHAR2(1000);
    BEGIN
 
      /* Read the path from the directory file... */
        get_path(p_directory_file,v_path);
 
      /* Prepare the external table... */
        set_location(p_directory_file);
 
      /* Read the file listing... */
        FOR r_files IN (
            SELECT
                *
            FROM v_app_files --v_app_files
        ) LOOP
            PIPE ROW ( file_listing_ot(
                v_path,
                r_files.file_name,
                r_files.last_modified,--file_time
                r_files.size_bytes
            ) );  --file_size
        END LOOP;

        return;
    END list_files;

    PROCEDURE populate_rest_logs_tbl (
        p_directory_file   IN VARCHAR2,
        p_ref_tbl_name     IN VARCHAR2
    )
        IS
    BEGIN
    --oac$file_utl.get_ora_dirname(file_path) ora_dir 
        MERGE INTO v_ansible_rest_logs a USING
            ( SELECT
                file_path,
                file_name,
                file_time,
                file_size
            FROM TABLE ( list_files(p_directory_file) )
            WHERE
                file_name LIKE ( '%.%' )
            )
        b ON (
                a.file_name = b.file_name
            AND a.file_path = b.file_path
            AND a.file_time = b.file_time
            AND a.file_size = b.file_size
        ) WHEN NOT MATCHED THEN INSERT ( file_path,file_name,file_size,file_time,status,ref_tbl_name ) VALUES ( b.file_path,b.file_name,b.file_size,
b.file_time,'I',p_ref_tbl_name );

    END;

    PROCEDURE fetch_host_inv_files
        IS
    BEGIN
        populate_rest_logs_tbl(g_host_inv_file,g_host_inv_tbl);
    END;

    PROCEDURE fetch_dbchecklist_files
        IS
    BEGIN
        populate_rest_logs_tbl(g_db_check_list_file,g_db_check_list_tbl);
    END;
    
    PROCEDURE fetch_db_inv_files
        IS
    BEGIN
        populate_rest_logs_tbl(g_db_inv_file,g_db_inv_tbl);
    END;    
    
    PROCEDURE fetch_process_status_files
        IS
    BEGIN
        populate_rest_logs_tbl(g_process_status_file,g_process_status_tbl);
    END;        
END oac$file_utl;

/
--------------------------------------------------------
--  DDL for Package Body SETUP_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."SETUP_MGR" as
    -------------------------------------------------------------------------
    -- Generates a unique Identifier
    -------------------------------------------------------------------------
    function gen_id
        return number
    is
        l_id  number;
    begin
        select to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
          into l_id
          from dual;
        return l_id;
    end gen_id;
    -------------------------------------------------------------------------
    -- Gets the current user's authorization level. Depends on the following:
    --  * If access control is currently disabled, returns highest level of 3.
    --  * If access control is enabled, but user is not in list, returns 0
    --  * If access control is enabled and user is in list, returns their
    --    access level.
    -------------------------------------------------------------------------
    function get_authorization_level (
        p_username             varchar2)
        return number
    is
     --   l_access_level_id       number := 0;  -- default to lowest privilege.
        l_access_level_id       number := 1;  -- default to lowest privilege.
        l_account_locked        varchar2(255);
    begin
            -- Query for user's access level, throws no_data_found if no user
            select  max(
            case
             when nvl(p.APP_ADMIN,'N') = 'Y' then
              4
             when nvl(p.APP_ROLE,'N') = 'DBA' then
              3
             else
              2
             end 
            ),
                   max('N')
              into l_access_level_id
                   ,l_account_locked
              from v_app_person p
             where upper(p.username) = upper(p_username)
             and nvl(v('APP_ID'),'BATCH') like p.APP_ID ;
          if l_access_level_id is null then
            l_access_level_id := 1;
          end if;
        return l_access_level_id;
    exception
        when no_data_found then
                return 1;
    end get_authorization_level;

    function is_internal_admin
      return boolean
    is
      v_admin_list varchar2(1000) := 'JMITCHELL:MPERRY:GURI:JRAULJI_DEV:HARPREET:JAY'; --'JMITCHELL:MPERRY:GURI:JRAULJI_DEV:HARPREET:JAY';
    begin

      for i in (select 1 from dual 
                    where exists 
                      ( select 1 from 
                         table( apex_string.split(v_admin_list,':') ) 
                         where COLUMN_VALUE = V('APP_USER')
                     ))
      loop
          return true;
      end loop;
      return false;
    exception
    when others then
      return false;
    end is_internal_admin;


end SETUP_MGR;

/
--------------------------------------------------------
--  DDL for Package Body SIMPLE_CRYPTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."SIMPLE_CRYPTO" 

AS

     encryption_type    PLS_INTEGER := DBMS_CRYPTO.ENCRYPT_DES

                                     + DBMS_CRYPTO.CHAIN_CBC

                                     + DBMS_CRYPTO.PAD_PKCS5;

     encryption_key     RAW (32) := UTL_RAW.cast_to_raw('0111SAFC');



     -- The encryption key should be 8 bytes or more for DES algorithm. Here I used MESSYKICKGOAL as encrypted key



     FUNCTION encrypt (p_plainText VARCHAR2) RETURN RAW DETERMINISTIC

     IS

        encrypted_raw      RAW (2000);

     BEGIN

        encrypted_raw := DBMS_CRYPTO.ENCRYPT

        (

           src => UTL_RAW.CAST_TO_RAW (p_plainText),

           typ => encryption_type,

           key => encryption_key

        );

       RETURN encrypted_raw;

     END encrypt;

     FUNCTION decrypt (p_encryptedText RAW) RETURN VARCHAR2 DETERMINISTIC

     IS

        decrypted_raw      RAW (2000);

     BEGIN

        decrypted_raw := DBMS_CRYPTO.DECRYPT

        (

            src => p_encryptedText,

            typ => encryption_type,

            key => encryption_key

        );

        RETURN (UTL_RAW.CAST_TO_VARCHAR2 (decrypted_raw));

     END decrypt;

END;

/
--------------------------------------------------------
--  DDL for Package Body STANDARD_TASK_MGR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."STANDARD_TASK_MGR" AS


procedure task_queue(
        p_action   IN VARCHAR2 DEFAULT 'CHECK_SCHEDULE',
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
)
as
Begin
  null;
  If p_action = 'CHECK_SCHEDULE' then
  
   null;
   
    for s1 in (
    
    SELECT
    schedule_id,
    schedule_type,
    schedule_process,
    task_id,
    approval_process_id,
    approval_required,
    ticket_ref,
    unique_grp,
    req_queue_id,
    self_service_request_id,
    host_name,
    task_parms,
    request_start_time_c,
    request_start_time,
    process_start_time,
    status,
    created,
    created_by,
    updated,
    updated_by
FROM
    v_schedule_queue
    where
    status = 'OPEN'
    and nvl(request_start_time,sysdate) <= sysdate
    
    ) loop
    
      null;
     dbms_output.put_line('Executing: '||s1.schedule_process );
     dbms_output.put_line('created_by: '||s1.created_by );
     dbms_output.put_line('To Be run After: '||s1.request_start_time_c );
     
     run_tower_task(p_schedule_id => s1.schedule_id);
     
     
       
    update v_schedule_queue d
     set  d.status = 'CLOSED'
    where
      d.schedule_id = s1.schedule_id;
  
     
    end loop;
    
    
    
  end if;
  
End;


  procedure         run_tower_task (   p_schedule_id in number
                                    /* , p_job_id out number,
                                      p_self_service_id out number 
                                     */ 
                                    ) AS
                                    
 p_job_id  number ;
p_self_service_id NUMBER;
v_request_queue_id NUMBER;
v_param_json    clob;
v_response      clob;
v_job_id        number;
v_request_type  varchar2(50) := 'PROVISIONING';
--v_request_type  varchar2(50) := 'PATCHING';
--v_job_name      varchar2(50):= 'Grid-PSU-apply';

v_job_name      varchar2(50):= 'standalone-install';
v_job_name_tower      varchar2(255);

--v_endpoint      varchar2(100) := concat(concat(concat(g_endpoint_prefix,g_playbook_template), v_job_name), '/');
v_workflow_id   number ;--:= get_id(g_playbook,v_job_name) ;
l_hosts_a APEX_APPLICATION_GLOBAL.VC_ARR2;
l_host_id number; -- tower host id
l_group_id number; -- tower group id
l_group_name varchar2(255) ;
l_host_code varchar2(255);
l_unq_grp varchar2(255) := to_char(sysdate,'HH24_MI_SS');
c_RESPONSE clob; -- Tower host and group reponse           
  BEGIN
    -- Templates in V_ANSIBLE_TEMPLATE_STORE
 --mssql-cluster-install-withDB
 --mssql-standalone-install-withDB

 -- Setup for Inventory
 oac$ansible_rest_utl.config('INIT');
 dbms_output.put_line('After Init');
 g_tower_domain :=  oac$ansible_rest_utl.g_tower_domain;
 g_default_inventory_id := oac$ansible_rest_utl.g_default_inventory_id;
 --g_default_inventory_id := 26;
 dbms_output.put_line('Inventory: '||g_default_inventory_id);
    --
    --  Get a list of the tower tasks that need to be 
    --  run for the schedule
    --
        FOR c1 IN (
        SELECT
    q.schedule_detail_id,
    q.schedule_id,
    q.task_id,
    q.step_id,
    q.template_type,
    q.template_name,
    q.job_name,
    q.job_no,
    q.ticket_ref,
    q.unique_grp,
    q.extra_vars,
    q.host_name,
    q.task_parms,
    q.process_start_time,
    q.status,
    q.template_id,
    s.schedule_process,
    case
     when t.privilege_role like 'ORACLE%' then
      'ORACLE-'||replace(s.schedule_process,' ')
     when t.privilege_role like 'OPEN%' then
      'OPEN-'||replace(s.schedule_process,' ') 
     when t.privilege_role like 'MS%' then
      'MSSQL-'||replace(s.schedule_process,' ') 
    else
      'OP-'||replace(s.schedule_process,' ')
    end request_type 
FROM
    v_schedule_queue_detail q
    ,v_schedule_queue s
    ,v_schedule_task t
    WHERE
    q.schedule_id = p_schedule_id
    and q.schedule_id = s.schedule_id
    and s.task_id = t.task_id
    
    --Only Exec if Open Status and Playbook or Workflow
    and q.status = 'OPEN'
    and q.template_type in ('P','W')
        ) LOOP

 
     INSERT INTO v_request_queue (   
      template_type,
      template_name,
      job_name,
      request_type,
      ticket_ref,
      status,
      extra_vars,
     HOST_NAME
     ) VALUES (
      c1.template_type,
      c1.template_name,
      c1.job_name,
      c1.schedule_process,
      c1.ticket_ref,
      'E',
      c1.extra_vars,
      c1.host_name
    ) RETURNING ID INTO v_request_queue_id;


      v_job_name := c1.job_name;
      v_request_type := c1.request_type;
      --
      -- Set the group to the Cluster name or to the Ticket_ref
      --
       l_group_name :=  c1.unique_grp ;
  --
 -- Check the group to see if it exists
            SELECT
                oac$ansible_rest_utl.get_group_id(l_group_name)
            INTO l_group_id
            FROM
                dual;

            IF l_group_id IS NULL THEN
  -- Add a group
                oac$ansible_rest_utl.add_group(p_inventory_id => g_default_inventory_id , p_group_name => l_group_name, p_response => c_response);
                SELECT
                    oac$ansible_rest_utl.get_group_id(l_group_name)
                INTO l_group_id
                FROM
                    dual;

            ELSE
  --group does exists Hmmm add a diff group?
                NULL;
            END IF;
-- DBMS_OUTPUT.PUT_LINE ('The group id ' ||l_group_id);
 --
 -- Passed in value from the select list could be multiple hosts

            l_hosts_a := apex_util.string_to_table(replace(c1.host_name,',',':'));
  -- Loop thru the passed in list of hosts
            FOR i IN 1..l_hosts_a.count LOOP
                SELECT
 --                   oac$ansible_rest_utl.get_host_id(l_hosts_a(i)
 --                                                    || g_tower_domain)
                    oac$ansible_rest_utl.get_host_id(l_hosts_a(i))


                INTO l_host_id
                FROM
                    dual;

                IF l_host_id IS NULL THEN
                    oac$ansible_rest_utl.add_host(p_host_name => l_hosts_a(i), p_response => c_response);
                    SELECT
                        oac$ansible_rest_utl.get_host_id(l_hosts_a(i))
                                                    --     || g_tower_domain)
                    INTO l_host_id
                    FROM
                        dual;

                END IF;
     --Add the Host to the group  
   --  DBMS_OUTPUT.PUT_LINE (l_hosts_a(i)||g_tower_domain||' - The host id ' ||l_host_id);

                oac$ansible_rest_utl.create_host_to_group(p_inventory_id => g_default_inventory_id, p_group_id => l_group_id,
                p_host_name => l_hosts_a

                (i), p_host_description => l_hosts_a(i), p_enabled => NULL, p_instance_id => l_host_id, p_variables => NULL, p_response

                => c_response);
    /*  add_host_to_group (  P_GROUP_ID => l_GROUP_ID,
       P_HOST_ID => l_HOST_ID,
       P_RESPONSE => c_RESPONSE) ;  */

            END LOOP;
    -- Loookup ID from V_ANSIBLE_TEMPLATE_STORE
    --mssql-cluster-install-withDB
    --mssql-standalone-install-withDB


     v_workflow_id := c1.template_id;
     v_param_json := c1.extra_vars||', "TowerPath": "/ansible"';
      --
      --  Pass back the extra vars to update the request
      --
      v_param_json := replace(v_param_json,chr(10));      

  -- Setting Ask variable true.
    begin
    v_job_name_tower := oac$ansible_rest_utl.get_name(c1.template_type,v_workflow_id);
    oac$ansible_rest_utl.set_ask_variable(oac$ansible_rest_utl.g_endpoint_prefix|| case when c1.template_type = 'W' then g_workflow_template else g_playbook_template end || v_workflow_id ||'/',v_job_name_tower,'true');
    exception
    when others then
     null;
    end; 

    -- make a rest call.

            oac$ansible_rest_utl.make_rest_call(p_flag => c1.template_type, p_id => v_workflow_id, p_param_json => v_param_json, p_response
            => v_response);

            dbms_output.put_line('v_response: ' || v_response);    

   -- parse and store response
            oac$ansible_rest_utl.parse_and_store_resp(p_request_type => v_request_type, p_job_name => v_job_name, p_ticket_ref =>
            c1.ticket_ref, p_target_name => c1.host_name, p_resp_clob => v_response, p_id => v_job_id, p_request_id => p_self_service_id
            );

            dbms_output.put_line('v_job_id: ' || v_job_id);
            dbms_output.put_line('p_schedule_id: ' || p_schedule_id);


        p_job_id := v_job_id;

     --
     --  Need the group its not passed back so update the record
     --

     --
     -- Complete the references on the various tables
     --   
        update  v_request_queue q
          set q.group_id = l_group_id
            WHERE
          q.id = v_request_queue_id;

        update V_SELF_SERVICE_STATUS s   
         set s.req_queue_id = v_request_queue_id
        where s.request_id =  p_self_service_id;
    
    update v_schedule_queue_detail d
     set REQ_QUEUE_ID = v_request_queue_id, 
	    SELF_SERVICE_REQUEST_ID = p_self_service_id ,
        GROUP_ID = l_group_id,
        JOB_NO = v_job_id ,
        STATUS = 'CLOSED'
    where
      d.schedule_detail_id = c1.schedule_detail_id;
      
    update v_schedule_queue d
     set  d.process_start_time = sysdate
    where
      d.schedule_id = c1.schedule_id;
  
END LOOP;

  END run_tower_task;


  procedure save_task(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) AS
 l_SCHEDULE_ID number;
 c number := 1;
 l_extra_vars varchar2(32000);
  BEGIN
    --  Get the Globals Setup from the Page Values
    set_globals(p_page => p_page,p_task_key =>p_task_key, p_task_id =>p_task_id, p_parm1 => p_parm1  );
    for c1 in (
    SELECT
    t.task_id,
    t.task_name,
    t.task_icon,
    t.task_type,
    t.execution_mode,
    t.description,
    t.privilege_role,
    t.approval_process_id,
    t.approval_required,
    t.job_name,
    t.show_database,
    t.show_db_home,
    t.show_dc_location,
    t.show_app_id,
    t.show_project,
    t.show_db_config,
    t.show_cluster,
    t.show_db_version,
    t.show_grid_version,
    t.show_domain,
    t.show_environment,
    t.show_schedule,
    s.step_id, 
    s.step_name,
    s.step_type,
    s.template_type,
    s.template_name,
    s.template_id,
    s.extra_vars,
    s.step_seq
FROM
    v_schedule_task t
    ,v_schedule_task_step s
   where
  -- t.task_id = G_TASK_ID
  t.task_key = G_TASK_KEY
  and t.task_id = s.task_id 
  and s.step_type = 'TOWER_TEMPLATE'
  order by s.step_seq
  )  loop 
 -- our loop gets both header and detail info about the task
 -- so we only insert the header record the first time thru the loop
 if c = 1 then 
    INSERT INTO  v_schedule_queue (
    schedule_type,
    schedule_process,
    task_id,
    approval_process_id,
    approval_required,
    ticket_ref,
    unique_grp,
  --  req_queue_id,
  --  self_service_request_id,
    host_name,
    task_parms,
    request_start_time,
   request_start_time_c,
    status
) VALUES (
    'ONLINE',
    c1.task_name,
    c1.task_id,
    c1.approval_process_id,
    c1.approval_required,
    G_ticket_ref,
    g_unique_grp,
    g_host_list,
    g_parm_list,
  to_date(G_EXECUTE_ON,'DD-MON-YYYY HH24:MI') ,
  G_EXECUTE_ON,
    'OPEN'
) returning schedule_id into l_schedule_id ;

 end if; 
    NULL;
   --
   -- Parse in the values from the Task into the place holders in the extra vars
   -- we loop thru all hthe parms in the task and replce &PARM& string with 
   --what was supplied in the call
   l_extra_vars := g_extra_var||
           '"execute_on": "'||G_EXECUTE_ON|| '",'||
           '"standard_task_id": "'||l_schedule_id|| '"'          
           
;
--   l_extra_vars := g_extra_var||
--           '"execute_on": "'||G_EXECUTE_ON|| '"'
--         ;  


   INSERT INTO v_schedule_queue_detail (
    schedule_id,
    task_id,
    step_id,
    template_type,
    template_id,
    template_name,
    job_name,
    ticket_ref,
    unique_grp,
    extra_vars,
    host_name,
    task_parms,
    status
) VALUES (
    l_schedule_id,
    c1.task_id,
    c1.step_id,
    c1.template_type,
    c1.template_id,
    c1.template_name,
    c1.job_name,
    g_ticket_ref,
    g_unique_grp,
    l_extra_vars,
    G_HOST_LIST,
    G_PARM_LIST,
    'OPEN'
);

--  if nvl(c1.show_schedule,'NO') = 'NO' then
  --   run_tower_task( p_schedule_id => l_schedule_id);
--  end if;
 end loop; 
 --
 -- Check to see if the task we just saved needs to be executed
 --
   task_queue( p_action => 'CHECK_SCHEDULE');
  if p_action = 'LICENSE_DISCOVERY' then
    --update the 
    update v_lic_discovery_schedule s
    set     current_schedule_id = l_schedule_id
    where
    lic_schedule_id = p_parm1;
  end if;
  END save_task;

procedure set_globals(
        p_action   IN VARCHAR2 DEFAULT NULL,
        p_page   IN VARCHAR2 DEFAULT NULL,
        p_task_key IN VARCHAR2 DEFAULT NULL,
        p_task_id IN VARCHAR2 DEFAULT NULL,
        p_parm1 IN VARCHAR2 DEFAULT NULL,
        p_debug IN VARCHAR2 DEFAULT 'N'
) as

G_PROJECT_ID varchar2(255);
G_APP_ID varchar2(255);
G_DC_LOCATION varchar2(255);
G_ENVIRONMENT varchar2(255);
G_DOMAIN varchar2(255); 
G_DATABASE_NAME varchar2(255);
G_CLUSTER varchar2(255);
G_DB_VERSION varchar2(255);
G_GRID_VERSION varchar2(255);
G_DB_HOME varchar2(255);
TASK_PARM1 varchar2(1000);
TASK_PARM2 varchar2(1000);
TASK_PARM3 varchar2(1000);
TASK_PARM4 varchar2(1000);
TASK_PARM5 varchar2(1000);
TASK_PARM6 varchar2(1000);
TASK_PARM7 varchar2(1000);
TASK_PARM8 varchar2(1000);
TASK_PARM9 varchar2(1000);
TASK_NAME_PARM1 varchar2(1000);
TASK_NAME_PARM2 varchar2(1000);
TASK_NAME_PARM3 varchar2(1000);
TASK_NAME_PARM4 varchar2(1000);
TASK_NAME_PARM5 varchar2(1000);
TASK_NAME_PARM6 varchar2(1000);
TASK_NAME_PARM7 varchar2(1000);
TASK_NAME_PARM8 varchar2(1000);
TASK_NAME_PARM9 varchar2(1000);

l_extra_vars varchar2(32000);
begin

select listagg(trim(c001), ',') within group (order by 1) into G_HOST_LIST from apex_collections where collection_name ='HOST_NAME_COLLECTION';


if nvl(p_page,'850') = '850' then
--Globals
null;
G_TASK_ID := v('P850_TASK_ID');
G_TASK_KEY := v('P850_TASK_KEY');


G_EXECUTE_ON := v('P850_EXECUTE_ON');
G_TICKET_REF := v('P850_TICKET_REF');
G_PROJECT_ID := v('P850_PROJECT_ID');
G_APP_ID := v('P850_APP_ID');
G_DC_LOCATION := v('P850_DC_LOCATION');
G_ENVIRONMENT := v('P850_ENVIRONMENT');
G_DOMAIN := v('P850_DOMAIN'); 
G_CLUSTER := v('P850_DOMAIN'); 
G_DATABASE_NAME := v('P850_DATABASE_NAME');
G_DB_VERSION := v('P850_DB_VERSION');
G_GRID_VERSION := v('P850_GRID_VERSION');
G_DB_HOME := v('P850_DB_HOME');

--
-- FOr each Parms there is a potential for test select or pop up, we use coalesce to filter the non-null entry
--
TASK_PARM1 := coalesce(v('P850_PARM1_T'),v('P850_PARM1_S'),v('P850_PARM1_P'));
TASK_PARM2 := coalesce(v('P850_PARM2_T'),v('P850_PARM2_S'),v('P850_PARM2_P'));
TASK_PARM3 := coalesce(v('P850_PARM3_T'),v('P850_PARM3_S'),v('P850_PARM3_P'));
TASK_PARM4 := v('P850_');
TASK_PARM5 := v('P850_');
TASK_PARM6 := v('P850_');
TASK_PARM7 := v('P850_');
TASK_PARM8 := v('P850_');
TASK_PARM9 := v('P850_');
TASK_NAME_PARM1 := v('P850_PARM1_NAME');
TASK_NAME_PARM2 := v('P850_PARM2_NAME');
TASK_NAME_PARM3 := v('P850_PARM3_NAME');
TASK_NAME_PARM4 := v('P850_');
TASK_NAME_PARM5 := v('P850_');
TASK_NAME_PARM6 := v('P850_');
TASK_NAME_PARM7 := v('P850_');
TASK_NAME_PARM8 := v('P850_');
TASK_NAME_PARM9 := v('P850_');

--Setup a json object with the parms and there values
G_PARM_LIST := '['||
--Row Parm 1
'{"parm_name" : "'||TASK_NAME_PARM1||'", "parm_value" : "'|| TASK_PARM1||'"},'||
'{"parm_name" : "'||TASK_NAME_PARM2||'", "parm_value" : "'|| TASK_PARM2||'"},'||
'{"parm_name" : "'||TASK_NAME_PARM3||'", "parm_value" : "'|| TASK_PARM3||'"}'||
']';


    g_unique_grp := g_ticket_ref||'-'||to_char(sysdate,'HH24-MI-SS');


  for c1 in (
    SELECT
    t.task_id,
    t.task_name,
    t.task_icon,
    t.task_type,
    t.execution_mode,
    t.description,
    t.privilege_role,
    t.approval_process_id,
    t.approval_required,
    t.job_name,
    t.show_database,
    t.show_db_home,
    t.show_dc_location,
    t.show_app_id,
    t.show_project,
    t.show_db_config,
    t.show_cluster,
    t.show_db_version,
    t.show_grid_version,
    t.show_domain,
    t.show_environment,
    s.step_id, 
    s.step_name,
    s.step_type,
    s.template_type,
    s.template_name,
    s.template_id,
    s.extra_vars,
    s.step_seq
FROM
    v_schedule_task t
    ,v_schedule_task_step s
   where
  -- t.task_id = G_TASK_ID
  t.task_key = G_TASK_KEY
  and t.task_id = s.task_id 
 -- and s.template_type = 'TOWER_TEMPLATE'
  order by s.step_seq
  )  loop 
 -- our loop gets both header and detail info about the task
 -- so we only insert the header record the first time thru the loop
    NULL;
   --
   -- Parse in the values from the Task into the place holders in the extra vars
   -- we loop thru all hthe parms in the task and replce &PARM& string with 
   --what was supplied in the call
   l_extra_vars := c1.extra_vars;
 for p1 in (   
    SELECT
    tp.task_parms,
    x.parm_name,
    x.parm_value,
    tp.parm_var,
    tp.parse_key
    FROM
    (
        SELECT
            G_PARM_LIST task_parms,
            p.parm_name,
            p.parm_var,
            '&'||p.parm_var||'&' parse_key
        FROM
            v_schedule_task_parms p
        WHERE
            p.task_id = c1.task_id
    ) tp,
    XMLTABLE (
                --'/json/items/row'
     '/json/row' PASSING apex_json.to_xmltype(tp.task_parms) COLUMNS parm_name VARCHAR2(255) PATH 'parm_name', parm_value VARCHAR2(1000
    ) PATH 'parm_value' ) x
    WHERE
    tp.parm_name = x.parm_name (+)  
    )  loop  
    
    l_extra_vars := replace(l_extra_vars,p1.parse_key,p1.parm_value);
    end loop;
     l_extra_vars := replace(l_extra_vars,chr(10));  
     l_extra_vars := replace(l_extra_vars,chr(13));  
   -- template we setup in the tasks defnition
   l_extra_vars := l_extra_vars ||
   	    '"host": "'       || g_unique_grp || '",'||
        '"ticket_ref": "'|| g_ticket_ref || '",'||
        '"unique_grp": "'|| g_unique_grp || '",'||
/*        '"task_area": "'||c1.job_name||'",'||
        '"task_key": "'||g_host_list||'",'||
        '"task_status": "IN-PROGESS",'||
        '"task_message": "Starting Task",'||*/
case when c1.show_db_home = 'YES' then '"db_home":'||'"'||G_DB_HOME||'",' else null  end||
case when c1.show_db_home = 'YES' then '"oracle_db_home":'||'"'||G_DB_HOME||'",' else null  end||
case when c1.show_dc_location = 'YES' then '"dc":'||'"'||G_DC_LOCATION||'",' else null  end||
case when c1.show_database = 'YES' then '"database":'||'"'||G_database_name||'",' else null  end||
case when c1.show_database = 'YES' then '"oracle_db_name":'||'"'||G_database_name||'",' else null  end||
case when c1.show_project = 'YES' then '"project_id":'||'"'||G_project_id||'",' else null  end||
case when c1.show_db_version = 'YES' then '"oracle_version":'||'"'||G_DB_VERSION||'",' else null  end||
case when c1.show_grid_version = 'YES' then '"grid_version":'||'"'||G_GRID_VERSION||'",' else null  end||
case when c1.show_cluster = 'YES' then '"cluster":'||'"'||G_CLUSTER||'",' else null  end||
case when c1.show_domain = 'YES' then '"domain":'||'"'||G_DOMAIN||'",' else null  end||
case when c1.show_environment = 'YES' then '"env":'||'"'||G_ENVIRONMENT||'",' else null  end||
case when c1.show_app_id = 'YES' then '"app_id":'||'"'||G_APP_ID||'",' else null  end

        ;		
       /* 
     Not done yet  
    t.show_db_config,
   
   */


end loop;

G_EXTRA_VAR := l_extra_vars;

elsif nvl(p_page,'26') = '26' then
--Globals
null;
--
-- Task for Provision OPen Source DB

SELECT TASK_ID, TASK_KEY INTO 
G_TASK_ID 
,G_TASK_KEY
FROM
V_SCHEDULE_TASK
where
task_key = P_TASK_KEY;

G_EXECUTE_ON := to_char(sysdate ,'DD-MON-YYYY HH24:MI');
G_TICKET_REF := v('P26_TICKET_REF');
G_PROJECT_ID := v('P26_PROJECT_ID');
G_APP_ID := v('P26_APP_ID');
G_DC_LOCATION := v('P26_DC_LOCATION');
G_ENVIRONMENT := v('P26_ENVIRONMENT');
G_DOMAIN := v('P26_DOMAIN'); 
G_DATABASE_NAME := v('P26_DATABASE_NAME');
--G_GRID_VERSION := v('P850_GRID_VERSION');
--G_DB_HOME := v('P850_DB_HOME');

--
-- FOr each Parms there is a potential for test select or pop up, we use coalesce to filter the non-null entry
--
TASK_PARM1 := v('P26_DATABASE_VENDOR');
TASK_PARM2 := v('P26_DATABASE_VERSION');
TASK_PARM3 := v('P26_DATABASE_ENGINE');
TASK_NAME_PARM1 := 'Database Vendor';
TASK_NAME_PARM2 := 'Database Version';
TASK_NAME_PARM3 := 'Database Engine';

--Setup a json object with the parms and there values
G_PARM_LIST := '['||
--Row Parm 1
'{"parm_name" : "'||TASK_NAME_PARM1||'", "parm_value" : "'|| TASK_PARM1||'"},'||
'{"parm_name" : "'||TASK_NAME_PARM2||'", "parm_value" : "'|| TASK_PARM2||'"},'||
'{"parm_name" : "'||TASK_NAME_PARM3||'", "parm_value" : "'|| TASK_PARM3||'"}'||
']';



   g_unique_grp := g_ticket_ref||'-'||to_char(sysdate,'HH24-MI-SS');
   l_extra_vars := l_extra_vars ||
   	    '"host": "'       || g_unique_grp || '",'||
        '"ticket_ref": "'|| g_ticket_ref || '",'||
        '"unique_grp": "'|| g_unique_grp || '",'||
        p_parm1;

  l_extra_vars := replace(l_extra_vars,chr(10));  
  l_extra_vars := replace(l_extra_vars,chr(13)); 
     
  G_EXTRA_VAR := l_extra_vars;
elsif nvl(p_page,'26') = '2250' then
--Globals
null;
--
-- Task for Provision OPen Source DB

SELECT TASK_ID
, TASK_KEY 
INTO 
G_TASK_ID 
,G_TASK_KEY
FROM
V_SCHEDULE_TASK
where
task_key = 'LOAD_DB_FEATURE';

--
-- Have to get the host list from the saved record
--  We use License_mgr.check_schedule to reschedule which doesnt have the collection
--setup
SELECT
    replace(schedule_name,' ','-')||'-'||execute_interval,
    to_char(schedule_start_date,'DD-MON-RRRR HH24:MI'),
    host_name
    into
    G_TICKET_REF,
    G_EXECUTE_ON,
    G_HOST_LIST
  from v_lic_discovery_schedule 
 where lic_schedule_id = P_PARM1;



--G_GRID_VERSION := v('P850_GRID_VERSION');
--G_DB_HOME := v('P850_DB_HOME');

--
-- FOr each Parms there is a potential for test select or pop up, we use coalesce to filter the non-null entry
--

--Setup a json object with the parms and there values
G_PARM_LIST := '['||
--Row Parm 1
'{"parm_name" : "schedule_name", "parm_value" : "'|| G_TICKET_REF||'"}'||
']';



   g_unique_grp := g_ticket_ref||'-'||to_char(sysdate,'HH24-MI-SS');
   l_extra_vars := l_extra_vars ||
   	    '"host": "'       || g_unique_grp || '",'||
        '"ticket_ref": "'|| g_ticket_ref || '",'||
        '"unique_grp": "'|| g_unique_grp || '",'
        ;

  l_extra_vars := replace(l_extra_vars,chr(10));  
  l_extra_vars := replace(l_extra_vars,chr(13)); 
     
  G_EXTRA_VAR := l_extra_vars;
  
  
end if;


end;


END STANDARD_TASK_MGR;

/

  GRANT EXECUTE ON "CHARTER2_INV"."STANDARD_TASK_MGR" TO "OPENSOURCE_USER";
--------------------------------------------------------
--  DDL for Package Body STATUS_REST_UTL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."STATUS_REST_UTL" AS

    PROCEDURE checkliststatus_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_task_body          IN                   BLOB,--v_checklist_status.task_body%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS
        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);    
    BEGIN
        BEGIN            
            l_record_type := upper(p_record_type);
            if p_task_body is null then 
            l_task_body :=null;
            else
                l_blob := p_task_body;
                dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
                DBMS_LOB.converttoclob(
                dest_lob      => l_task_body,
                src_blob      => l_blob,
                amount        => DBMS_LOB.lobmaxsize,
                dest_offset   => l_dest_offset,
                src_offset    => l_src_offset, 
                blob_csid     => DBMS_LOB.default_csid,
                lang_context  => l_lang_context,
                warning       => l_warning);
    
                IF l_task_body LIKE '[{%' THEN
                    l_record_type := 'LOAD_JSON';
                END IF;
            end if;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;    
        INSERT INTO v_checklist_status (
            task_id,
            task_key,
            task_area,
            task_status,
            task_message,
            task_body,
            record_type,
            standard_task_id
        ) VALUES (
            p_task_id,
            p_task_key,
            p_task_area,
            p_task_status,
            p_task_message,
            l_task_body,--p_task_body,
            l_record_type,--upper(p_record_type),
            p_standard_task_id
        ) RETURNING status_id INTO p_status_id;

    END;

    PROCEDURE checkliststatus_file_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_file_upload        IN                   v_checklist_status.file_upload%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_file_mimetype      IN                   v_checklist_status.file_mimetype%TYPE,
        p_file_name          IN                   v_checklist_status.file_name%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS

        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);
    BEGIN
        BEGIN
            l_blob := p_file_upload;
            l_record_type := upper(p_record_type);
            dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
            DBMS_LOB.converttoclob(
            dest_lob      => l_task_body,
            src_blob      => l_blob,
            amount        => DBMS_LOB.lobmaxsize,
            dest_offset   => l_dest_offset,
            src_offset    => l_src_offset, 
            blob_csid     => DBMS_LOB.default_csid,
            lang_context  => l_lang_context,
            warning       => l_warning);

            IF l_task_body LIKE '[{%' THEN
                l_record_type := 'LOAD_JSON';
            END IF;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;
            INSERT INTO v_checklist_status (
                task_id,
                task_key,
                task_area,
                task_status,
                task_message,
                task_body,
                file_upload,
                record_type,
                file_mimetype,
                file_name,
                standard_task_id
            ) VALUES (
                p_task_id,
                p_task_key,
                p_task_area,
                p_task_status,
                p_task_message,
                l_task_body,
                l_blob,
                l_record_type,
                p_file_mimetype,
                p_file_name,
                p_standard_task_id
            ) RETURNING status_id INTO p_status_id;

    END;

    PROCEDURE process_status_ins (
        p_task_id            IN                   v_process_status.task_id%TYPE,
        p_task_key           IN                   v_process_status.task_key%TYPE,
        p_task_area          IN                   v_process_status.task_area%TYPE,
        p_task_status        IN                   v_process_status.task_status%TYPE,
        p_task_message       IN                   v_process_status.task_message%TYPE,
        p_task_body          IN                   BLOB,--v_process_status.task_body%TYPE,
        p_record_type        IN                   v_process_status.record_type%TYPE,
        p_standard_task_id   IN                   v_process_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS
        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);    
    BEGIN
        BEGIN
            l_blob := p_task_body;
            l_record_type := upper(p_record_type);
            dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
            DBMS_LOB.converttoclob(
            dest_lob      => l_task_body,
            src_blob      => l_blob,
            amount        => DBMS_LOB.lobmaxsize,
            dest_offset   => l_dest_offset,
            src_offset    => l_src_offset, 
            blob_csid     => DBMS_LOB.default_csid,
            lang_context  => l_lang_context,
            warning       => l_warning);

            IF l_task_body LIKE '[{%' THEN
                l_record_type := 'LOAD_JSON';
            END IF;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;
        
        INSERT INTO v_process_status (
            task_id,
            task_key,
            task_area,
            task_status,
            task_message,
            task_body,
            record_type,
            standard_task_id
        ) VALUES (
            p_task_id,
            p_task_key,
            p_task_area,
            p_task_status,
            p_task_message,
            l_task_body,--p_task_body,
            l_record_type,--upper(p_record_type),
            p_standard_task_id
        ) RETURNING status_id INTO p_status_id;

    END process_status_ins;
    
    PROCEDURE process_status_file_ins (
        p_task_id            IN                   v_process_status.task_id%TYPE,
        p_task_key           IN                   v_process_status.task_key%TYPE,
        p_task_area          IN                   v_process_status.task_area%TYPE,
        p_task_status        IN                   v_process_status.task_status%TYPE,
        p_task_message       IN                   v_process_status.task_message%TYPE,
        p_file_upload        IN                   v_process_status.file_upload%TYPE,
        p_record_type        IN                   v_process_status.record_type%TYPE,
        p_file_mimetype      IN                   v_process_status.file_mimetype%TYPE,
        p_file_name          IN                   v_process_status.file_name%TYPE,
        p_standard_task_id   IN                   v_process_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS

        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);
    BEGIN
        BEGIN
            l_blob := p_file_upload;
            l_record_type := upper(p_record_type);
            dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
            DBMS_LOB.converttoclob(
            dest_lob      => l_task_body,
            src_blob      => l_blob,
            amount        => DBMS_LOB.lobmaxsize,
            dest_offset   => l_dest_offset,
            src_offset    => l_src_offset, 
            blob_csid     => DBMS_LOB.default_csid,
            lang_context  => l_lang_context,
            warning       => l_warning);

            IF l_task_body LIKE '[{%' THEN
                l_record_type := 'LOAD_JSON';
            END IF;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;
            INSERT INTO v_process_status (
                task_id,
                task_key,
                task_area,
                task_status,
                task_message,
                task_body,
                file_upload,
                record_type,
                file_mimetype,
                file_name,
                standard_task_id
            ) VALUES (
                p_task_id,
                p_task_key,
                p_task_area,
                p_task_status,
                p_task_message,
                l_task_body,
                l_blob,
                l_record_type,
                p_file_mimetype,
                p_file_name,
                p_standard_task_id
            ) RETURNING status_id INTO p_status_id;

    END process_status_file_ins;


    PROCEDURE checkliststatus_sql_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_task_body          IN                   BLOB,--v_checklist_status.task_body%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS
        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);    
    BEGIN
        BEGIN            
            l_record_type := upper(p_record_type);
            if p_task_body is null then 
            l_task_body :=null;
            else
                l_blob := p_task_body;
                dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
                DBMS_LOB.converttoclob(
                dest_lob      => l_task_body,
                src_blob      => l_blob,
                amount        => DBMS_LOB.lobmaxsize,
                dest_offset   => l_dest_offset,
                src_offset    => l_src_offset, 
                blob_csid     => DBMS_LOB.default_csid,
                lang_context  => l_lang_context,
                warning       => l_warning);
    
                IF l_task_body LIKE '[{%' THEN
                    l_record_type := 'LOAD_JSON';
                END IF;
            end if;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;    
        INSERT INTO charter2_sql.v_checklist_status (
            task_id,
            task_key,
            task_area,
            task_status,
            task_message,
            task_body,
            record_type,
            standard_task_id
        ) VALUES (
            p_task_id,
            p_task_key,
            p_task_area,
            p_task_status,
            p_task_message,
            l_task_body,--p_task_body,
            l_record_type,--upper(p_record_type),
            p_standard_task_id
        ) RETURNING status_id INTO p_status_id;

    END;

    PROCEDURE checkliststatus_sql_file_ins (
        p_task_id            IN                   v_checklist_status.task_id%TYPE,
        p_task_key           IN                   v_checklist_status.task_key%TYPE,
        p_task_area          IN                   v_checklist_status.task_area%TYPE,
        p_task_status        IN                   v_checklist_status.task_status%TYPE,
        p_task_message       IN                   v_checklist_status.task_message%TYPE,
        p_file_upload        IN                   v_checklist_status.file_upload%TYPE,
        p_record_type        IN                   v_checklist_status.record_type%TYPE,
        p_file_mimetype      IN                   v_checklist_status.file_mimetype%TYPE,
        p_file_name          IN                   v_checklist_status.file_name%TYPE,
        p_standard_task_id   IN                   v_checklist_status.standard_task_id%TYPE,
        p_status_id          OUT                  NUMBER
    ) IS

        l_task_body      CLOB;
        l_blob           BLOB;
        l_dest_offset    PLS_INTEGER := 1;
        l_src_offset     PLS_INTEGER := 1;
        l_lang_context   PLS_INTEGER := dbms_lob.default_lang_ctx;
        l_warning        PLS_INTEGER;
        l_record_type    VARCHAR2(255);
    BEGIN
        BEGIN
            l_blob := p_file_upload;
            l_record_type := upper(p_record_type);
            dbms_lob.createtemporary(lob_loc => l_task_body, cache => true);
            DBMS_LOB.converttoclob(
            dest_lob      => l_task_body,
            src_blob      => l_blob,
            amount        => DBMS_LOB.lobmaxsize,
            dest_offset   => l_dest_offset,
            src_offset    => l_src_offset, 
            blob_csid     => DBMS_LOB.default_csid,
            lang_context  => l_lang_context,
            warning       => l_warning);

            IF l_task_body LIKE '[{%' THEN
                l_record_type := 'LOAD_JSON';
            END IF;
        EXCEPTION
        WHEN OTHERS THEN NULL;
        END;
            INSERT INTO charter2_sql.v_checklist_status (
                task_id,
                task_key,
                task_area,
                task_status,
                task_message,
                task_body,
                file_upload,
                record_type,
                file_mimetype,
                file_name,
                standard_task_id
            ) VALUES (
                p_task_id,
                p_task_key,
                p_task_area,
                p_task_status,
                p_task_message,
                l_task_body,
                l_blob,
                l_record_type,
                p_file_mimetype,
                p_file_name,
                p_standard_task_id
            ) RETURNING status_id INTO p_status_id;

    END;


    
END status_rest_utl;

/
--------------------------------------------------------
--  DDL for Package Body V_APPLICATION_DETAILS_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL_API" 
is

    procedure get_row (
        p_id                           in number,
        P_application_name             out varchar2,
        P_business_unit                out varchar2,
        P_technical_contact            out varchar2,
        P_tech_contact_email           out varchar2,
        P_app_desc                     out varchar2,
        P_app_owner                    out varchar2,
        P_app_owner_email              out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_ref_app_id                   out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_application_details_tbl where id = p_id) loop
            p_application_name := c1.application_name;
            p_business_unit := c1.business_unit;
            p_technical_contact := c1.technical_contact;
            p_tech_contact_email := c1.tech_contact_email;
            p_app_desc := c1.app_desc;
            p_app_owner := c1.app_owner;
            p_app_owner_email := c1.app_owner_email;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
            p_ref_app_id := c1.ref_app_id;
        end loop;
    end get_row;


    procedure insert_row  (
        p_id                           out number ,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in  varchar2 default null
    )
    is
    begin
        insert into charter2_inv.v_application_details_tbl (
           -- id,                   -- We need to populate it using trigger.
            application_name,
            business_unit,
            technical_contact,
            tech_contact_email,
            app_desc,
            app_owner,
            app_owner_email,
            ref_app_id
        ) values (
          --  p_id,                 -- We need to populate it using trigger.
            p_application_name,
            p_business_unit,
            p_technical_contact,
            p_tech_contact_email,
            p_app_desc,
            p_app_owner,
            p_app_owner_email,
            p_ref_app_id
        ) returning id into p_id;
    end insert_row;

    procedure update_row  (
        p_id                           in number default null,
        p_application_name             in varchar2 default null,
        p_business_unit                in varchar2 default null,
        p_technical_contact            in varchar2 default null,
        p_tech_contact_email           in varchar2 default null,
        p_app_desc                     in varchar2 default null,
        p_app_owner                    in varchar2 default null,
        p_app_owner_email              in varchar2 default null,
        p_ref_app_id                   in varchar2 default null
    )
    is
    begin
        update  charter2_inv.v_application_details_tbl set
            --id = p_id,       -- not to update PK 
            application_name   =  nvl(p_application_name,application_name),
            business_unit      =  nvl(p_business_unit,business_unit),
            technical_contact  =  nvl(p_technical_contact,technical_contact),
            tech_contact_email =  nvl(p_tech_contact_email,tech_contact_email),
            app_desc           =  nvl(p_app_desc,app_desc),
            app_owner          =  nvl(p_app_owner,app_owner),
            app_owner_email    =  nvl(p_app_owner_email,app_owner_email),
           ref_app_id          =  nvl(p_ref_app_id,ref_app_id)
        where id = p_id;
    end update_row;

    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_application_details_tbl where id = p_id;
    end delete_row;

end v_application_details_tbl_api;

/
--------------------------------------------------------
--  DDL for Package Body V_CLUSTER_MEMBER_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL_API" 
is
    procedure get_row (
        p_id                           in number,
        P_cluster_name                 out varchar2,
        P_cluster_type                 out varchar2,
        P_gi_version                   out varchar2,
        P_gi_current_patchset          out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_env_source                   out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_cluster_member_tbl where id = p_id) loop
            p_cluster_name := c1.cluster_name;
            p_cluster_type := c1.cluster_type;
            p_gi_version := c1.gi_version;
            p_gi_current_patchset := c1.gi_current_patchset;
            p_host_code := c1.v_host_code;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
            p_env_source := c1.env_source;
        end loop;
    end get_row;
    procedure insert_row  (
        p_id                           out number ,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null,
        p_host_code                    out varchar2 ,
        p_env_source                   in varchar2
    )
    is
    begin
        insert into charter2_inv.v_cluster_member_tbl (
            --id,
            cluster_name,
            cluster_type,
            gi_version,
            gi_current_patchset,
            --v_host_code
            env_source
        ) values (
           -- p_id,
            p_cluster_name,
            p_cluster_type,
            p_gi_version,
            p_gi_current_patchset,
            p_env_source
            --p_host_code
        ) returning id, v_host_code into p_id,p_host_code;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_cluster_name                 in varchar2 default null,
        p_cluster_type                 in varchar2 default null,
        p_gi_version                   in varchar2 default null,
        p_gi_current_patchset          in varchar2 default null--,
        --p_host_code                    in varchar2 default null
    )
    is
    begin
        update  charter2_inv.v_cluster_member_tbl set
           -- id = p_id,
            cluster_name = nvl(p_cluster_name,cluster_name),
            cluster_type = nvl(p_cluster_type,cluster_type),
            gi_version =   nvl(p_gi_version,gi_version),
            gi_current_patchset = nvl(p_gi_current_patchset,gi_current_patchset)--,
            --v_host_code = nvl(p_host_code,v_host_code)
        where id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_cluster_member_tbl where id = p_id;
    end delete_row;
end v_cluster_member_tbl_api;

/
--------------------------------------------------------
--  DDL for Package Body V_DB_CHECK_LIST_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_DB_CHECK_LIST_API" 
is
    procedure get_row (
        p_id                           in number,        
        P_checklist_type               out VARCHAR2,
        P_post_build_status            out varchar2,
        P_cluster_verify               out varchar2,
        P_gi_install_status            out varchar2,
        P_db_install_status            out varchar2,
        P_db_upgrade_status            out varchar2,
        P_gi_upgrade_status            out varchar2,
        P_migration_status             out varchar2,
        P_post_migration_status        out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        p_cluster_id                   out number,
        p_checklist_category           out varchar2,
        p_db_name                      out varchar2,
        p_cluster_name                 out varchar2,
        p_host_name                    out varchar2,
        p_task_desc                    out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_db_check_list where check_list_id = p_id) loop
            p_checklist_type := c1.checklist_type;
            p_post_build_status := c1.post_build_status;
            p_cluster_verify := c1.cluster_verify;
            p_gi_install_status := c1.gi_install_status;
            p_db_install_status := c1.db_install_status;
            p_db_upgrade_status := c1.db_upgrade_status;
            p_gi_upgrade_status := c1.gi_upgrade_status;
            p_migration_status := c1.migration_status;
            p_post_migration_status := c1.post_migration_status;
            p_checklist_category := c1.checklist_category;
            p_host_name := c1.host_name;
            p_cluster_name := c1.cluster_name;
            p_db_name := c1.db_name;
            p_task_desc := c1.task_desc;
        end loop;
    end get_row;
    
    
    procedure insert_row  (
        p_id                           out number,
        p_checklist_type               in varchar2 default null,
        p_post_build_status            in varchar2 default null,
        p_cluster_verify               in varchar2 default null,
        p_gi_install_status            in varchar2 default null,
        p_db_install_status            in varchar2 default null,
        p_db_upgrade_status            in varchar2 default null,
        p_gi_upgrade_status            in varchar2 default null,
        p_migration_status             in varchar2 default null,
        p_post_migration_status        in varchar2 default null,
        p_cluster_id                   in number default null,
        p_checklist_category           in varchar2 default null,
        p_db_name                      in varchar2 default null,
        p_cluster_name                 in varchar2 default null,
        p_host_name                    in varchar2 default null,
        p_task_desc                    in varchar2 default null,
        P_ticket_ref  in varchar2 default null
    )
    is
    begin
        insert into charter2_inv.v_db_check_list (
            checklist_type,
            post_build_status,
            cluster_verify,
            gi_install_status,
            db_install_status,
            db_upgrade_status,
            gi_upgrade_status,
            migration_status,
            post_migration_status,
            checklist_category,
            db_name,
            host_name,
            cluster_name,
            task_desc,
            ticket_ref
        ) values (
            p_checklist_type,
            p_post_build_status,
            p_cluster_verify,
            p_gi_install_status,
            p_db_install_status,
            p_db_upgrade_status,
            p_gi_upgrade_status,
            p_migration_status,
            p_post_migration_status,
            p_checklist_category,
            p_db_name,
            p_host_name,
            p_cluster_name,
            p_task_desc,
            p_ticket_ref
        ) returning check_list_id into p_id ;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_checklist_type               in varchar2 default null,
        p_post_build_status            in varchar2 default null,
        p_cluster_verify               in varchar2 default null,
        p_gi_install_status            in varchar2 default null,
        p_db_install_status            in varchar2 default null,
        p_db_upgrade_status            in varchar2 default null,
        p_gi_upgrade_status            in varchar2 default null,
        p_migration_status             in varchar2 default null,
        p_post_migration_status        in varchar2 default null,
        p_checklist_category           in varchar2 default null,
        p_db_name                      in varchar2 default null,
        p_cluster_name                 in varchar2 default null,
        p_host_name                    in varchar2 default null,
        p_task_desc                    in varchar2 default null        
    )
    is
    begin
        update  charter2_inv.v_db_check_list set
            checklist_type = nvl(p_checklist_type,checklist_type),
            post_build_status = nvl(p_post_build_status,post_build_status),
            cluster_verify = nvl(p_cluster_verify,cluster_verify),
            gi_install_status = nvl(p_gi_install_status,gi_install_status),
            db_install_status = nvl(p_db_install_status,db_install_status),
            db_upgrade_status = nvl(p_db_upgrade_status,db_upgrade_status),
            gi_upgrade_status = nvl(p_gi_upgrade_status,gi_upgrade_status),
            migration_status = nvl(p_migration_status,migration_status),
            post_migration_status = nvl(p_post_migration_status,post_migration_status),
            checklist_category = nvl(p_checklist_category,checklist_category) ,
            db_name = nvl(p_db_name,db_name),
            host_name = nvl(p_host_name, host_name),
            cluster_name = nvl(p_cluster_name, cluster_name),
            task_desc = nvl(p_task_desc,task_desc)
        where check_list_id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_db_check_list where check_list_id = p_id;
    end delete_row;
 
end v_db_check_list_api;

/
--------------------------------------------------------
--  DDL for Package Body V_DB_INVENTORY_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_DB_INVENTORY_API" 
is
    procedure get_row (
        p_id                           in number,
        P_database_name                out varchar2,
        P_application_name             out varchar2,
        P_environment                  out varchar2,
        P_host_name                    out varchar2,
        P_oracle_version               out varchar2,
        P_rac_enabled                  out varchar2,
        P_rac_type                     out varchar2,
        P_business_unit                out varchar2,
        P_cluster_name                 out varchar2,
        P_clustered                    out number,
        P_appliance                    out varchar2,
        P_database_role                out varchar2,
        P_pci_required                 out varchar2,
        P_sox_required                 out varchar2,
        P_encryption_required          out varchar2,
        P_dataguard                    out varchar2,
        P_golden_gate                  out varchar2,
        P_backup_enabled               out varchar2,
        P_end_of_life                  out varchar2,
        P_db_monitoring_tool           out varchar2,
        P_monitoring                   out varchar2,
        P_comments                     out varchar2,
        P_instance_count               out number,
        P_db_source                    out varchar2,
        P_db_id                        out number,
        P_dr_solution                  out varchar2,
        P_dr_location                  out varchar2,
        P_env_category                 out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        P_app_id	                   out number,
        P_storage_type	               out varchar2,
        p_db_home                      out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_db_inventory where id = p_id) loop
            p_database_name := c1.database_name;
            p_application_name := c1.application_name;
            p_environment := c1.environment;
            --p_host_name := c1.host_name;
            p_oracle_version := c1.oracle_version;
            --p_rac_enabled := c1.rac_enabled;
            p_rac_type := c1.rac_type;
            p_business_unit := c1.business_unit;
            --p_cluster_name := c1.cluster_name;
            --p_clustered := c1.clustered;
            p_appliance := c1.appliance;
            p_database_role := c1.database_role;
            p_pci_required := c1.pci_required;
            p_sox_required := c1.sox_required;
            p_encryption_required := c1.encryption_required;
            p_dataguard := c1.dataguard;
            p_golden_gate := c1.golden_gate;
            p_backup_enabled := c1.backup_enabled;
            p_end_of_life := c1.end_of_life;
            p_db_monitoring_tool := c1.db_monitoring_tool;
            p_monitoring := c1.monitoring;
            p_comments := c1.comments;
            p_instance_count := c1.instance_count;
            p_db_source := c1.db_source;
            --p_db_id := c1.db_id;
            p_dr_solution := c1.dr_solution;
            p_dr_location := c1.dr_location;
            p_env_category := c1.env_category;
            p_host_code := c1.v_host_code;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
            P_app_id  := c1.app_id;
            P_storage_type := c1.storage_type;
            p_db_home       := c1.db_home;
        end loop;
    end get_row;
    procedure insert_row  (
        p_id                           out number  ,
        p_database_name                in varchar2 default null,
        p_application_name             in varchar2 default null,
        p_environment                  in varchar2 default null,
       --p_host_name                    in varchar2 default null,
        p_oracle_version               in varchar2 default null,
        --p_rac_enabled                  in varchar2 default null,
        p_rac_type                     in varchar2 default null,
        p_business_unit                in varchar2 default null,
        --p_cluster_name                 in varchar2 default null,
        --p_clustered                    in number default null,
        p_appliance                    in varchar2 default null,
        p_database_role                in varchar2 default null,
        p_pci_required                 in varchar2 default null,
        p_sox_required                 in varchar2 default null,
        p_encryption_required          in varchar2 default null,
        p_dataguard                    in varchar2 default null,
        p_golden_gate                  in varchar2 default null,
        p_backup_enabled               in varchar2 default null,
        p_end_of_life                  in varchar2 default null,
        p_db_monitoring_tool           in varchar2 default null,
        p_monitoring                   in varchar2 default null,
        p_comments                     in varchar2 default null,
        p_instance_count               in number default null,
        p_db_source                    in varchar2 default null,
        --p_db_id                        in number default null,
        p_dr_solution                  in varchar2 default null,
        p_dr_location                  in varchar2 default null,
        p_env_category                 in varchar2 default null,
        p_host_code                    in varchar2 default null,
        p_app_id	                   in number default null,
        p_storage_type	               in varchar2 default null,
        p_db_home                      in varchar2 default null 
    )
    is
    begin
        insert into charter2_inv.v_db_inventory (
            --id,
            database_name,
            application_name,
            environment,
            --host_name,
            oracle_version,
            --rac_enabled,
            rac_type,
            business_unit,
            --cluster_name,
            --clustered,
            appliance,
            database_role,
            pci_required,
            sox_required,
            encryption_required,
            dataguard,
            golden_gate,
            backup_enabled,
            end_of_life,
            db_monitoring_tool,
            monitoring,
            comments,
            instance_count,
            db_source,
            --db_id,
            dr_solution,
            dr_location,
            env_category,
            v_host_code,
            app_id,
            storage_type,
            db_home
        ) values (
            --p_id,
            p_database_name,
            p_application_name,
            p_environment,
            --p_host_name,
            p_oracle_version,
            --p_rac_enabled,
            p_rac_type,
            p_business_unit,
            --p_cluster_name,
            --p_clustered,
            p_appliance,
            p_database_role,
            p_pci_required,
            p_sox_required,
            p_encryption_required,
            p_dataguard,
            p_golden_gate,
            p_backup_enabled,
            p_end_of_life,
            p_db_monitoring_tool,
            p_monitoring,
            p_comments,
            p_instance_count,
            p_db_source,
            --p_db_id,
            p_dr_solution,
            p_dr_location,
            p_env_category,
            p_host_code,
            p_app_id,
            p_storage_type,
            p_db_home
        ) returning id into p_id ;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_database_name                in varchar2 default null,
        p_application_name             in varchar2 default null,
        p_environment                  in varchar2 default null,
        --p_host_name                    in varchar2 default null,
        p_oracle_version               in varchar2 default null,
        --p_rac_enabled                  in varchar2 default null,
        p_rac_type                     in varchar2 default null,
        p_business_unit                in varchar2 default null,
        --p_cluster_name                 in varchar2 default null,
        --p_clustered                    in number default null,
        p_appliance                    in varchar2 default null,
        p_database_role                in varchar2 default null,
        p_pci_required                 in varchar2 default null,
        p_sox_required                 in varchar2 default null,
        p_encryption_required          in varchar2 default null,
        p_dataguard                    in varchar2 default null,
        p_golden_gate                  in varchar2 default null,
        p_backup_enabled               in varchar2 default null,
        p_end_of_life                  in varchar2 default null,
        p_db_monitoring_tool           in varchar2 default null,
        p_monitoring                   in varchar2 default null,
        p_comments                     in varchar2 default null,
        p_instance_count               in number default null,
        p_db_source                    in varchar2 default null,
        --p_db_id                        in number default null,
        p_dr_solution                  in varchar2 default null,
        p_dr_location                  in varchar2 default null,
        p_env_category                 in varchar2 default null,
        p_host_code                    in varchar2 default null,
        p_app_id	                   in number default null,
        p_storage_type	               in varchar2 default null,
        p_db_home                      in varchar2 default null 
    )
    is
    begin
        update  charter2_inv.v_db_inventory set
            --id = p_id,
            database_name = nvl(p_database_name,database_name),
            application_name = nvl(p_application_name,application_name),
            environment = nvl(p_environment,environment),
            --host_name = p_host_name,
            oracle_version = nvl(p_oracle_version,oracle_version),
            --rac_enabled = p_rac_enabled,
            rac_type = nvl(p_rac_type,rac_type),
            business_unit = nvl(p_business_unit,business_unit),
            --cluster_name = p_cluster_name,
            --clustered = p_clustered,
            appliance = nvl(p_appliance,appliance),
            database_role = nvl(p_database_role,database_role),
            pci_required = nvl(p_pci_required,pci_required),
            sox_required = nvl(p_sox_required,sox_required),
            encryption_required = nvl(p_encryption_required,encryption_required),
            dataguard = nvl(p_dataguard,dataguard),
            golden_gate = nvl(p_golden_gate,golden_gate),
            backup_enabled = nvl(p_backup_enabled,backup_enabled),
            end_of_life = nvl(p_end_of_life,end_of_life),
            db_monitoring_tool = nvl(p_db_monitoring_tool,db_monitoring_tool),
            monitoring = nvl(p_monitoring,monitoring),
            comments = nvl(p_comments,comments),
            instance_count = nvl(p_instance_count,instance_count),
            db_source = nvl(p_db_source,db_source),
            --db_id = p_db_id,
            dr_solution = nvl(p_dr_solution,dr_solution),
            dr_location = nvl(p_dr_location,dr_location),
            env_category = nvl(p_env_category,env_category),
            v_host_code = nvl(p_host_code,v_host_code),
            app_id = nvl(p_app_id,app_id),
            storage_type = nvl(p_storage_type,storage_type),
            db_home = nvl(p_db_home,db_home)
        where id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_db_inventory where id = p_id;
    end delete_row;
end v_db_inventory_api;

/
--------------------------------------------------------
--  DDL for Package Body V_DB_PATCH_HISTORY_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_DB_PATCH_HISTORY_API" 
is 
procedure get_row (
p_id              in number,
p_db_home          out varchar2,
p_PSU_NUMBER      out VARCHAR2,
p_PSU_QUARTER      out varchar2,
p_PSU_YEAR         out VARCHAR2,
p_patch_type       out varchar2,
p_host_code          out varchar2,
p_host_name         out varchar2,
p_patch_status      out VARCHAR2 
)
is
begin
    for c1 in (select * from charter2_inv.v_db_patch_history where id = p_id) loop
      p_db_home :=  c1.db_home;
        p_PSU_NUMBER := c1.PSU_NUMBER;
        p_PSU_QUARTER := c1.PSU_QUARTER;
        p_PSU_YEAR := c1.PSU_YEAR;
        p_patch_type := c1.patch_type;
        p_host_code := c1.host_code;
        p_host_name := c1.host_name;
        p_patch_status := c1.patch_status;
    end loop;
 end get_row;

procedure insert_row (
p_id              out number,
p_db_home          in varchar2 default null,
p_PSU_NUMBER       in varchar2 default null,
p_PSU_QUARTER      in varchar2 default null,
p_PSU_YEAR         in varchar2 default null,
p_patch_type        in varchar2 default null,
p_host_code           in varchar2 default null,
p_host_name           in varchar2 default null,
p_patch_status      in VARCHAR2 default null
)
is 
begin

insert into  charter2_inv.v_db_patch_history ( db_home,PSU_NUMBER,PSU_QUARTER,PSU_YEAR,patch_type, host_code,host_name,patch_status)
values (p_db_home,p_PSU_NUMBER,p_PSU_QUARTER,p_PSU_YEAR,p_PATCH_TYPE,p_host_code,p_host_name,p_patch_status) returning id into p_id;

end insert_row;


procedure update_row (
p_id              in number default null,
p_db_home           in VARCHAR2 default null,
p_PSU_NUMBER       in varchar2 default null,
p_PSU_QUARTER      in varchar2 default null,
p_PSU_YEAR         in varchar2 default null,
p_patch_type        in varchar2 default null,
p_host_code          in VARCHAR2 default null,
p_host_name         in VARCHAR2 default null,
p_patch_status      in VARCHAR2 default null
)
is 
begin

update charter2_inv.v_db_patch_history
set  db_home= nvl(p_db_home,db_home),
PSU_NUMBER = nvl(p_PSU_NUMBER,PSU_NUMBER),
PSU_QUARTER = nvl(p_PSU_QUARTER,PSU_QUARTER),
PSU_YEAR = nvl (p_PSU_YEAR,PSU_YEAR),
PATCH_TYPE = nvl(p_PATCH_TYPE,PATCH_TYPE),
host_code = nvl(p_host_code,host_code),
host_name = nvl(p_host_name,host_name),
patch_status = p_patch_status
where id = p_id;

end update_row;

 procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_db_patch_history
        where id = p_id;
    end delete_row;
end    v_db_patch_history_api;

/
--------------------------------------------------------
--  DDL for Package Body V_DB_SCHEDULE_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_DB_SCHEDULE_TBL_API" 
is
--123456789*123456789*123456789*
--P_upgrade_completion_time_times with P_UPGR_COMPLETN_TIMES
--P_UPGR_COMPLETN_TIMES with P_mig_comp_time_tim
    procedure get_row (
        p_id                           in number,
        P_db_id                        out number,
        P_upgrade_start_date           out date,
        P_upgrade_end_date             out date,
        P_migration_start_date         out date,
        P_migration_end_date           out date,
        P_UPGR_COMPLETN_TIMES          out varchar2,
        P_MIGR_COMPLETN_TIMES          out varchar2,
        P_migration_method             out varchar2,
        P_outage_window                out number,
        P_comments                     out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_db_schedule_tbl where id = p_id) loop
            p_db_id := c1.db_id;
            p_upgrade_start_date := c1.upgrade_start_date;
            p_upgrade_end_date := c1.upgrade_end_date;
            p_migration_start_date := c1.migration_start_date;
            p_migration_end_date := c1.migration_end_date;
            P_UPGR_COMPLETN_TIMES     := c1.upgrade_completion_time;
            P_MIGR_COMPLETN_TIMES     := c1.migration_completion_time;
            p_migration_method := c1.migration_method;
            p_outage_window := c1.outage_window;
            p_comments := c1.comments;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
        end loop;
    end get_row;
    procedure insert_row  (
        p_id                           out number  ,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    )
    is
    begin
        insert into charter2_inv.v_db_schedule_tbl (
            --id,
            db_id,
            upgrade_start_date,
            upgrade_end_date,
            migration_start_date,
            migration_end_date,
            upgrade_completion_time,
            migration_completion_time,
            migration_method,
            outage_window,
            comments
        ) values (
            --p_id,
            p_db_id,
            p_upgrade_start_date,
            p_upgrade_end_date,
            p_migration_start_date,
            p_migration_end_date,
            p_upgrade_completion_time  ,
            p_migration_completion_time ,
            p_migration_method,
            p_outage_window,
            p_comments
        ) RETURNING id into p_id ;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_db_id                        in number default null,
        p_upgrade_start_date           in date default null,
        p_upgrade_end_date             in date default null,
        p_migration_start_date         in date default null,
        p_migration_end_date           in date default null,
        p_upgrade_completion_time      in varchar2 default null,
        p_migration_completion_time    in varchar2 default null,
        p_migration_method             in varchar2 default null,
        p_outage_window                in number default null,
        p_comments                     in varchar2 default null
    )
    is
    begin
        update  charter2_inv.v_db_schedule_tbl set
            --id = p_id,
            db_id = nvl(p_db_id,db_id),
            upgrade_start_date = nvl(p_upgrade_start_date,upgrade_start_date),
            upgrade_end_date = nvl(p_upgrade_end_date,upgrade_end_date),
            migration_start_date = nvl(p_migration_start_date,migration_start_date),
            migration_end_date = nvl(p_migration_end_date,migration_end_date),
            upgrade_completion_time = nvl(p_upgrade_completion_time ,upgrade_completion_time),
            migration_completion_time =  nvl(p_migration_completion_time, migration_completion_time),
            migration_method = nvl(p_migration_method,migration_method),
            outage_window = nvl(p_outage_window,outage_window),
            comments = nvl(p_comments,comments)
        where id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_db_schedule_tbl where id = p_id;
    end delete_row;
end v_db_schedule_tbl_api;

/
--------------------------------------------------------
--  DDL for Package Body V_HOST_INV_TBL_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_HOST_INV_TBL_API" 
is
    procedure get_row (
        p_id                           in number,
        P_host_name                    out varchar2,
        P_network_type                 out varchar2,
        P_core_count                   out number,
        P_processor_config_speed       out varchar2,
        P_server_model                 out varchar2,
        P_hardware_vendor              out varchar2,
        P_os_type_version              out varchar2,
        P_processor_bit                out varchar2,
        P_server_creation_date         out varchar2,
        P_phy_virt                     out varchar2,
        P_dc_location                  out varchar2,
        P_global_zone_solaris          out varchar2,
        P_phy_memory                   out varchar2,
        P_server_monitoring_tool       out varchar2,
        P_host_code                    out varchar2,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2,
        --p_db_id	                       out number,
        --p_cluster_id	               out number,
        p_clustered	                   out varchar2,
        p_os_type	                   out varchar2,
        p_env_source	               out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_host_inv_tbl where id = p_id) loop
            p_host_name := c1.host_name;
            p_network_type := c1.network_type;
            p_core_count := c1.core_count;
            p_processor_config_speed := c1.processor_config_speed;
            p_server_model := c1.server_model;
            p_hardware_vendor := c1.hardware_vendor;
            p_os_type_version := c1.os_type_version;
            p_processor_bit := c1.processor_bit;
            p_server_creation_date := c1.server_creation_date;
            p_phy_virt := c1.phy_virt;
            p_dc_location := c1.dc_location;
            p_global_zone_solaris := c1.global_zone_solaris;
            p_phy_memory := c1.phy_memory;
            p_server_monitoring_tool := c1.server_monitoring_tool;
            p_host_code := c1.host_code;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
           -- p_db_id := c1.db_id;
           -- p_cluster_id := c1.cluster_id ;
            p_clustered := c1.clustered ;
            p_os_type := c1.os_type;
            p_env_source := c1.env_source;
            
        end loop;
    end get_row;
    procedure insert_row  (
        p_id                           out number  ,
        p_host_name                    in varchar2 default null,
        p_network_type                 in varchar2 default null,
        p_core_count                   in number default null,
        p_processor_config_speed       in varchar2 default null,
        p_server_model                 in varchar2 default null,
        p_hardware_vendor              in varchar2 default null,
        p_os_type_version              in varchar2 default null,
        p_processor_bit                in varchar2 default null,
        p_server_creation_date         in varchar2 default null,
        p_phy_virt                     in varchar2 default null,
        p_dc_location                  in varchar2 default null,
        p_global_zone_solaris          in varchar2 default null,
        p_phy_memory                   in varchar2 default null,
        p_server_monitoring_tool       in varchar2 default null,
        p_host_code                    out varchar2  ,
        --p_db_id	                       in number default null,
        --p_cluster_id	               in number default null,
        p_clustered	                   in varchar2 default null,
        p_os_type	                   in varchar2 default null,
        p_env_source	               in varchar2        
    )
    is
    begin
        insert into charter2_inv.v_host_inv_tbl (
           -- id,
            host_name,
            network_type,
            core_count,
            processor_config_speed,
            server_model,
            hardware_vendor,
            os_type_version,
            processor_bit,
            server_creation_date,
            phy_virt,
            dc_location,
            global_zone_solaris,
            phy_memory,
            server_monitoring_tool,
            --host_code,
            --db_id,
            --cluster_id,
            clustered,
            os_type,
            env_source            
        ) values (
          --  p_id,
            p_host_name,
            p_network_type,
            p_core_count,
            p_processor_config_speed,
            p_server_model,
            p_hardware_vendor,
            p_os_type_version,
            p_processor_bit,
            p_server_creation_date,
            p_phy_virt,
            p_dc_location,
            p_global_zone_solaris,
            p_phy_memory,
            p_server_monitoring_tool,
            --p_host_code,
            --p_db_id,
            --p_cluster_id,
            p_clustered,
            p_os_type,
            p_env_source
        ) returning id,host_code into p_id,p_host_code;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_host_name                    in varchar2 default null,
        p_network_type                 in varchar2 default null,
        p_core_count                   in number default null,
        p_processor_config_speed       in varchar2 default null,
        p_server_model                 in varchar2 default null,
        p_hardware_vendor              in varchar2 default null,
        p_os_type_version              in varchar2 default null,
        p_processor_bit                in varchar2 default null,
        p_server_creation_date         in varchar2 default null,
        p_phy_virt                     in varchar2 default null,
        p_dc_location                  in varchar2 default null,
        p_global_zone_solaris          in varchar2 default null,
        p_phy_memory                   in varchar2 default null,
        p_server_monitoring_tool       in varchar2 default null,
        --p_host_code                    in varchar2 default null,
        --p_db_id	                       in number default null,
        --p_cluster_id	               in number default null,
        p_clustered	                   in varchar2 default null,
        p_os_type	                   in varchar2 default null
        --p_env_source	               in varchar2 default null            
    )
    is
    begin
        update  charter2_inv.v_host_inv_tbl set
            --id = p_id,
            host_name = nvl(p_host_name,host_name),
            network_type = nvl(p_network_type,network_type),
            core_count = nvl(p_core_count,core_count),
            processor_config_speed = nvl(p_processor_config_speed,processor_config_speed),
            server_model = nvl(p_server_model,server_model),
            hardware_vendor = nvl(p_hardware_vendor,hardware_vendor),
            os_type_version = nvl(p_os_type_version,os_type_version),
            processor_bit = nvl(p_processor_bit,processor_bit),
            server_creation_date = nvl(p_server_creation_date,server_creation_date),
            phy_virt = nvl(p_phy_virt,phy_virt),
            dc_location = nvl(p_dc_location,dc_location),
            global_zone_solaris = nvl(p_global_zone_solaris,global_zone_solaris),
            phy_memory = nvl(p_phy_memory,phy_memory),
            server_monitoring_tool = nvl(p_server_monitoring_tool,server_monitoring_tool),
            --host_code = nvl(p_host_code,host_code),
            --db_id= nvl(p_db_id,db_id),
            --cluster_id = nvl(p_cluster_id,cluster_id),
            clustered = nvl(p_clustered,clustered),
            os_type = nvl(p_os_type,os_type)--,
            --env_source = nvl(p_env_source,env_source)            
        where id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_host_inv_tbl where id = p_id;
    end delete_row;
end v_host_inv_tbl_api;

/
--------------------------------------------------------
--  DDL for Package Body V_REQUEST_QUEUE_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_REQUEST_QUEUE_API" is
--------------------------------------------------------------
-- create procedure for table "V_REQUEST_QUEUE"
   procedure "INS_V_REQUEST_QUEUE" (
      "P_ID"                     in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null
   ) is 
 
   begin
 
      insert into "V_REQUEST_QUEUE" (
         "ID",
         "TEMPLATE_TYPE",
         "TEMPLATE_NAME",
         "JOB_NAME",
         "REQUEST_TYPE",
         "DB_OPTION",
         "HOST_NAME",
         "CLUSTER_NAME",
         "CLUSTER_TYPE",
         "GI_VERSION",
         "ENV_SOURCE",
         "TICKET_REF",
         "APPLICATION_NAME",
         "BUSINESS_UNIT",
         "NETWORK_TYPE",
         "ORACLE_VERSION",
         "OS_TYPE",
         "OS_TYPE_VERSION",
         "PHY_VERT",
         "CLUSTERED",
         "DC_LOCATION",
         "SERVER_MONITORING_TOOL",
         "ORACLE_DB_NAME",
         "DB_ENVIRONMENT",
         "RAC_TYPE",
         "DATABASE_ROLE",
         "ENV_CATEGORY",
         "STORAGE_TYPE",
         "DB_MONITORING_TOOL",
         "APPLIANCE",
         "PCI_REQUIRED",
         "SOX_REQUIRED",
         "ENCRYPTION_REQUIRED",
         "BACKUP_ENABLED",
         "MONITORING",
         "STATUS",
         "CREATED",
         "CREATED_BY",
         "UPDATED",
         "UPDATED_BY"
      ) values ( 
         "P_ID",
         "P_TEMPLATE_TYPE",
         "P_TEMPLATE_NAME",
         "P_JOB_NAME",
         "P_REQUEST_TYPE",
         "P_DB_OPTION",
         "P_HOST_NAME",
         "P_CLUSTER_NAME",
         "P_CLUSTER_TYPE",
         "P_GI_VERSION",
         "P_ENV_SOURCE",
         "P_TICKET_REF",
         "P_APPLICATION_NAME",
         "P_BUSINESS_UNIT",
         "P_NETWORK_TYPE",
         "P_ORACLE_VERSION",
         "P_OS_TYPE",
         "P_OS_TYPE_VERSION",
         "P_PHY_VERT",
         "P_CLUSTERED",
         "P_DC_LOCATION",
         "P_SERVER_MONITORING_TOOL",
         "P_ORACLE_DB_NAME",
         "P_DB_ENVIRONMENT",
         "P_RAC_TYPE",
         "P_DATABASE_ROLE",
         "P_ENV_CATEGORY",
         "P_STORAGE_TYPE",
         "P_DB_MONITORING_TOOL",
         "P_APPLIANCE",
         "P_PCI_REQUIRED",
         "P_SOX_REQUIRED",
         "P_ENCRYPTION_REQUIRED",
         "P_BACKUP_ENABLED",
         "P_MONITORING",
         "P_STATUS",
         "P_CREATED",
         "P_CREATED_BY",
         "P_UPDATED",
         "P_UPDATED_BY"
      );
 
   end "INS_V_REQUEST_QUEUE";
--------------------------------------------------------------
-- update procedure for table "V_REQUEST_QUEUE"
   procedure "UPD_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null,
      "P_MD5"                    in varchar2                        default null
   ) is 
 
      "L_MD5" varchar2(32767) := null;
 
   begin
 
      if "P_MD5" is not null then
         for c1 in (
            select * from "V_REQUEST_QUEUE" 
            where "ID" = "P_ID" FOR UPDATE
         ) loop
 
            "L_MD5" := "BUILD_V_REQUEST_QUEUE_MD5"(
               c1."ID",
               c1."TEMPLATE_TYPE",
               c1."TEMPLATE_NAME",
               c1."JOB_NAME",
               c1."REQUEST_TYPE",
               c1."DB_OPTION",
               c1."HOST_NAME",
               c1."CLUSTER_NAME",
               c1."CLUSTER_TYPE",
               c1."GI_VERSION",
               c1."ENV_SOURCE",
               c1."TICKET_REF",
               c1."APPLICATION_NAME",
               c1."BUSINESS_UNIT",
               c1."NETWORK_TYPE",
               c1."ORACLE_VERSION",
               c1."OS_TYPE",
               c1."OS_TYPE_VERSION",
               c1."PHY_VERT",
               c1."CLUSTERED",
               c1."DC_LOCATION",
               c1."SERVER_MONITORING_TOOL",
               c1."ORACLE_DB_NAME",
               c1."DB_ENVIRONMENT",
               c1."RAC_TYPE",
               c1."DATABASE_ROLE",
               c1."ENV_CATEGORY",
               c1."STORAGE_TYPE",
               c1."DB_MONITORING_TOOL",
               c1."APPLIANCE",
               c1."PCI_REQUIRED",
               c1."SOX_REQUIRED",
               c1."ENCRYPTION_REQUIRED",
               c1."BACKUP_ENABLED",
               c1."MONITORING",
               c1."STATUS",
               c1."CREATED",
               c1."CREATED_BY",
               c1."UPDATED",
               c1."UPDATED_BY"
            );
 
         end loop;
 
      end if;
 
      if ("P_MD5" is null) or ("L_MD5" = "P_MD5") then 
         update "V_REQUEST_QUEUE" set
            "ID"                       = "P_ID",
            "TEMPLATE_TYPE"            = "P_TEMPLATE_TYPE",
            "TEMPLATE_NAME"            = "P_TEMPLATE_NAME",
            "JOB_NAME"                 = "P_JOB_NAME",
            "REQUEST_TYPE"             = "P_REQUEST_TYPE",
            "DB_OPTION"                = "P_DB_OPTION",
            "HOST_NAME"                = "P_HOST_NAME",
            "CLUSTER_NAME"             = "P_CLUSTER_NAME",
            "CLUSTER_TYPE"             = "P_CLUSTER_TYPE",
            "GI_VERSION"               = "P_GI_VERSION",
            "ENV_SOURCE"               = "P_ENV_SOURCE",
            "TICKET_REF"               = "P_TICKET_REF",
            "APPLICATION_NAME"         = "P_APPLICATION_NAME",
            "BUSINESS_UNIT"            = "P_BUSINESS_UNIT",
            "NETWORK_TYPE"             = "P_NETWORK_TYPE",
            "ORACLE_VERSION"           = "P_ORACLE_VERSION",
            "OS_TYPE"                  = "P_OS_TYPE",
            "OS_TYPE_VERSION"          = "P_OS_TYPE_VERSION",
            "PHY_VERT"                 = "P_PHY_VERT",
            "CLUSTERED"                = "P_CLUSTERED",
            "DC_LOCATION"              = "P_DC_LOCATION",
            "SERVER_MONITORING_TOOL"   = "P_SERVER_MONITORING_TOOL",
            "ORACLE_DB_NAME"           = "P_ORACLE_DB_NAME",
            "DB_ENVIRONMENT"           = "P_DB_ENVIRONMENT",
            "RAC_TYPE"                 = "P_RAC_TYPE",
            "DATABASE_ROLE"            = "P_DATABASE_ROLE",
            "ENV_CATEGORY"             = "P_ENV_CATEGORY",
            "STORAGE_TYPE"             = "P_STORAGE_TYPE",
            "DB_MONITORING_TOOL"       = "P_DB_MONITORING_TOOL",
            "APPLIANCE"                = "P_APPLIANCE",
            "PCI_REQUIRED"             = "P_PCI_REQUIRED",
            "SOX_REQUIRED"             = "P_SOX_REQUIRED",
            "ENCRYPTION_REQUIRED"      = "P_ENCRYPTION_REQUIRED",
            "BACKUP_ENABLED"           = "P_BACKUP_ENABLED",
            "MONITORING"               = "P_MONITORING",
            "STATUS"                   = "P_STATUS",
            "CREATED"                  = "P_CREATED",
            "CREATED_BY"               = "P_CREATED_BY",
            "UPDATED"                  = "P_UPDATED",
            "UPDATED_BY"               = "P_UPDATED_BY"
         where "ID" = "P_ID";
      else
         raise_application_error (-20001,'Current version of data in database has changed since user initiated update process. current checksum = "'||"L_MD5"||'", item checksum = "'||"P_MD5"||'".');  
      end if;
 
   end "UPD_V_REQUEST_QUEUE";
--------------------------------------------------------------
-- delete procedure for table "V_REQUEST_QUEUE"
   procedure "DEL_V_REQUEST_QUEUE" (
      "P_ID" in number
   ) is 
 
   begin
 
      delete from "V_REQUEST_QUEUE" 
      where "ID" = "P_ID";
 
   end "DEL_V_REQUEST_QUEUE";
--------------------------------------------------------------
-- get procedure for table "V_REQUEST_QUEUE"
   procedure "GET_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          out varchar2,
      "P_TEMPLATE_NAME"          out varchar2,
      "P_JOB_NAME"               out varchar2,
      "P_REQUEST_TYPE"           out varchar2,
      "P_DB_OPTION"              out varchar2,
      "P_HOST_NAME"              out clob,
      "P_CLUSTER_NAME"           out varchar2,
      "P_CLUSTER_TYPE"           out varchar2,
      "P_GI_VERSION"             out varchar2,
      "P_ENV_SOURCE"             out varchar2,
      "P_TICKET_REF"             out varchar2,
      "P_APPLICATION_NAME"       out varchar2,
      "P_BUSINESS_UNIT"          out varchar2,
      "P_NETWORK_TYPE"           out varchar2,
      "P_ORACLE_VERSION"         out varchar2,
      "P_OS_TYPE"                out varchar2,
      "P_OS_TYPE_VERSION"        out varchar2,
      "P_PHY_VERT"               out varchar2,
      "P_CLUSTERED"              out varchar2,
      "P_DC_LOCATION"            out varchar2,
      "P_SERVER_MONITORING_TOOL" out varchar2,
      "P_ORACLE_DB_NAME"         out varchar2,
      "P_DB_ENVIRONMENT"         out varchar2,
      "P_RAC_TYPE"               out varchar2,
      "P_DATABASE_ROLE"          out varchar2,
      "P_ENV_CATEGORY"           out varchar2,
      "P_STORAGE_TYPE"           out varchar2,
      "P_DB_MONITORING_TOOL"     out varchar2,
      "P_APPLIANCE"              out varchar2,
      "P_PCI_REQUIRED"           out varchar2,
      "P_SOX_REQUIRED"           out varchar2,
      "P_ENCRYPTION_REQUIRED"    out varchar2,
      "P_BACKUP_ENABLED"         out varchar2,
      "P_MONITORING"             out varchar2,
      "P_STATUS"                 out varchar2,
      "P_CREATED"                out date,
      "P_CREATED_BY"             out varchar2,
      "P_UPDATED"                out date,
      "P_UPDATED_BY"             out varchar2
   ) is 
 
      ignore varchar2(32676);
   begin
 
      "GET_V_REQUEST_QUEUE" (
         "P_ID",
         "P_TEMPLATE_TYPE",
         "P_TEMPLATE_NAME",
         "P_JOB_NAME",
         "P_REQUEST_TYPE",
         "P_DB_OPTION",
         "P_HOST_NAME",
         "P_CLUSTER_NAME",
         "P_CLUSTER_TYPE",
         "P_GI_VERSION",
         "P_ENV_SOURCE",
         "P_TICKET_REF",
         "P_APPLICATION_NAME",
         "P_BUSINESS_UNIT",
         "P_NETWORK_TYPE",
         "P_ORACLE_VERSION",
         "P_OS_TYPE",
         "P_OS_TYPE_VERSION",
         "P_PHY_VERT",
         "P_CLUSTERED",
         "P_DC_LOCATION",
         "P_SERVER_MONITORING_TOOL",
         "P_ORACLE_DB_NAME",
         "P_DB_ENVIRONMENT",
         "P_RAC_TYPE",
         "P_DATABASE_ROLE",
         "P_ENV_CATEGORY",
         "P_STORAGE_TYPE",
         "P_DB_MONITORING_TOOL",
         "P_APPLIANCE",
         "P_PCI_REQUIRED",
         "P_SOX_REQUIRED",
         "P_ENCRYPTION_REQUIRED",
         "P_BACKUP_ENABLED",
         "P_MONITORING",
         "P_STATUS",
         "P_CREATED",
         "P_CREATED_BY",
         "P_UPDATED",
         "P_UPDATED_BY",
         ignore
      );
 
   end "GET_V_REQUEST_QUEUE";
--------------------------------------------------------------
-- get procedure for table "V_REQUEST_QUEUE"
   procedure "GET_V_REQUEST_QUEUE" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          out varchar2,
      "P_TEMPLATE_NAME"          out varchar2,
      "P_JOB_NAME"               out varchar2,
      "P_REQUEST_TYPE"           out varchar2,
      "P_DB_OPTION"              out varchar2,
      "P_HOST_NAME"              out clob,
      "P_CLUSTER_NAME"           out varchar2,
      "P_CLUSTER_TYPE"           out varchar2,
      "P_GI_VERSION"             out varchar2,
      "P_ENV_SOURCE"             out varchar2,
      "P_TICKET_REF"             out varchar2,
      "P_APPLICATION_NAME"       out varchar2,
      "P_BUSINESS_UNIT"          out varchar2,
      "P_NETWORK_TYPE"           out varchar2,
      "P_ORACLE_VERSION"         out varchar2,
      "P_OS_TYPE"                out varchar2,
      "P_OS_TYPE_VERSION"        out varchar2,
      "P_PHY_VERT"               out varchar2,
      "P_CLUSTERED"              out varchar2,
      "P_DC_LOCATION"            out varchar2,
      "P_SERVER_MONITORING_TOOL" out varchar2,
      "P_ORACLE_DB_NAME"         out varchar2,
      "P_DB_ENVIRONMENT"         out varchar2,
      "P_RAC_TYPE"               out varchar2,
      "P_DATABASE_ROLE"          out varchar2,
      "P_ENV_CATEGORY"           out varchar2,
      "P_STORAGE_TYPE"           out varchar2,
      "P_DB_MONITORING_TOOL"     out varchar2,
      "P_APPLIANCE"              out varchar2,
      "P_PCI_REQUIRED"           out varchar2,
      "P_SOX_REQUIRED"           out varchar2,
      "P_ENCRYPTION_REQUIRED"    out varchar2,
      "P_BACKUP_ENABLED"         out varchar2,
      "P_MONITORING"             out varchar2,
      "P_STATUS"                 out varchar2,
      "P_CREATED"                out date,
      "P_CREATED_BY"             out varchar2,
      "P_UPDATED"                out date,
      "P_UPDATED_BY"             out varchar2,
      "P_MD5"                    out varchar2
   ) is 
 
   begin
 
      for c1 in (
         select * from "V_REQUEST_QUEUE" 
         where "ID" = "P_ID" 
      ) loop
         "P_TEMPLATE_TYPE"          := c1."TEMPLATE_TYPE";
         "P_TEMPLATE_NAME"          := c1."TEMPLATE_NAME";
         "P_JOB_NAME"               := c1."JOB_NAME";
         "P_REQUEST_TYPE"           := c1."REQUEST_TYPE";
         "P_DB_OPTION"              := c1."DB_OPTION";
         "P_HOST_NAME"              := c1."HOST_NAME";
         "P_CLUSTER_NAME"           := c1."CLUSTER_NAME";
         "P_CLUSTER_TYPE"           := c1."CLUSTER_TYPE";
         "P_GI_VERSION"             := c1."GI_VERSION";
         "P_ENV_SOURCE"             := c1."ENV_SOURCE";
         "P_TICKET_REF"             := c1."TICKET_REF";
         "P_APPLICATION_NAME"       := c1."APPLICATION_NAME";
         "P_BUSINESS_UNIT"          := c1."BUSINESS_UNIT";
         "P_NETWORK_TYPE"           := c1."NETWORK_TYPE";
         "P_ORACLE_VERSION"         := c1."ORACLE_VERSION";
         "P_OS_TYPE"                := c1."OS_TYPE";
         "P_OS_TYPE_VERSION"        := c1."OS_TYPE_VERSION";
         "P_PHY_VERT"               := c1."PHY_VERT";
         "P_CLUSTERED"              := c1."CLUSTERED";
         "P_DC_LOCATION"            := c1."DC_LOCATION";
         "P_SERVER_MONITORING_TOOL" := c1."SERVER_MONITORING_TOOL";
         "P_ORACLE_DB_NAME"         := c1."ORACLE_DB_NAME";
         "P_DB_ENVIRONMENT"         := c1."DB_ENVIRONMENT";
         "P_RAC_TYPE"               := c1."RAC_TYPE";
         "P_DATABASE_ROLE"          := c1."DATABASE_ROLE";
         "P_ENV_CATEGORY"           := c1."ENV_CATEGORY";
         "P_STORAGE_TYPE"           := c1."STORAGE_TYPE";
         "P_DB_MONITORING_TOOL"     := c1."DB_MONITORING_TOOL";
         "P_APPLIANCE"              := c1."APPLIANCE";
         "P_PCI_REQUIRED"           := c1."PCI_REQUIRED";
         "P_SOX_REQUIRED"           := c1."SOX_REQUIRED";
         "P_ENCRYPTION_REQUIRED"    := c1."ENCRYPTION_REQUIRED";
         "P_BACKUP_ENABLED"         := c1."BACKUP_ENABLED";
         "P_MONITORING"             := c1."MONITORING";
         "P_STATUS"                 := c1."STATUS";
         "P_CREATED"                := c1."CREATED";
         "P_CREATED_BY"             := c1."CREATED_BY";
         "P_UPDATED"                := c1."UPDATED";
         "P_UPDATED_BY"             := c1."UPDATED_BY";
 
         "P_MD5" := "BUILD_V_REQUEST_QUEUE_MD5"(
            c1."ID",
            c1."TEMPLATE_TYPE",
            c1."TEMPLATE_NAME",
            c1."JOB_NAME",
            c1."REQUEST_TYPE",
            c1."DB_OPTION",
            c1."HOST_NAME",
            c1."CLUSTER_NAME",
            c1."CLUSTER_TYPE",
            c1."GI_VERSION",
            c1."ENV_SOURCE",
            c1."TICKET_REF",
            c1."APPLICATION_NAME",
            c1."BUSINESS_UNIT",
            c1."NETWORK_TYPE",
            c1."ORACLE_VERSION",
            c1."OS_TYPE",
            c1."OS_TYPE_VERSION",
            c1."PHY_VERT",
            c1."CLUSTERED",
            c1."DC_LOCATION",
            c1."SERVER_MONITORING_TOOL",
            c1."ORACLE_DB_NAME",
            c1."DB_ENVIRONMENT",
            c1."RAC_TYPE",
            c1."DATABASE_ROLE",
            c1."ENV_CATEGORY",
            c1."STORAGE_TYPE",
            c1."DB_MONITORING_TOOL",
            c1."APPLIANCE",
            c1."PCI_REQUIRED",
            c1."SOX_REQUIRED",
            c1."ENCRYPTION_REQUIRED",
            c1."BACKUP_ENABLED",
            c1."MONITORING",
            c1."STATUS",
            c1."CREATED",
            c1."CREATED_BY",
            c1."UPDATED",
            c1."UPDATED_BY"
         );
      end loop;
 
   end "GET_V_REQUEST_QUEUE";
--------------------------------------------------------------
-- build MD5 function for table "V_REQUEST_QUEUE"
   function "BUILD_V_REQUEST_QUEUE_MD5" (
      "P_ID" in number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default '''PROVISIONING''',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default null,
      "P_CREATED"                in date                            default null,
      "P_CREATED_BY"             in varchar2                        default 'coalesce(sys_context(''APEX$SESSION'',''app_user''),regexp_substr(sys_context(''userenv'',''client_identifier''),''^[^:]*''),sys_context(''userenv'',''session_user'')) ',
      "P_UPDATED"                in date                            default null,
      "P_UPDATED_BY"             in varchar2                        default null
   ) return varchar2 is 
 
   begin
 
      return apex_util.get_hash(apex_t_varchar2(
         "P_TEMPLATE_TYPE",
         "P_TEMPLATE_NAME",
         "P_JOB_NAME",
         "P_REQUEST_TYPE",
         "P_DB_OPTION",
         "P_HOST_NAME",
         "P_CLUSTER_NAME",
         "P_CLUSTER_TYPE",
         "P_GI_VERSION",
         "P_ENV_SOURCE",
         "P_TICKET_REF",
         "P_APPLICATION_NAME",
         "P_BUSINESS_UNIT",
         "P_NETWORK_TYPE",
         "P_ORACLE_VERSION",
         "P_OS_TYPE",
         "P_OS_TYPE_VERSION",
         "P_PHY_VERT",
         "P_CLUSTERED",
         "P_DC_LOCATION",
         "P_SERVER_MONITORING_TOOL",
         "P_ORACLE_DB_NAME",
         "P_DB_ENVIRONMENT",
         "P_RAC_TYPE",
         "P_DATABASE_ROLE",
         "P_ENV_CATEGORY",
         "P_STORAGE_TYPE",
         "P_DB_MONITORING_TOOL",
         "P_APPLIANCE",
         "P_PCI_REQUIRED",
         "P_SOX_REQUIRED",
         "P_ENCRYPTION_REQUIRED",
         "P_BACKUP_ENABLED",
         "P_MONITORING",
         "P_STATUS",
         to_char("P_CREATED",'yyyymmddhh24:mi:ss'),
         "P_CREATED_BY",
         to_char("P_UPDATED",'yyyymmddhh24:mi:ss'),
         "P_UPDATED_BY" ));
 
   end "BUILD_V_REQUEST_QUEUE_MD5";
   
      procedure insert_row (
      "P_ID"                     out number,
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default 'PROVISIONING',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default 'P',
      "P_EXTRA_VARS"             in clob                            default null  
   ) is 
 
   begin
 
      insert into "V_REQUEST_QUEUE" (
         "TEMPLATE_TYPE",
         "TEMPLATE_NAME",
         "JOB_NAME",
         "REQUEST_TYPE",
         "DB_OPTION",
         "HOST_NAME",
         "CLUSTER_NAME",
         "CLUSTER_TYPE",
         "GI_VERSION",
         "ENV_SOURCE",
         "TICKET_REF",
         "APPLICATION_NAME",
         "BUSINESS_UNIT",
         "NETWORK_TYPE",
         "ORACLE_VERSION",
         "OS_TYPE",
         "OS_TYPE_VERSION",
         "PHY_VERT",
         "CLUSTERED",
         "DC_LOCATION",
         "SERVER_MONITORING_TOOL",
         "ORACLE_DB_NAME",
         "DB_ENVIRONMENT",
         "RAC_TYPE",
         "DATABASE_ROLE",
         "ENV_CATEGORY",
         "STORAGE_TYPE",
         "DB_MONITORING_TOOL",
         "APPLIANCE",
         "PCI_REQUIRED",
         "SOX_REQUIRED",
         "ENCRYPTION_REQUIRED",
         "BACKUP_ENABLED",
         "MONITORING",
         "STATUS",
         "EXTRA_VARS"
      ) values ( 
         "P_TEMPLATE_TYPE",
         "P_TEMPLATE_NAME",
         "P_JOB_NAME",
         "P_REQUEST_TYPE",
         "P_DB_OPTION",
         "P_HOST_NAME",
         "P_CLUSTER_NAME",
         "P_CLUSTER_TYPE",
         "P_GI_VERSION",
         "P_ENV_SOURCE",
         "P_TICKET_REF",
         "P_APPLICATION_NAME",
         "P_BUSINESS_UNIT",
         "P_NETWORK_TYPE",
         "P_ORACLE_VERSION",
         "P_OS_TYPE",
         "P_OS_TYPE_VERSION",
         "P_PHY_VERT",
         "P_CLUSTERED",
         "P_DC_LOCATION",
         "P_SERVER_MONITORING_TOOL",
         "P_ORACLE_DB_NAME",
         "P_DB_ENVIRONMENT",
         "P_RAC_TYPE",
         "P_DATABASE_ROLE",
         "P_ENV_CATEGORY",
         "P_STORAGE_TYPE",
         "P_DB_MONITORING_TOOL",
         "P_APPLIANCE",
         "P_PCI_REQUIRED",
         "P_SOX_REQUIRED",
         "P_ENCRYPTION_REQUIRED",
         "P_BACKUP_ENABLED",
         "P_MONITORING",
         "P_STATUS",
         "P_EXTRA_VARS" 
      ) returning id into P_ID;
   end ;
 
   procedure insert_row (
      "P_TEMPLATE_TYPE"          in varchar2                        default null,
      "P_TEMPLATE_NAME"          in varchar2                        default null,
      "P_JOB_NAME"               in varchar2                        default null,
      "P_REQUEST_TYPE"           in varchar2                        default 'PROVISIONING',
      "P_DB_OPTION"              in varchar2                        default null,
      "P_HOST_NAME"              in clob                            default null,
      "P_CLUSTER_NAME"           in varchar2                        default null,
      "P_CLUSTER_TYPE"           in varchar2                        default null,
      "P_GI_VERSION"             in varchar2                        default null,
      "P_ENV_SOURCE"             in varchar2                        default null,
      "P_TICKET_REF"             in varchar2                        default null,
      "P_APPLICATION_NAME"       in varchar2                        default null,
      "P_BUSINESS_UNIT"          in varchar2                        default null,
      "P_NETWORK_TYPE"           in varchar2                        default null,
      "P_ORACLE_VERSION"         in varchar2                        default null,
      "P_OS_TYPE"                in varchar2                        default null,
      "P_OS_TYPE_VERSION"        in varchar2                        default null,
      "P_PHY_VERT"               in varchar2                        default null,
      "P_CLUSTERED"              in varchar2                        default null,
      "P_DC_LOCATION"            in varchar2                        default null,
      "P_SERVER_MONITORING_TOOL" in varchar2                        default null,
      "P_ORACLE_DB_NAME"         in varchar2                        default null,
      "P_DB_ENVIRONMENT"         in varchar2                        default null,
      "P_RAC_TYPE"               in varchar2                        default null,
      "P_DATABASE_ROLE"          in varchar2                        default null,
      "P_ENV_CATEGORY"           in varchar2                        default null,
      "P_STORAGE_TYPE"           in varchar2                        default null,
      "P_DB_MONITORING_TOOL"     in varchar2                        default null,
      "P_APPLIANCE"              in varchar2                        default null,
      "P_PCI_REQUIRED"           in varchar2                        default null,
      "P_SOX_REQUIRED"           in varchar2                        default null,
      "P_ENCRYPTION_REQUIRED"    in varchar2                        default null,
      "P_BACKUP_ENABLED"         in varchar2                        default null,
      "P_MONITORING"             in varchar2                        default null,
      "P_STATUS"                 in varchar2                        default 'P',
      "P_EXTRA_VARS"             in clob                            default null        
   ) is 
 
   begin
 
      insert into "V_REQUEST_QUEUE" (
         "TEMPLATE_TYPE",
         "TEMPLATE_NAME",
         "JOB_NAME",
         "REQUEST_TYPE",
         "DB_OPTION",
         "HOST_NAME",
         "CLUSTER_NAME",
         "CLUSTER_TYPE",
         "GI_VERSION",
         "ENV_SOURCE",
         "TICKET_REF",
         "APPLICATION_NAME",
         "BUSINESS_UNIT",
         "NETWORK_TYPE",
         "ORACLE_VERSION",
         "OS_TYPE",
         "OS_TYPE_VERSION",
         "PHY_VERT",
         "CLUSTERED",
         "DC_LOCATION",
         "SERVER_MONITORING_TOOL",
         "ORACLE_DB_NAME",
         "DB_ENVIRONMENT",
         "RAC_TYPE",
         "DATABASE_ROLE",
         "ENV_CATEGORY",
         "STORAGE_TYPE",
         "DB_MONITORING_TOOL",
         "APPLIANCE",
         "PCI_REQUIRED",
         "SOX_REQUIRED",
         "ENCRYPTION_REQUIRED",
         "BACKUP_ENABLED",
         "MONITORING",
         "STATUS",
         "EXTRA_VARS"
      ) values ( 
         "P_TEMPLATE_TYPE",
         "P_TEMPLATE_NAME",
         "P_JOB_NAME",
         "P_REQUEST_TYPE",
         "P_DB_OPTION",
         "P_HOST_NAME",
         "P_CLUSTER_NAME",
         "P_CLUSTER_TYPE",
         "P_GI_VERSION",
         "P_ENV_SOURCE",
         "P_TICKET_REF",
         "P_APPLICATION_NAME",
         "P_BUSINESS_UNIT",
         "P_NETWORK_TYPE",
         "P_ORACLE_VERSION",
         "P_OS_TYPE",
         "P_OS_TYPE_VERSION",
         "P_PHY_VERT",
         "P_CLUSTERED",
         "P_DC_LOCATION",
         "P_SERVER_MONITORING_TOOL",
         "P_ORACLE_DB_NAME",
         "P_DB_ENVIRONMENT",
         "P_RAC_TYPE",
         "P_DATABASE_ROLE",
         "P_ENV_CATEGORY",
         "P_STORAGE_TYPE",
         "P_DB_MONITORING_TOOL",
         "P_APPLIANCE",
         "P_PCI_REQUIRED",
         "P_SOX_REQUIRED",
         "P_ENCRYPTION_REQUIRED",
         "P_BACKUP_ENABLED",
         "P_MONITORING",
         "P_STATUS",
         "P_EXTRA_VARS"
      );
    end ;
    
end "V_REQUEST_QUEUE_API";

/
--------------------------------------------------------
--  DDL for Package Body V_REST_DEFINITIONS_API
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CHARTER2_INV"."V_REST_DEFINITIONS_API" 
is
    procedure get_row (
        p_id                           in number,
        P_schema_enable                out varchar2,
        P_schema_enable_flag           out varchar2,
        P_module_name                  out varchar2,
        P_uri_prefix                   out varchar2,
        P_uri_template                 out varchar2,
        P_method                       out varchar2,
        P_rest_action                  out varchar2,
        P_rest_code                    out clob,
        P_created                      out date,
        P_created_by                   out varchar2,
        P_updated                      out date,
        P_updated_by                   out varchar2
    )
    is
    begin
        for c1 in (select * from charter2_inv.v_rest_definitions where id = p_id) loop
            p_schema_enable := c1.schema_enable;
            p_schema_enable_flag := c1.schema_enable_flag;
            p_module_name := c1.module_name;
            p_uri_prefix := c1.uri_prefix;
            p_uri_template := c1.uri_template;
            p_method := c1.method;
            p_rest_action := c1.rest_action;
            p_rest_code := c1.rest_code;
            p_created := c1.created;
            p_created_by := c1.created_by;
            p_updated := c1.updated;
            p_updated_by := c1.updated_by;
        end loop;
    end get_row;
    procedure insert_row  (
        p_id                           out number  ,
        p_schema_enable                in varchar2 default null,
        p_schema_enable_flag           in varchar2 default null,
        p_module_name                  in varchar2 default null,
        p_uri_prefix                   in varchar2 default null,
        p_uri_template                 in varchar2 default null,
        p_method                       in varchar2 default null,
        p_rest_action                  in varchar2 default null,
        p_rest_code                    in clob default null
    )
    is
    begin
        insert into charter2_inv.v_rest_definitions (
            --id,
            schema_enable,
            schema_enable_flag,
            module_name,
            uri_prefix,
            uri_template,
            method,
            rest_action,
            rest_code
        ) values (
            --p_id,
            p_schema_enable,
            p_schema_enable_flag,
            p_module_name,
            p_uri_prefix,
            p_uri_template,
            p_method,
            p_rest_action,
            p_rest_code
        ) returning id into p_id;
    end insert_row;
    procedure update_row  (
        p_id                           in number default null,
        p_schema_enable                in varchar2 default null,
        p_schema_enable_flag           in varchar2 default null,
        p_module_name                  in varchar2 default null,
        p_uri_prefix                   in varchar2 default null,
        p_uri_template                 in varchar2 default null,
        p_method                       in varchar2 default null,
        p_rest_action                  in varchar2 default null,
        p_rest_code                    in clob default null
    )
    is
    begin
        update  charter2_inv.v_rest_definitions set
            --id = p_id,
            schema_enable = nvl(p_schema_enable,schema_enable),
            schema_enable_flag = nvl(p_schema_enable_flag,schema_enable_flag),
            module_name = nvl(p_module_name,module_name),
            uri_prefix = nvl(p_uri_prefix,uri_prefix),
            uri_template = nvl(p_uri_template,uri_template),
            method = nvl(p_method,method),
            rest_action = nvl(p_rest_action,rest_action),
            rest_code = nvl(p_rest_code,rest_code)
        where id = p_id;
    end update_row;
    procedure delete_row (
        p_id                           in number
    )
    is
    begin
        delete from charter2_inv.v_rest_definitions where id = p_id;
    end delete_row;
end v_rest_definitions_api;

/
--------------------------------------------------------
--  DDL for Function GET_HOST_CODE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "CHARTER2_INV"."GET_HOST_CODE" (
pENV_SOURCE in VARCHAR2 DEFAULT 'CHR'
) return VARCHAR2 as
PRAGMA AUTONOMOUS_TRANSACTION;
p_host_code  varchar2(10);

MAX_ENV_NUM   NUMBER:=0;
New_Num  NUMBER:=0;



Begin

  SELECT MAX(ENV_NUM) into MAX_ENV_NUM from charter2_inv.env_HOST_INFO
          where ENV_SOURCE = 'CHR' ;

          New_NUM := MAX_ENV_NUM +1;


         p_host_code := 'CHR' ||New_NUM;
    insert into env_HOST_INFO (host_code, ENV_SOURCE, ENV_NUM) 
                   VALUES  (p_host_code, 'CHR', New_NUM);

 commit;
    Return p_host_code;

    end;

/
--------------------------------------------------------
--  DDL for Function GET_ID
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "CHARTER2_INV"."GET_ID" (url varchar2) return number 
IS id number;
l_clob clob;
l_amount number;
l_offset number;
l_buffer varchar2(32767);

Begin
  apex_web_service.g_request_headers(1).name := 'Content-Type';
  apex_web_service.g_request_headers(1).value := 'application/json'; 
  -- host should be dbtest04.techlab.com 
  l_clob := apex_web_service.make_rest_request(
              p_url => url ,
              p_http_method => 'GET',
              p_username => 'apex' ,
              p_password => '0rac!3' ,
              p_wallet_path => 'file:/home/oracle/app/oracle/product/12.2.0/dbhome_1/user',
              p_wallet_pwd => 'oracle123' 
              );
                             
    l_amount := 32000;
    l_offset := 1;
    begin
        loop
            dbms_lob.read( l_clob, l_amount, l_offset, l_buffer );
            
            apex_json.parse(l_buffer);
             id := apex_json.get_varchar2(p_path => 'id')   ;
             --htp.p('ID : ' || apex_json.get_varchar2(p_path => 'id'));
            --htp.p('<br>');
            --htp.p(l_buffer);
            l_offset := l_offset + l_amount;
            l_amount := 32000;
        end loop;
             
    exception
      when no_data_found then
         null;
    end;
    
    Return id;
end;

/
--------------------------------------------------------
--  DDL for Function GET_NAME
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "CHARTER2_INV"."GET_NAME" (APEX_APP_ID NUMBER, TEMPLATE_ID NUMBER, APEX_FEATURE VARCHAR2) RETURN VARCHAR2
IS
NAME varchar2(200);
af varchar2(200) := APEX_FEATURE;
aid NUMBER := APEX_APP_ID;
tid NUMBER := TEMPLATE_ID;
BEGIN
 SELECT TEMPLATE_NAME INTO NAME FROM V_ANSIBLE_TEMPLATE_STORE WHERE APEX_FEATURE = af AND TEMPLATE_ID = tid AND  APEX_APP_ID = aid;
 RETURN NAME;
END;

/
--------------------------------------------------------
--  Constraints for Table DB_SCHEDULE_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."DB_SCHEDULE_TBL" MODIFY ("DB_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_STATS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STATS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STATS" ADD CONSTRAINT "EBA_DEMO_CHART_STATS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_CHECK_LIST_LOGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_CHECK_LIST_LOGS" MODIFY ("LOG_ID" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_CHECK_LIST_LOGS" MODIFY ("CHECK_LIST_ID" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_CHECK_LIST_LOGS" ADD CONSTRAINT "LOG_ID_PK" PRIMARY KEY ("LOG_ID") DISABLE;
--------------------------------------------------------
--  Constraints for Table V_DB_CHECK_LIST
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" MODIFY ("CHECK_LIST_ID" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" MODIFY ("CREATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" MODIFY ("CREATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" MODIFY ("UPDATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" MODIFY ("UPDATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_CHECK_LIST" ADD CONSTRAINT "V_DB_CHECK_LIST_ID_PK" PRIMARY KEY ("CHECK_LIST_ID") DISABLE;
--------------------------------------------------------
--  Constraints for Table LOGGER_PREFS_BY_CLIENT_ID
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" MODIFY ("CLIENT_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" MODIFY ("LOGGER_LEVEL" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" MODIFY ("INCLUDE_CALL_STACK" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" MODIFY ("CREATED_DATE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" MODIFY ("EXPIRY_DATE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" ADD CONSTRAINT "LOGGER_PREFS_BY_CLIENT_ID_CK1" CHECK (logger_level in ('OFF','PERMANENT','ERROR','WARNING','INFORMATION','DEBUG','TIMING', 'APEX', 'SYS_CONTEXT')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" ADD CONSTRAINT "LOGGER_PREFS_BY_CLIENT_ID_CK2" CHECK (expiry_date >= created_date) ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" ADD CONSTRAINT "LOGGER_PREFS_BY_CLIENT_ID_CK3" CHECK (include_call_stack in ('TRUE', 'FALSE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS_BY_CLIENT_ID" ADD CONSTRAINT "LOGGER_PREFS_BY_CLIENT_ID_PK" PRIMARY KEY ("CLIENT_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_BBALL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_BBALL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_BBALL" ADD CONSTRAINT "EBA_DEMO_CHART_BBALL_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LIC_DB_INVENTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" MODIFY ("CREATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" MODIFY ("CREATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" MODIFY ("UPDATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" MODIFY ("UPDATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_DB_INVENTORY" ADD CONSTRAINT "V_LIC_DB_INVENTORY_PK" PRIMARY KEY ("DATABASE_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table APEX$_ACL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("USERNAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("PRIV" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" ADD CONSTRAINT "APEX$_ACL_PRIV_CK" CHECK (priv in ('R','C','A')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_ACL" ADD CONSTRAINT "APEX$_ACL_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_PATCH_SCHEDULE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_PATCH_SCHEDULE" MODIFY ("PATCH_SCHED_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_SCHEDULE" MODIFY ("PATCH_DATE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_SCHEDULE" MODIFY ("PATCH_LOOKUP_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table APEX$_WS_ROWS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" MODIFY ("DATA_GRID_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" ADD CONSTRAINT "APEX$_WS_ROWS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_ROWS" ADD CONSTRAINT "APEX$_WS_ROWS_UK1" UNIQUE ("WS_APP_ID", "DATA_GRID_ID", "UNIQUE_VALUE")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_ORDERS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" MODIFY ("ORDER_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" ADD CONSTRAINT "EBA_DEMO_CHART_ORDER_PK" PRIMARY KEY ("ORDER_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_PROJECTS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" MODIFY ("PROJECT" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" ADD CONSTRAINT "EBA_DEMO_CHARTS_PROJ_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_APP_PERSON_ROLES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_APP_PERSON_ROLES" ADD CONSTRAINT "V_APP_PERSON_ROLES_PK" PRIMARY KEY ("PERSON_ID", "ROLE_ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_APP_PERSON_ROLES" MODIFY ("ROLE_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APP_PERSON_ROLES" MODIFY ("PERSON_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_LIC_DISCOVERY_SCHEDULE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_DISCOVERY_SCHEDULE" MODIFY ("LIC_SCHEDULE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_LIC_HOST_INV
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_HOST_INV" ADD CONSTRAINT "V_LIC_HOST_INV_PK" PRIMARY KEY ("HOST_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LIC_PRODUCT_USAGE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" MODIFY ("CREATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" MODIFY ("UPDATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_PRODUCT_USAGE" ADD CONSTRAINT "V_LIC_PRODUCT_USAGE_PK" PRIMARY KEY ("PRODUCT_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_TASK_STEP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" MODIFY ("STEP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_STEP" MODIFY ("TASK_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_STOCKS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STOCKS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_STOCKS" ADD CONSTRAINT "EBA_DEMO_CHART_STOCKS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table LOGGER_LOGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS" ADD CONSTRAINT "LOGGER_LOGS_LVL_CK" CHECK (logger_level in (1,2,4,8,16,32,64,128)) ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS" ADD CONSTRAINT "LOGGER_LOGS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS" MODIFY ("LOGGER_LEVEL" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS" MODIFY ("TIME_STAMP" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table LOGGER_PREFS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS" MODIFY ("PREF_VALUE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS" ADD CONSTRAINT "LOGGER_PREFS_PK" PRIMARY KEY ("PREF_TYPE", "PREF_NAME")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS" MODIFY ("PREF_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS" ADD CONSTRAINT "LOGGER_PREFS_CK1" CHECK (pref_name = upper(pref_name)) ENABLE;
  ALTER TABLE "CHARTER2_INV"."LOGGER_PREFS" ADD CONSTRAINT "LOGGER_PREFS_CK2" CHECK (pref_type = upper(pref_type)) ENABLE;
--------------------------------------------------------
--  Constraints for Table V_APP_PERSON
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_APP_PERSON" ADD CONSTRAINT "V_APP_PERSON_PK" PRIMARY KEY ("PERSON_ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_APP_PERSON" MODIFY ("PERSON_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_DB_PATCH_HISTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_DB_PATCH_HISTORY" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_HOST_INV_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" MODIFY ("UPDATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" MODIFY ("UPDATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" ADD CONSTRAINT "V_HOST_INV_TBL_ID_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table DEPT
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."DEPT" ADD PRIMARY KEY ("DEPTNO")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table MSSQL_TEAM_USERS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."MSSQL_TEAM_USERS" ADD CONSTRAINT "MSSQL_TEAM_USERS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_TASK
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK" MODIFY ("TASK_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table APEX$_WS_WEBPG_SECTION_HISTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" MODIFY ("SECTION_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" MODIFY ("WEBPAGE_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" MODIFY ("APPLICATION_USER_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTION_HISTORY" MODIFY ("CHANGE_DATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table APEX$_WS_LINKS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" MODIFY ("LINK_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" MODIFY ("URL" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" ADD CONSTRAINT "APEX$_WS_LINKS_CL_CK" CHECK (component_level in ('WEBSHEET','ROW','WORKSPACE','WEBPAGE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" ADD CONSTRAINT "APEX$_WS_LINKS_SH_CK" CHECK (show_on_homepage in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" ADD CONSTRAINT "APEX$_WS_LINKS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_APP_SETTINGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_APP_SETTINGS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APP_SETTINGS" MODIFY ("SETTING_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APP_SETTINGS" MODIFY ("SETTING_VALUE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APP_SETTINGS" ADD CONSTRAINT "V_APP_SETTINGS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LIC_BASELINE_JSONLOAD
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_BASELINE_JSONLOAD" ADD CONSTRAINT "V_LIC_BASELINE_JSON_PK" PRIMARY KEY ("JSON_LOAD_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_EMP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_EMP" MODIFY ("EMPNO" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ADD CONSTRAINT "EBA_DEMO_CHART_EMP_PK" PRIMARY KEY ("EMPNO")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_QUEUE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_QUEUE" MODIFY ("SCHEDULE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ENV_HOST_CODE_BACKUP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."ENV_HOST_CODE_BACKUP" MODIFY ("HOST_CODE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."ENV_HOST_CODE_BACKUP" MODIFY ("ENV_SOURCE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."ENV_HOST_CODE_BACKUP" MODIFY ("ENV_NUM" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_DB_SCHEDULE_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("UPDATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("UPDATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" MODIFY ("DB_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" ADD CONSTRAINT "V_DB_SCHEDULE_TBL_ID_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SELF_SERVICE_STATUS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SELF_SERVICE_STATUS" MODIFY ("REQUEST_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SELF_SERVICE_STATUS" MODIFY ("REQUEST_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SELF_SERVICE_STATUS" MODIFY ("JOB_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SELF_SERVICE_STATUS" MODIFY ("JOB_NO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_RESTDEMO_SAMPLE_LANG
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_LANG" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_LANG" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_LANG" ADD PRIMARY KEY ("NAME")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_ANSIBLE_API_RESULT
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_API_RESULT" MODIFY ("REQUEST_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_PROCESS_STATUS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_PROCESS_STATUS" MODIFY ("STATUS_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_PRODUCTS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" MODIFY ("PRODUCT_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" ADD CONSTRAINT "EBA_DEMO_CHART_PROD_PK" PRIMARY KEY ("PRODUCT_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_CLUSTER_MEMBER_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("CLUSTER_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("UPDATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("UPDATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" MODIFY ("V_HOST_CODE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" ADD CONSTRAINT "V_CLUSTER_MEMBER_T_ID_PK" PRIMARY KEY ("ID", "V_HOST_CODE")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table DB_CHECK_LIST
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."DB_CHECK_LIST" MODIFY ("DB_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."DB_CHECK_LIST" MODIFY ("EXECUTION_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."DB_CHECK_LIST" ADD CONSTRAINT "DB_CHECK_LIST_PK" PRIMARY KEY ("EXECUTION_ID", "DB_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_DEPT
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_DEPT" MODIFY ("DEPTNO" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_DEPT" ADD CONSTRAINT "EBA_DEMO_CHART_DEPT_PK" PRIMARY KEY ("DEPTNO")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table SOURCE_APP_UPDATE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."SOURCE_APP_UPDATE" ADD CONSTRAINT "SOURCE_APP_UPDATE_PK" PRIMARY KEY ("SOURCE_APP_UPDATE_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_APPLICATION_DETAILS_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" MODIFY ("UPDATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" MODIFY ("UPDATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_APPLICATION_DETAILS_TBL" ADD CONSTRAINT "V_APPLICATION_DETA_ID_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table APEX$_WS_NOTES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" ADD CONSTRAINT "APEX$_WS_NOTES_CL_CK" CHECK (component_level in ('WEBSHEET','ROW','WORKSPACE','WEBPAGE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" ADD CONSTRAINT "APEX$_WS_NOTES_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_PATCH_LOOKUP_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" MODIFY ("PATCH_FILE_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" MODIFY ("PATCH_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" MODIFY ("PATCH_STATUS" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_LOOKUP_TBL" ADD CONSTRAINT "LOOKUP_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table APEX$TEAM_DEV_FILES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" MODIFY ("COMPONENT_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" MODIFY ("COMPONENT_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" MODIFY ("FILENAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" ADD CONSTRAINT "WWV_VALID_ATDF_COMP_TY" CHECK (component_type in ('MILESTONE','FEATURE','BUG','FEEDBACK','TODO')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$TEAM_DEV_FILES" ADD PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table CLUSTER_MEMBER_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."CLUSTER_MEMBER_TBL" MODIFY ("HOST_CODE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."CLUSTER_MEMBER_TBL" ADD CONSTRAINT "PK_CLUSTER_NAME" PRIMARY KEY ("CLUSTER_NAME", "HOST_CODE")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_ANSIBLE_REST_LOGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("STATUS" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("UPDATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" MODIFY ("UPDATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_REST_LOGS" ADD CONSTRAINT "V_ANSIBLE_REST_LOGS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LIC_PRODUCT_PRICE_LIST
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_PRODUCT_PRICE_LIST" ADD CONSTRAINT "V_LIC_PRODUCT_PRICE_LIST_PK" PRIMARY KEY ("PRODUCT_PRICE_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_QUEUE_DETAIL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" MODIFY ("SCHEDULE_DETAIL_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_QUEUE_DETAIL" MODIFY ("SCHEDULE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_TASKS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" ADD CONSTRAINT "EBA_DEMO_CHART_TASKS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table LOGGER_LOGS_APEX_ITEMS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" MODIFY ("LOG_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" MODIFY ("APP_SESSION" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" MODIFY ("ITEM_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" ADD CONSTRAINT "LOGGER_LOGS_APX_ITMS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_HISTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_HISTORY" ADD CHECK (action in ('I','U','D')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_HISTORY" ADD PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_REGISTRY_SQLPATCH
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_REGISTRY_SQLPATCH" ADD CONSTRAINT "V_REGISTRY_SQLPATCH_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_REGISTRY_SQLPATCH" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_REQUEST_QUEUE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_REQUEST_QUEUE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_REQUEST_QUEUE" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_REQUEST_QUEUE" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_REQUEST_QUEUE" ADD CONSTRAINT "V_REQUEST_QUEUE_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORACLE_TEAM_USERS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."ORACLE_TEAM_USERS" ADD CONSTRAINT "ORACLE_TEAM_USERS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_RESTDEMO_SAMPLE_URLS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_URLS" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_URLS" MODIFY ("URL" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_RESTDEMO_SAMPLE_URLS" ADD PRIMARY KEY ("NAME")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LIC_PURCHASED_PRODUCTS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_PURCHASED_PRODUCTS" ADD CONSTRAINT "V_LIC_PURCHASED_PRODUCTS_PK" PRIMARY KEY ("PRODUCT_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table APEX$_WS_TAGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" ADD CONSTRAINT "APEX$_WS_TAGS_CL_CK" CHECK (component_level in ('WEBSHEET','ROW','WORKSPACE','WEBPAGE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" ADD CONSTRAINT "APEX$_WS_TAGS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_ANSIBLE_TEMPLATE_STORE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" MODIFY ("TEMPLATE_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" MODIFY ("TEMPLATE_STATUS" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" ADD CONSTRAINT "V_ANSIBLE_TEMPLATE_STORE_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_TEMPLATE_STORE" ADD CONSTRAINT "V_ANSIBLE_TEMPLATE_STORE_UK1" UNIQUE ("TEMPLATE_NAME")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_APP_ROLE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_APP_ROLE" ADD CONSTRAINT "V_APP_ROLE_PK" PRIMARY KEY ("ROLE_ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_APP_ROLE" MODIFY ("ROLE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_LICENSE_FEATURE_USAGE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LICENSE_FEATURE_USAGE" MODIFY ("FEATURE_BEING_USED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_LICENSE_FEATURE_USAGE" MODIFY ("DETECTED_USAGES" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_LICENSE_FEATURE_USAGE" MODIFY ("TOTAL_SAMPLES" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_LIC_BASELINE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_BASELINE" ADD CONSTRAINT "V_LIC_BASELINE_PK" PRIMARY KEY ("BASELINE_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_LOV_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LOV_TBL" MODIFY ("LOV_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_LOV_TBL" MODIFY ("LOV_VALUE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_LOV_TBL" MODIFY ("LOV_CATEGORY" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_TASK_PARMS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" MODIFY ("PARM_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_PARMS" MODIFY ("TASK_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_SAMPLE_DATA
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_DATA" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_DATA" ADD CONSTRAINT "EBA_DEMO_SAMPLE_DATA_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_SAMPLE_NAMES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" MODIFY ("SAMPLE_NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" ADD CONSTRAINT "EBA_DEMO_SAMPLES_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_GRADES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_GRADES" MODIFY ("SCHOOLB" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EMP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EMP" MODIFY ("EMPNO" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EMP" ADD PRIMARY KEY ("EMPNO")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_REST_DEFINITIONS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_REST_DEFINITIONS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_REST_DEFINITIONS" ADD CONSTRAINT "V_REST_DEFINI_SCHEMA_ENABLE_CC" CHECK (schema_enable_flag in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_REST_DEFINITIONS" ADD CONSTRAINT "V_REST_DEFINITI_REST_ACTION_CC" CHECK (rest_action in ('SELECT','INSERT','UPDATE','DELETE','SCHEMA_ENABLE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_REST_DEFINITIONS" ADD CONSTRAINT "V_REST_DEFINITIONS_ID_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table APEX$_WS_WEBPG_SECTIONS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" MODIFY ("SECTION_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTION_TYPE_CK" CHECK (section_type in ('TEXT','DATA','CHART','NAV_PAGE','NAV_SECTION','PLSQL')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTION_LINK_CK" CHECK (nav_include_link in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTION_AR_CK" CHECK (show_add_row in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTION_ER_CK" CHECK (show_edit_row in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTION_SER_CK" CHECK (show_search in ('Y','N')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_WEBPG_SECTIONS" ADD CONSTRAINT "APEX$_WS_WEBPG_SECTIONS_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table EBA_DEMO_CHART_POPULATION
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_POPULATION" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_POPULATION" ADD CONSTRAINT "EBA_DEMO_CHART_POP_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_ANSIBLE_INVENTORIES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_ANSIBLE_INVENTORIES" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_CSI_LIST
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_CSI_LIST" MODIFY ("CSI" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CSI_LIST" MODIFY ("CSI_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_CSI_LIST" MODIFY ("CSI_PRODUCT_TYPE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_LIC_FEATURE_USAGE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_LIC_FEATURE_USAGE" MODIFY ("CREATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_FEATURE_USAGE" MODIFY ("UPDATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_LIC_FEATURE_USAGE" ADD CONSTRAINT "V_LIC_FEATURE_USAGE_PK" PRIMARY KEY ("FEATURE_ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_SCHEDULE_TASK_REPORT
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" MODIFY ("REPORT_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_SCHEDULE_TASK_REPORT" MODIFY ("TASK_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table APEX$_WS_FILES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" MODIFY ("MIME_TYPE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" MODIFY ("CREATED_ON" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" ADD CONSTRAINT "APEX$_WS_FILES_CL_CK" CHECK (component_level in ('WEBSHEET','ROW','WORKSPACE','WEBPAGE')) ENABLE;
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" ADD CONSTRAINT "APEX$_WS_FILES_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_CSI_PRODUCT_LIST
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_CSI_PRODUCT_LIST" MODIFY ("CSI" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_ITSM_API_RESULT
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_ITSM_API_RESULT" MODIFY ("REQUEST_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table APEX$_WS_HISTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_HISTORY" MODIFY ("ROW_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_HISTORY" MODIFY ("WS_APP_ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."APEX$_WS_HISTORY" MODIFY ("DATA_GRID_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ENV_HOST_INFO
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."ENV_HOST_INFO" MODIFY ("HOST_CODE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."ENV_HOST_INFO" MODIFY ("ENV_SOURCE" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."ENV_HOST_INFO" MODIFY ("ENV_NUM" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table V_DB_INVENTORY
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" MODIFY ("CREATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" MODIFY ("CREATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" MODIFY ("UPDATED" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" MODIFY ("UPDATED_BY" NOT NULL DISABLE);
  ALTER TABLE "CHARTER2_INV"."V_DB_INVENTORY" ADD CONSTRAINT "V_DB_INVENTORY_ID_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
--------------------------------------------------------
--  Constraints for Table V_PATCH_REQUEST_QUEUE
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" ADD CONSTRAINT "V_PATCH_REQUEST_QUEUE_PK" PRIMARY KEY ("ID")
  USING INDEX  ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" MODIFY ("CREATED" NOT NULL ENABLE);
  ALTER TABLE "CHARTER2_INV"."V_PATCH_REQUEST_QUEUE" MODIFY ("CREATED_BY" NOT NULL ENABLE);
--------------------------------------------------------
--  Ref Constraints for Table APEX$_WS_FILES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_FILES" ADD CONSTRAINT "APEX$_WS_FILES_FK" FOREIGN KEY ("ROW_ID")
	  REFERENCES "CHARTER2_INV"."APEX$_WS_ROWS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table APEX$_WS_LINKS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_LINKS" ADD CONSTRAINT "APEX$_WS_LINKS_FK" FOREIGN KEY ("ROW_ID")
	  REFERENCES "CHARTER2_INV"."APEX$_WS_ROWS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table APEX$_WS_NOTES
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_NOTES" ADD CONSTRAINT "APEX$_WS_NOTES_FK" FOREIGN KEY ("ROW_ID")
	  REFERENCES "CHARTER2_INV"."APEX$_WS_ROWS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table APEX$_WS_TAGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."APEX$_WS_TAGS" ADD CONSTRAINT "APEX$_WS_TAGS_FK" FOREIGN KEY ("ROW_ID")
	  REFERENCES "CHARTER2_INV"."APEX$_WS_ROWS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EBA_DEMO_CHART_EMP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ADD FOREIGN KEY ("MGR")
	  REFERENCES "CHARTER2_INV"."EBA_DEMO_CHART_EMP" ("EMPNO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EBA_DEMO_CHART_ORDERS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_ORDERS" ADD CONSTRAINT "EBA_DEMO_CHART_ORDER_FK" FOREIGN KEY ("PRODUCT_ID")
	  REFERENCES "CHARTER2_INV"."EBA_DEMO_CHART_PRODUCTS" ("PRODUCT_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EBA_DEMO_CHART_SAMPLE_DATA
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_DATA" ADD FOREIGN KEY ("SAMPLE_ID")
	  REFERENCES "CHARTER2_INV"."EBA_DEMO_CHART_SAMPLE_NAMES" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EBA_DEMO_CHART_TASKS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EBA_DEMO_CHART_TASKS" ADD CONSTRAINT "EBA_DEMO_CHART_TASKS_FK" FOREIGN KEY ("PROJECT")
	  REFERENCES "CHARTER2_INV"."EBA_DEMO_CHART_PROJECTS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EMP
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."EMP" ADD FOREIGN KEY ("MGR")
	  REFERENCES "CHARTER2_INV"."EMP" ("EMPNO") ENABLE;
  ALTER TABLE "CHARTER2_INV"."EMP" ADD FOREIGN KEY ("DEPTNO")
	  REFERENCES "CHARTER2_INV"."DEPT" ("DEPTNO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LOGGER_LOGS_APEX_ITEMS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."LOGGER_LOGS_APEX_ITEMS" ADD CONSTRAINT "LOGGER_LOGS_APX_ITMS_FK" FOREIGN KEY ("LOG_ID")
	  REFERENCES "CHARTER2_INV"."LOGGER_LOGS" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table V_CHECK_LIST_LOGS
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_CHECK_LIST_LOGS" ADD CONSTRAINT "V_CHECK_LIST_LOGS_FK1" FOREIGN KEY ("CHECK_LIST_ID")
	  REFERENCES "CHARTER2_INV"."V_DB_CHECK_LIST" ("CHECK_LIST_ID") ON DELETE CASCADE DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table V_DB_SCHEDULE_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_DB_SCHEDULE_TBL" ADD CONSTRAINT "V_DB_INVNTRY_DB_SCHED_FK" FOREIGN KEY ("DB_ID")
	  REFERENCES "CHARTER2_INV"."V_DB_INVENTORY" ("ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table V_HOST_INV_TBL
--------------------------------------------------------

  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" ADD CONSTRAINT "V_HOST_INV_TBL_FK1" FOREIGN KEY ("CLUSTER_ID", "HOST_CODE")
	  REFERENCES "CHARTER2_INV"."V_CLUSTER_MEMBER_TBL" ("ID", "V_HOST_CODE") ENABLE;
  ALTER TABLE "CHARTER2_INV"."V_HOST_INV_TBL" ADD CONSTRAINT "FK_DB_ID" FOREIGN KEY ("DB_ID")
	  REFERENCES "CHARTER2_INV"."V_DB_INVENTORY" ("ID") ENABLE;
